"use strict"; (self.webpackChunkflo_client_plugin = self.webpackChunkflo_client_plugin || []).push([[429], { 435: (ie, Ee, de) => { de(583) }, 583: () => { !function (e) { const n = e.performance; function i(M) { n && n.mark && n.mark(M) } function o(M, E) { n && n.measure && n.measure(M, E) } i("Zone"); const c = e.__Zone_symbol_prefix || "__zone_symbol__"; function a(M) { return c + M } const y = !0 === e[a("forceDuplicateZoneCheck")]; if (e.Zone) { if (y || "function" != typeof e.Zone.__symbol__) throw new Error("Zone already loaded."); return e.Zone } let d = (() => { class M { constructor(t, r) { this._parent = t, this._name = r ? r.name || "unnamed" : "<root>", this._properties = r && r.properties || {}, this._zoneDelegate = new v(this, this._parent && this._parent._zoneDelegate, r) } static assertZonePatched() { if (e.Promise !== oe.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)") } static get root() { let t = M.current; for (; t.parent;)t = t.parent; return t } static get current() { return U.zone } static get currentTask() { return re } static __load_patch(t, r, k = !1) { if (oe.hasOwnProperty(t)) { if (!k && y) throw Error("Already loaded patch: " + t) } else if (!e["__Zone_disable_" + t]) { const C = "Zone:" + t; i(C), oe[t] = r(e, M, z), o(C, C) } } get parent() { return this._parent } get name() { return this._name } get(t) { const r = this.getZoneWith(t); if (r) return r._properties[t] } getZoneWith(t) { let r = this; for (; r;) { if (r._properties.hasOwnProperty(t)) return r; r = r._parent } return null } fork(t) { if (!t) throw new Error("ZoneSpec required!"); return this._zoneDelegate.fork(this, t) } wrap(t, r) { if ("function" != typeof t) throw new Error("Expecting function got: " + t); const k = this._zoneDelegate.intercept(this, t, r), C = this; return function () { return C.runGuarded(k, this, arguments, r) } } run(t, r, k, C) { U = { parent: U, zone: this }; try { return this._zoneDelegate.invoke(this, t, r, k, C) } finally { U = U.parent } } runGuarded(t, r = null, k, C) { U = { parent: U, zone: this }; try { try { return this._zoneDelegate.invoke(this, t, r, k, C) } catch ($) { if (this._zoneDelegate.handleError(this, $)) throw $ } } finally { U = U.parent } } runTask(t, r, k) { if (t.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (t.zone || K).name + "; Execution: " + this.name + ")"); if (t.state === x && (t.type === Q || t.type === w)) return; const C = t.state != p; C && t._transitionTo(p, j), t.runCount++; const $ = re; re = t, U = { parent: U, zone: this }; try { t.type == w && t.data && !t.data.isPeriodic && (t.cancelFn = void 0); try { return this._zoneDelegate.invokeTask(this, t, r, k) } catch (l) { if (this._zoneDelegate.handleError(this, l)) throw l } } finally { t.state !== x && t.state !== h && (t.type == Q || t.data && t.data.isPeriodic ? C && t._transitionTo(j, p) : (t.runCount = 0, this._updateTaskCount(t, -1), C && t._transitionTo(x, p, x))), U = U.parent, re = $ } } scheduleTask(t) { if (t.zone && t.zone !== this) { let k = this; for (; k;) { if (k === t.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`); k = k.parent } } t._transitionTo(X, x); const r = []; t._zoneDelegates = r, t._zone = this; try { t = this._zoneDelegate.scheduleTask(this, t) } catch (k) { throw t._transitionTo(h, X, x), this._zoneDelegate.handleError(this, k), k } return t._zoneDelegates === r && this._updateTaskCount(t, 1), t.state == X && t._transitionTo(j, X), t } scheduleMicroTask(t, r, k, C) { return this.scheduleTask(new m(I, t, r, k, C, void 0)) } scheduleMacroTask(t, r, k, C, $) { return this.scheduleTask(new m(w, t, r, k, C, $)) } scheduleEventTask(t, r, k, C, $) { return this.scheduleTask(new m(Q, t, r, k, C, $)) } cancelTask(t) { if (t.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (t.zone || K).name + "; Execution: " + this.name + ")"); t._transitionTo(G, j, p); try { this._zoneDelegate.cancelTask(this, t) } catch (r) { throw t._transitionTo(h, G), this._zoneDelegate.handleError(this, r), r } return this._updateTaskCount(t, -1), t._transitionTo(x, G), t.runCount = 0, t } _updateTaskCount(t, r) { const k = t._zoneDelegates; -1 == r && (t._zoneDelegates = null); for (let C = 0; C < k.length; C++)k[C]._updateTaskCount(t.type, r) } } return M.__symbol__ = a, M })(); const P = { name: "", onHasTask: (M, E, t, r) => M.hasTask(t, r), onScheduleTask: (M, E, t, r) => M.scheduleTask(t, r), onInvokeTask: (M, E, t, r, k, C) => M.invokeTask(t, r, k, C), onCancelTask: (M, E, t, r) => M.cancelTask(t, r) }; class v { constructor(E, t, r) { this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }, this.zone = E, this._parentDelegate = t, this._forkZS = r && (r && r.onFork ? r : t._forkZS), this._forkDlgt = r && (r.onFork ? t : t._forkDlgt), this._forkCurrZone = r && (r.onFork ? this.zone : t._forkCurrZone), this._interceptZS = r && (r.onIntercept ? r : t._interceptZS), this._interceptDlgt = r && (r.onIntercept ? t : t._interceptDlgt), this._interceptCurrZone = r && (r.onIntercept ? this.zone : t._interceptCurrZone), this._invokeZS = r && (r.onInvoke ? r : t._invokeZS), this._invokeDlgt = r && (r.onInvoke ? t : t._invokeDlgt), this._invokeCurrZone = r && (r.onInvoke ? this.zone : t._invokeCurrZone), this._handleErrorZS = r && (r.onHandleError ? r : t._handleErrorZS), this._handleErrorDlgt = r && (r.onHandleError ? t : t._handleErrorDlgt), this._handleErrorCurrZone = r && (r.onHandleError ? this.zone : t._handleErrorCurrZone), this._scheduleTaskZS = r && (r.onScheduleTask ? r : t._scheduleTaskZS), this._scheduleTaskDlgt = r && (r.onScheduleTask ? t : t._scheduleTaskDlgt), this._scheduleTaskCurrZone = r && (r.onScheduleTask ? this.zone : t._scheduleTaskCurrZone), this._invokeTaskZS = r && (r.onInvokeTask ? r : t._invokeTaskZS), this._invokeTaskDlgt = r && (r.onInvokeTask ? t : t._invokeTaskDlgt), this._invokeTaskCurrZone = r && (r.onInvokeTask ? this.zone : t._invokeTaskCurrZone), this._cancelTaskZS = r && (r.onCancelTask ? r : t._cancelTaskZS), this._cancelTaskDlgt = r && (r.onCancelTask ? t : t._cancelTaskDlgt), this._cancelTaskCurrZone = r && (r.onCancelTask ? this.zone : t._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null; const k = r && r.onHasTask; (k || t && t._hasTaskZS) && (this._hasTaskZS = k ? r : P, this._hasTaskDlgt = t, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = E, r.onScheduleTask || (this._scheduleTaskZS = P, this._scheduleTaskDlgt = t, this._scheduleTaskCurrZone = this.zone), r.onInvokeTask || (this._invokeTaskZS = P, this._invokeTaskDlgt = t, this._invokeTaskCurrZone = this.zone), r.onCancelTask || (this._cancelTaskZS = P, this._cancelTaskDlgt = t, this._cancelTaskCurrZone = this.zone)) } fork(E, t) { return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, E, t) : new d(E, t) } intercept(E, t, r) { return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, E, t, r) : t } invoke(E, t, r, k, C) { return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, E, t, r, k, C) : t.apply(r, k) } handleError(E, t) { return !this._handleErrorZS || this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, E, t) } scheduleTask(E, t) { let r = t; if (this._scheduleTaskZS) this._hasTaskZS && r._zoneDelegates.push(this._hasTaskDlgtOwner), r = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, E, t), r || (r = t); else if (t.scheduleFn) t.scheduleFn(t); else { if (t.type != I) throw new Error("Task is missing scheduleFn."); R(t) } return r } invokeTask(E, t, r, k) { return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, E, t, r, k) : t.callback.apply(r, k) } cancelTask(E, t) { let r; if (this._cancelTaskZS) r = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, E, t); else { if (!t.cancelFn) throw Error("Task is not cancelable"); r = t.cancelFn(t) } return r } hasTask(E, t) { try { this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, E, t) } catch (r) { this.handleError(E, r) } } _updateTaskCount(E, t) { const r = this._taskCounts, k = r[E], C = r[E] = k + t; if (C < 0) throw new Error("More tasks executed then were scheduled."); 0 != k && 0 != C || this.hasTask(this.zone, { microTask: r.microTask > 0, macroTask: r.macroTask > 0, eventTask: r.eventTask > 0, change: E }) } } class m { constructor(E, t, r, k, C, $) { if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = E, this.source = t, this.data = k, this.scheduleFn = C, this.cancelFn = $, !r) throw new Error("callback is not defined"); this.callback = r; const l = this; this.invoke = E === Q && k && k.useG ? m.invokeTask : function () { return m.invokeTask.call(e, l, this, arguments) } } static invokeTask(E, t, r) { E || (E = this), ee++; try { return E.runCount++, E.zone.runTask(E, t, r) } finally { 1 == ee && _(), ee-- } } get zone() { return this._zone } get state() { return this._state } cancelScheduleRequest() { this._transitionTo(x, X) } _transitionTo(E, t, r) { if (this._state !== t && this._state !== r) throw new Error(`${this.type} '${this.source}': can not transition to '${E}', expecting state '${t}'${r ? " or '" + r + "'" : ""}, was '${this._state}'.`); this._state = E, E == x && (this._zoneDelegates = null) } toString() { return this.data && typeof this.data.handleId < "u" ? this.data.handleId.toString() : Object.prototype.toString.call(this) } toJSON() { return { type: this.type, state: this.state, source: this.source, zone: this.zone.name, runCount: this.runCount } } } const L = a("setTimeout"), Z = a("Promise"), N = a("then"); let J, B = [], H = !1; function q(M) { if (J || e[Z] && (J = e[Z].resolve(0)), J) { let E = J[N]; E || (E = J.then), E.call(J, M) } else e[L](M, 0) } function R(M) { 0 === ee && 0 === B.length && q(_), M && B.push(M) } function _() { if (!H) { for (H = !0; B.length;) { const M = B; B = []; for (let E = 0; E < M.length; E++) { const t = M[E]; try { t.zone.runTask(t, null, null) } catch (r) { z.onUnhandledError(r) } } } z.microtaskDrainDone(), H = !1 } } const K = { name: "NO ZONE" }, x = "notScheduled", X = "scheduling", j = "scheduled", p = "running", G = "canceling", h = "unknown", I = "microTask", w = "macroTask", Q = "eventTask", oe = {}, z = { symbol: a, currentZoneFrame: () => U, onUnhandledError: W, microtaskDrainDone: W, scheduleMicroTask: R, showUncaughtError: () => !d[a("ignoreConsoleErrorUncaughtError")], patchEventTarget: () => [], patchOnProperties: W, patchMethod: () => W, bindArguments: () => [], patchThen: () => W, patchMacroTask: () => W, patchEventPrototype: () => W, isIEOrEdge: () => !1, getGlobalObjects: () => { }, ObjectDefineProperty: () => W, ObjectGetOwnPropertyDescriptor: () => { }, ObjectCreate: () => { }, ArraySlice: () => [], patchClass: () => W, wrapWithCurrentZone: () => W, filterProperties: () => [], attachOriginToPatched: () => W, _redefineProperty: () => W, patchCallbacks: () => W, nativeScheduleMicroTask: q }; let U = { parent: null, zone: new d(null, null) }, re = null, ee = 0; function W() { } o("Zone", "Zone"), e.Zone = d }(typeof window < "u" && window || typeof self < "u" && self || global); const ie = Object.getOwnPropertyDescriptor, Ee = Object.defineProperty, de = Object.getPrototypeOf, ge = Object.create, Ve = Array.prototype.slice, Oe = "addEventListener", Se = "removeEventListener", Ze = Zone.__symbol__(Oe), Ne = Zone.__symbol__(Se), ce = "true", ae = "false", ke = Zone.__symbol__(""); function Ie(e, n) { return Zone.current.wrap(e, n) } function Me(e, n, i, o, c) { return Zone.current.scheduleMacroTask(e, n, i, o, c) } const A = Zone.__symbol__, Pe = typeof window < "u", Te = Pe ? window : void 0, Y = Pe && Te || "object" == typeof self && self || global, ct = "removeAttribute"; function Le(e, n) { for (let i = e.length - 1; i >= 0; i--)"function" == typeof e[i] && (e[i] = Ie(e[i], n + "_" + i)); return e } function Fe(e) { return !e || !1 !== e.writable && !("function" == typeof e.get && typeof e.set > "u") } const Be = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, we = !("nw" in Y) && typeof Y.process < "u" && "[object process]" === {}.toString.call(Y.process), je = !we && !Be && !(!Pe || !Te.HTMLElement), Ue = typeof Y.process < "u" && "[object process]" === {}.toString.call(Y.process) && !Be && !(!Pe || !Te.HTMLElement), Re = {}, We = function (e) { if (!(e = e || Y.event)) return; let n = Re[e.type]; n || (n = Re[e.type] = A("ON_PROPERTY" + e.type)); const i = this || e.target || Y, o = i[n]; let c; return je && i === Te && "error" === e.type ? (c = o && o.call(this, e.message, e.filename, e.lineno, e.colno, e.error), !0 === c && e.preventDefault()) : (c = o && o.apply(this, arguments), null != c && !c && e.preventDefault()), c }; function qe(e, n, i) { let o = ie(e, n); if (!o && i && ie(i, n) && (o = { enumerable: !0, configurable: !0 }), !o || !o.configurable) return; const c = A("on" + n + "patched"); if (e.hasOwnProperty(c) && e[c]) return; delete o.writable, delete o.value; const a = o.get, y = o.set, d = n.slice(2); let P = Re[d]; P || (P = Re[d] = A("ON_PROPERTY" + d)), o.set = function (v) { let m = this; !m && e === Y && (m = Y), m && ("function" == typeof m[P] && m.removeEventListener(d, We), y && y.call(m, null), m[P] = v, "function" == typeof v && m.addEventListener(d, We, !1)) }, o.get = function () { let v = this; if (!v && e === Y && (v = Y), !v) return null; const m = v[P]; if (m) return m; if (a) { let L = a.call(this); if (L) return o.set.call(this, L), "function" == typeof v[ct] && v.removeAttribute(n), L } return null }, Ee(e, n, o), e[c] = !0 } function Xe(e, n, i) { if (n) for (let o = 0; o < n.length; o++)qe(e, "on" + n[o], i); else { const o = []; for (const c in e) "on" == c.slice(0, 2) && o.push(c); for (let c = 0; c < o.length; c++)qe(e, o[c], i) } } const ne = A("originalInstance"); function ve(e) { const n = Y[e]; if (!n) return; Y[A(e)] = n, Y[e] = function () { const c = Le(arguments, e); switch (c.length) { case 0: this[ne] = new n; break; case 1: this[ne] = new n(c[0]); break; case 2: this[ne] = new n(c[0], c[1]); break; case 3: this[ne] = new n(c[0], c[1], c[2]); break; case 4: this[ne] = new n(c[0], c[1], c[2], c[3]); break; default: throw new Error("Arg list too long.") } }, ue(Y[e], n); const i = new n(function () { }); let o; for (o in i) "XMLHttpRequest" === e && "responseBlob" === o || function (c) { "function" == typeof i[c] ? Y[e].prototype[c] = function () { return this[ne][c].apply(this[ne], arguments) } : Ee(Y[e].prototype, c, { set: function (a) { "function" == typeof a ? (this[ne][c] = Ie(a, e + "." + c), ue(this[ne][c], a)) : this[ne][c] = a }, get: function () { return this[ne][c] } }) }(o); for (o in n) "prototype" !== o && n.hasOwnProperty(o) && (Y[e][o] = n[o]) } function le(e, n, i) { let o = e; for (; o && !o.hasOwnProperty(n);)o = de(o); !o && e[n] && (o = e); const c = A(n); let a = null; if (o && (!(a = o[c]) || !o.hasOwnProperty(c)) && (a = o[c] = o[n], Fe(o && ie(o, n)))) { const d = i(a, c, n); o[n] = function () { return d(this, arguments) }, ue(o[n], a) } return a } function lt(e, n, i) { let o = null; function c(a) { const y = a.data; return y.args[y.cbIdx] = function () { a.invoke.apply(this, arguments) }, o.apply(y.target, y.args), a } o = le(e, n, a => function (y, d) { const P = i(y, d); return P.cbIdx >= 0 && "function" == typeof d[P.cbIdx] ? Me(P.name, d[P.cbIdx], P, c) : a.apply(y, d) }) } function ue(e, n) { e[A("OriginalDelegate")] = n } let ze = !1, Ae = !1; function ft() { if (ze) return Ae; ze = !0; try { const e = Te.navigator.userAgent; (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/") || -1 !== e.indexOf("Edge/")) && (Ae = !0) } catch { } return Ae } Zone.__load_patch("ZoneAwarePromise", (e, n, i) => { const o = Object.getOwnPropertyDescriptor, c = Object.defineProperty, y = i.symbol, d = [], P = !0 === e[y("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")], v = y("Promise"), m = y("then"), L = "__creationTrace__"; i.onUnhandledError = l => { if (i.showUncaughtError()) { const u = l && l.rejection; u ? console.error("Unhandled Promise rejection:", u instanceof Error ? u.message : u, "; Zone:", l.zone.name, "; Task:", l.task && l.task.source, "; Value:", u, u instanceof Error ? u.stack : void 0) : console.error(l) } }, i.microtaskDrainDone = () => { for (; d.length;) { const l = d.shift(); try { l.zone.runGuarded(() => { throw l.throwOriginal ? l.rejection : l }) } catch (u) { N(u) } } }; const Z = y("unhandledPromiseRejectionHandler"); function N(l) { i.onUnhandledError(l); try { const u = n[Z]; "function" == typeof u && u.call(this, l) } catch { } } function B(l) { return l && l.then } function H(l) { return l } function J(l) { return t.reject(l) } const q = y("state"), R = y("value"), _ = y("finally"), K = y("parentPromiseValue"), x = y("parentPromiseState"), X = "Promise.then", j = null, p = !0, G = !1, h = 0; function I(l, u) { return s => { try { z(l, u, s) } catch (f) { z(l, !1, f) } } } const w = function () { let l = !1; return function (s) { return function () { l || (l = !0, s.apply(null, arguments)) } } }, Q = "Promise resolved with itself", oe = y("currentTaskTrace"); function z(l, u, s) { const f = w(); if (l === s) throw new TypeError(Q); if (l[q] === j) { let g = null; try { ("object" == typeof s || "function" == typeof s) && (g = s && s.then) } catch (b) { return f(() => { z(l, !1, b) })(), l } if (u !== G && s instanceof t && s.hasOwnProperty(q) && s.hasOwnProperty(R) && s[q] !== j) re(s), z(l, s[q], s[R]); else if (u !== G && "function" == typeof g) try { g.call(s, f(I(l, u)), f(I(l, !1))) } catch (b) { f(() => { z(l, !1, b) })() } else { l[q] = u; const b = l[R]; if (l[R] = s, l[_] === _ && u === p && (l[q] = l[x], l[R] = l[K]), u === G && s instanceof Error) { const T = n.currentTask && n.currentTask.data && n.currentTask.data[L]; T && c(s, oe, { configurable: !0, enumerable: !1, writable: !0, value: T }) } for (let T = 0; T < b.length;)ee(l, b[T++], b[T++], b[T++], b[T++]); if (0 == b.length && u == G) { l[q] = h; let T = s; try { throw new Error("Uncaught (in promise): " + function a(l) { return l && l.toString === Object.prototype.toString ? (l.constructor && l.constructor.name || "") + ": " + JSON.stringify(l) : l ? l.toString() : Object.prototype.toString.call(l) }(s) + (s && s.stack ? "\n" + s.stack : "")) } catch (D) { T = D } P && (T.throwOriginal = !0), T.rejection = s, T.promise = l, T.zone = n.current, T.task = n.currentTask, d.push(T), i.scheduleMicroTask() } } } return l } const U = y("rejectionHandledHandler"); function re(l) { if (l[q] === h) { try { const u = n[U]; u && "function" == typeof u && u.call(this, { rejection: l[R], promise: l }) } catch { } l[q] = G; for (let u = 0; u < d.length; u++)l === d[u].promise && d.splice(u, 1) } } function ee(l, u, s, f, g) { re(l); const b = l[q], T = b ? "function" == typeof f ? f : H : "function" == typeof g ? g : J; u.scheduleMicroTask(X, () => { try { const D = l[R], O = !!s && _ === s[_]; O && (s[K] = D, s[x] = b); const S = u.run(T, void 0, O && T !== J && T !== H ? [] : [D]); z(s, !0, S) } catch (D) { z(s, !1, D) } }, s) } const M = function () { }, E = e.AggregateError; class t { static toString() { return "function ZoneAwarePromise() { [native code] }" } static resolve(u) { return z(new this(null), p, u) } static reject(u) { return z(new this(null), G, u) } static any(u) { if (!u || "function" != typeof u[Symbol.iterator]) return Promise.reject(new E([], "All promises were rejected")); const s = []; let f = 0; try { for (let T of u) f++, s.push(t.resolve(T)) } catch { return Promise.reject(new E([], "All promises were rejected")) } if (0 === f) return Promise.reject(new E([], "All promises were rejected")); let g = !1; const b = []; return new t((T, D) => { for (let O = 0; O < s.length; O++)s[O].then(S => { g || (g = !0, T(S)) }, S => { b.push(S), f--, 0 === f && (g = !0, D(new E(b, "All promises were rejected"))) }) }) } static race(u) { let s, f, g = new this((D, O) => { s = D, f = O }); function b(D) { s(D) } function T(D) { f(D) } for (let D of u) B(D) || (D = this.resolve(D)), D.then(b, T); return g } static all(u) { return t.allWithCallback(u) } static allSettled(u) { return (this && this.prototype instanceof t ? this : t).allWithCallback(u, { thenCallback: f => ({ status: "fulfilled", value: f }), errorCallback: f => ({ status: "rejected", reason: f }) }) } static allWithCallback(u, s) { let f, g, b = new this((S, V) => { f = S, g = V }), T = 2, D = 0; const O = []; for (let S of u) { B(S) || (S = this.resolve(S)); const V = D; try { S.then(F => { O[V] = s ? s.thenCallback(F) : F, T--, 0 === T && f(O) }, F => { s ? (O[V] = s.errorCallback(F), T--, 0 === T && f(O)) : g(F) }) } catch (F) { g(F) } T++, D++ } return T -= 2, 0 === T && f(O), b } constructor(u) { const s = this; if (!(s instanceof t)) throw new Error("Must be an instanceof Promise."); s[q] = j, s[R] = []; try { const f = w(); u && u(f(I(s, p)), f(I(s, G))) } catch (f) { z(s, !1, f) } } get [Symbol.toStringTag]() { return "Promise" } get [Symbol.species]() { return t } then(u, s) { var f; let g = null === (f = this.constructor) || void 0 === f ? void 0 : f[Symbol.species]; (!g || "function" != typeof g) && (g = this.constructor || t); const b = new g(M), T = n.current; return this[q] == j ? this[R].push(T, b, u, s) : ee(this, T, b, u, s), b } catch(u) { return this.then(null, u) } finally(u) { var s; let f = null === (s = this.constructor) || void 0 === s ? void 0 : s[Symbol.species]; (!f || "function" != typeof f) && (f = t); const g = new f(M); g[_] = _; const b = n.current; return this[q] == j ? this[R].push(b, g, u, u) : ee(this, b, g, u, u), g } } t.resolve = t.resolve, t.reject = t.reject, t.race = t.race, t.all = t.all; const r = e[v] = e.Promise; e.Promise = t; const k = y("thenPatched"); function C(l) { const u = l.prototype, s = o(u, "then"); if (s && (!1 === s.writable || !s.configurable)) return; const f = u.then; u[m] = f, l.prototype.then = function (g, b) { return new t((D, O) => { f.call(this, D, O) }).then(g, b) }, l[k] = !0 } return i.patchThen = C, r && (C(r), le(e, "fetch", l => function $(l) { return function (u, s) { let f = l.apply(u, s); if (f instanceof t) return f; let g = f.constructor; return g[k] || C(g), f } }(l))), Promise[n.__symbol__("uncaughtPromiseErrors")] = d, t }), Zone.__load_patch("toString", e => { const n = Function.prototype.toString, i = A("OriginalDelegate"), o = A("Promise"), c = A("Error"), a = function () { if ("function" == typeof this) { const v = this[i]; if (v) return "function" == typeof v ? n.call(v) : Object.prototype.toString.call(v); if (this === Promise) { const m = e[o]; if (m) return n.call(m) } if (this === Error) { const m = e[c]; if (m) return n.call(m) } } return n.call(this) }; a[i] = n, Function.prototype.toString = a; const y = Object.prototype.toString; Object.prototype.toString = function () { return "function" == typeof Promise && this instanceof Promise ? "[object Promise]" : y.call(this) } }); let ye = !1; if (typeof window < "u") try { const e = Object.defineProperty({}, "passive", { get: function () { ye = !0 } }); window.addEventListener("test", e, e), window.removeEventListener("test", e, e) } catch { ye = !1 } const ht = { useG: !0 }, te = {}, Ye = {}, $e = new RegExp("^" + ke + "(\\w+)(true|false)$"), Ke = A("propagationStopped"); function Je(e, n) { const i = (n ? n(e) : e) + ae, o = (n ? n(e) : e) + ce, c = ke + i, a = ke + o; te[e] = {}, te[e][ae] = c, te[e][ce] = a } function dt(e, n, i, o) { const c = o && o.add || Oe, a = o && o.rm || Se, y = o && o.listeners || "eventListeners", d = o && o.rmAll || "removeAllListeners", P = A(c), v = "." + c + ":", m = "prependListener", L = "." + m + ":", Z = function (R, _, K) { if (R.isRemoved) return; const x = R.callback; let X; "object" == typeof x && x.handleEvent && (R.callback = p => x.handleEvent(p), R.originalDelegate = x); try { R.invoke(R, _, [K]) } catch (p) { X = p } const j = R.options; return j && "object" == typeof j && j.once && _[a].call(_, K.type, R.originalDelegate ? R.originalDelegate : R.callback, j), X }; function N(R, _, K) { if (!(_ = _ || e.event)) return; const x = R || _.target || e, X = x[te[_.type][K ? ce : ae]]; if (X) { const j = []; if (1 === X.length) { const p = Z(X[0], x, _); p && j.push(p) } else { const p = X.slice(); for (let G = 0; G < p.length && (!_ || !0 !== _[Ke]); G++) { const h = Z(p[G], x, _); h && j.push(h) } } if (1 === j.length) throw j[0]; for (let p = 0; p < j.length; p++) { const G = j[p]; n.nativeScheduleMicroTask(() => { throw G }) } } } const B = function (R) { return N(this, R, !1) }, H = function (R) { return N(this, R, !0) }; function J(R, _) { if (!R) return !1; let K = !0; _ && void 0 !== _.useG && (K = _.useG); const x = _ && _.vh; let X = !0; _ && void 0 !== _.chkDup && (X = _.chkDup); let j = !1; _ && void 0 !== _.rt && (j = _.rt); let p = R; for (; p && !p.hasOwnProperty(c);)p = de(p); if (!p && R[c] && (p = R), !p || p[P]) return !1; const G = _ && _.eventNameToString, h = {}, I = p[P] = p[c], w = p[A(a)] = p[a], Q = p[A(y)] = p[y], oe = p[A(d)] = p[d]; let z; _ && _.prepend && (z = p[A(_.prepend)] = p[_.prepend]); const t = K ? function (s) { if (!h.isExisting) return I.call(h.target, h.eventName, h.capture ? H : B, h.options) } : function (s) { return I.call(h.target, h.eventName, s.invoke, h.options) }, r = K ? function (s) { if (!s.isRemoved) { const f = te[s.eventName]; let g; f && (g = f[s.capture ? ce : ae]); const b = g && s.target[g]; if (b) for (let T = 0; T < b.length; T++)if (b[T] === s) { b.splice(T, 1), s.isRemoved = !0, 0 === b.length && (s.allRemoved = !0, s.target[g] = null); break } } if (s.allRemoved) return w.call(s.target, s.eventName, s.capture ? H : B, s.options) } : function (s) { return w.call(s.target, s.eventName, s.invoke, s.options) }, C = _ && _.diff ? _.diff : function (s, f) { const g = typeof f; return "function" === g && s.callback === f || "object" === g && s.originalDelegate === f }, $ = Zone[A("UNPATCHED_EVENTS")], l = e[A("PASSIVE_EVENTS")], u = function (s, f, g, b, T = !1, D = !1) { return function () { const O = this || e; let S = arguments[0]; _ && _.transferEventName && (S = _.transferEventName(S)); let V = arguments[1]; if (!V) return s.apply(this, arguments); if (we && "uncaughtException" === S) return s.apply(this, arguments); let F = !1; if ("function" != typeof V) { if (!V.handleEvent) return s.apply(this, arguments); F = !0 } if (x && !x(s, V, O, arguments)) return; const fe = ye && !!l && -1 !== l.indexOf(S), se = function U(s, f) { return !ye && "object" == typeof s && s ? !!s.capture : ye && f ? "boolean" == typeof s ? { capture: s, passive: !0 } : s ? "object" == typeof s && !1 !== s.passive ? Object.assign(Object.assign({}, s), { passive: !0 }) : s : { passive: !0 } : s }(arguments[2], fe); if ($) for (let _e = 0; _e < $.length; _e++)if (S === $[_e]) return fe ? s.call(O, S, V, se) : s.apply(this, arguments); const xe = !!se && ("boolean" == typeof se || se.capture), nt = !(!se || "object" != typeof se) && se.once, gt = Zone.current; let Ge = te[S]; Ge || (Je(S, G), Ge = te[S]); const rt = Ge[xe ? ce : ae]; let De, me = O[rt], ot = !1; if (me) { if (ot = !0, X) for (let _e = 0; _e < me.length; _e++)if (C(me[_e], V)) return } else me = O[rt] = []; const st = O.constructor.name, it = Ye[st]; it && (De = it[S]), De || (De = st + f + (G ? G(S) : S)), h.options = se, nt && (h.options.once = !1), h.target = O, h.capture = xe, h.eventName = S, h.isExisting = ot; const be = K ? ht : void 0; be && (be.taskData = h); const he = gt.scheduleEventTask(De, V, be, g, b); return h.target = null, be && (be.taskData = null), nt && (se.once = !0), !ye && "boolean" == typeof he.options || (he.options = se), he.target = O, he.capture = xe, he.eventName = S, F && (he.originalDelegate = V), D ? me.unshift(he) : me.push(he), T ? O : void 0 } }; return p[c] = u(I, v, t, r, j), z && (p[m] = u(z, L, function (s) { return z.call(h.target, h.eventName, s.invoke, h.options) }, r, j, !0)), p[a] = function () { const s = this || e; let f = arguments[0]; _ && _.transferEventName && (f = _.transferEventName(f)); const g = arguments[2], b = !!g && ("boolean" == typeof g || g.capture), T = arguments[1]; if (!T) return w.apply(this, arguments); if (x && !x(w, T, s, arguments)) return; const D = te[f]; let O; D && (O = D[b ? ce : ae]); const S = O && s[O]; if (S) for (let V = 0; V < S.length; V++) { const F = S[V]; if (C(F, T)) return S.splice(V, 1), F.isRemoved = !0, 0 === S.length && (F.allRemoved = !0, s[O] = null, "string" == typeof f) && (s[ke + "ON_PROPERTY" + f] = null), F.zone.cancelTask(F), j ? s : void 0 } return w.apply(this, arguments) }, p[y] = function () { const s = this || e; let f = arguments[0]; _ && _.transferEventName && (f = _.transferEventName(f)); const g = [], b = Qe(s, G ? G(f) : f); for (let T = 0; T < b.length; T++) { const D = b[T]; g.push(D.originalDelegate ? D.originalDelegate : D.callback) } return g }, p[d] = function () { const s = this || e; let f = arguments[0]; if (f) { _ && _.transferEventName && (f = _.transferEventName(f)); const g = te[f]; if (g) { const D = s[g[ae]], O = s[g[ce]]; if (D) { const S = D.slice(); for (let V = 0; V < S.length; V++) { const F = S[V]; this[a].call(this, f, F.originalDelegate ? F.originalDelegate : F.callback, F.options) } } if (O) { const S = O.slice(); for (let V = 0; V < S.length; V++) { const F = S[V]; this[a].call(this, f, F.originalDelegate ? F.originalDelegate : F.callback, F.options) } } } } else { const g = Object.keys(s); for (let b = 0; b < g.length; b++) { const D = $e.exec(g[b]); let O = D && D[1]; O && "removeListener" !== O && this[d].call(this, O) } this[d].call(this, "removeListener") } if (j) return this }, ue(p[c], I), ue(p[a], w), oe && ue(p[d], oe), Q && ue(p[y], Q), !0 } let q = []; for (let R = 0; R < i.length; R++)q[R] = J(i[R], o); return q } function Qe(e, n) { if (!n) { const a = []; for (let y in e) { const d = $e.exec(y); let P = d && d[1]; if (P && (!n || P === n)) { const v = e[y]; if (v) for (let m = 0; m < v.length; m++)a.push(v[m]) } } return a } let i = te[n]; i || (Je(n), i = te[n]); const o = e[i[ae]], c = e[i[ce]]; return o ? c ? o.concat(c) : o.slice() : c ? c.slice() : [] } function _t(e, n) { const i = e.Event; i && i.prototype && n.patchMethod(i.prototype, "stopImmediatePropagation", o => function (c, a) { c[Ke] = !0, o && o.apply(c, a) }) } function Et(e, n, i, o, c) { const a = Zone.__symbol__(o); if (n[a]) return; const y = n[a] = n[o]; n[o] = function (d, P, v) { return P && P.prototype && c.forEach(function (m) { const L = `${i}.${o}::` + m, Z = P.prototype; try { if (Z.hasOwnProperty(m)) { const N = e.ObjectGetOwnPropertyDescriptor(Z, m); N && N.value ? (N.value = e.wrapWithCurrentZone(N.value, L), e._redefineProperty(P.prototype, m, N)) : Z[m] && (Z[m] = e.wrapWithCurrentZone(Z[m], L)) } else Z[m] && (Z[m] = e.wrapWithCurrentZone(Z[m], L)) } catch { } }), y.call(n, d, P, v) }, e.attachOriginToPatched(n[o], y) } function et(e, n, i) { if (!i || 0 === i.length) return n; const o = i.filter(a => a.target === e); if (!o || 0 === o.length) return n; const c = o[0].ignoreProperties; return n.filter(a => -1 === c.indexOf(a)) } function tt(e, n, i, o) { e && Xe(e, et(e, n, i), o) } function He(e) { return Object.getOwnPropertyNames(e).filter(n => n.startsWith("on") && n.length > 2).map(n => n.substring(2)) } Zone.__load_patch("util", (e, n, i) => { const o = He(e); i.patchOnProperties = Xe, i.patchMethod = le, i.bindArguments = Le, i.patchMacroTask = lt; const c = n.__symbol__("BLACK_LISTED_EVENTS"), a = n.__symbol__("UNPATCHED_EVENTS"); e[a] && (e[c] = e[a]), e[c] && (n[c] = n[a] = e[c]), i.patchEventPrototype = _t, i.patchEventTarget = dt, i.isIEOrEdge = ft, i.ObjectDefineProperty = Ee, i.ObjectGetOwnPropertyDescriptor = ie, i.ObjectCreate = ge, i.ArraySlice = Ve, i.patchClass = ve, i.wrapWithCurrentZone = Ie, i.filterProperties = et, i.attachOriginToPatched = ue, i._redefineProperty = Object.defineProperty, i.patchCallbacks = Et, i.getGlobalObjects = () => ({ globalSources: Ye, zoneSymbolEventNames: te, eventNames: o, isBrowser: je, isMix: Ue, isNode: we, TRUE_STR: ce, FALSE_STR: ae, ZONE_SYMBOL_PREFIX: ke, ADD_EVENT_LISTENER_STR: Oe, REMOVE_EVENT_LISTENER_STR: Se }) }); const Ce = A("zoneTask"); function pe(e, n, i, o) { let c = null, a = null; i += o; const y = {}; function d(v) { const m = v.data; return m.args[0] = function () { return v.invoke.apply(this, arguments) }, m.handleId = c.apply(e, m.args), v } function P(v) { return a.call(e, v.data.handleId) } c = le(e, n += o, v => function (m, L) { if ("function" == typeof L[0]) { const Z = { isPeriodic: "Interval" === o, delay: "Timeout" === o || "Interval" === o ? L[1] || 0 : void 0, args: L }, N = L[0]; L[0] = function () { try { return N.apply(this, arguments) } finally { Z.isPeriodic || ("number" == typeof Z.handleId ? delete y[Z.handleId] : Z.handleId && (Z.handleId[Ce] = null)) } }; const B = Me(n, L[0], Z, d, P); if (!B) return B; const H = B.data.handleId; return "number" == typeof H ? y[H] = B : H && (H[Ce] = B), H && H.ref && H.unref && "function" == typeof H.ref && "function" == typeof H.unref && (B.ref = H.ref.bind(H), B.unref = H.unref.bind(H)), "number" == typeof H || H ? H : B } return v.apply(e, L) }), a = le(e, i, v => function (m, L) { const Z = L[0]; let N; "number" == typeof Z ? N = y[Z] : (N = Z && Z[Ce], N || (N = Z)), N && "string" == typeof N.type ? "notScheduled" !== N.state && (N.cancelFn && N.data.isPeriodic || 0 === N.runCount) && ("number" == typeof Z ? delete y[Z] : Z && (Z[Ce] = null), N.zone.cancelTask(N)) : v.apply(e, L) }) } Zone.__load_patch("legacy", e => { const n = e[Zone.__symbol__("legacyPatch")]; n && n() }), Zone.__load_patch("queueMicrotask", (e, n, i) => { i.patchMethod(e, "queueMicrotask", o => function (c, a) { n.current.scheduleMicroTask("queueMicrotask", a[0]) }) }), Zone.__load_patch("timers", e => { const n = "set", i = "clear"; pe(e, n, i, "Timeout"), pe(e, n, i, "Interval"), pe(e, n, i, "Immediate") }), Zone.__load_patch("requestAnimationFrame", e => { pe(e, "request", "cancel", "AnimationFrame"), pe(e, "mozRequest", "mozCancel", "AnimationFrame"), pe(e, "webkitRequest", "webkitCancel", "AnimationFrame") }), Zone.__load_patch("blocking", (e, n) => { const i = ["alert", "prompt", "confirm"]; for (let o = 0; o < i.length; o++)le(e, i[o], (a, y, d) => function (P, v) { return n.current.run(a, e, v, d) }) }), Zone.__load_patch("EventTarget", (e, n, i) => { (function mt(e, n) { n.patchEventPrototype(e, n) })(e, i), function pt(e, n) { if (Zone[n.symbol("patchEventTarget")]) return; const { eventNames: i, zoneSymbolEventNames: o, TRUE_STR: c, FALSE_STR: a, ZONE_SYMBOL_PREFIX: y } = n.getGlobalObjects(); for (let P = 0; P < i.length; P++) { const v = i[P], Z = y + (v + a), N = y + (v + c); o[v] = {}, o[v][a] = Z, o[v][c] = N } const d = e.EventTarget; d && d.prototype && n.patchEventTarget(e, n, [d && d.prototype]) }(e, i); const o = e.XMLHttpRequestEventTarget; o && o.prototype && i.patchEventTarget(e, i, [o.prototype]) }), Zone.__load_patch("MutationObserver", (e, n, i) => { ve("MutationObserver"), ve("WebKitMutationObserver") }), Zone.__load_patch("IntersectionObserver", (e, n, i) => { ve("IntersectionObserver") }), Zone.__load_patch("FileReader", (e, n, i) => { ve("FileReader") }), Zone.__load_patch("on_property", (e, n, i) => { !function Tt(e, n) { if (we && !Ue || Zone[e.symbol("patchEvents")]) return; const i = n.__Zone_ignore_on_properties; let o = []; if (je) { const c = window; o = o.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]); const a = function ut() { try { const e = Te.navigator.userAgent; if (-1 !== e.indexOf("MSIE ") || -1 !== e.indexOf("Trident/")) return !0 } catch { } return !1 }() ? [{ target: c, ignoreProperties: ["error"] }] : []; tt(c, He(c), i && i.concat(a), de(c)) } o = o.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]); for (let c = 0; c < o.length; c++) { const a = n[o[c]]; a && a.prototype && tt(a.prototype, He(a.prototype), i) } }(i, e) }), Zone.__load_patch("customElements", (e, n, i) => { !function yt(e, n) { const { isBrowser: i, isMix: o } = n.getGlobalObjects(); (i || o) && e.customElements && "customElements" in e && n.patchCallbacks(n, e.customElements, "customElements", "define", ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"]) }(e, i) }), Zone.__load_patch("XHR", (e, n) => { !function P(v) { const m = v.XMLHttpRequest; if (!m) return; const L = m.prototype; let N = L[Ze], B = L[Ne]; if (!N) { const h = v.XMLHttpRequestEventTarget; if (h) { const I = h.prototype; N = I[Ze], B = I[Ne] } } const H = "readystatechange", J = "scheduled"; function q(h) { const I = h.data, w = I.target; w[a] = !1, w[d] = !1; const Q = w[c]; N || (N = w[Ze], B = w[Ne]), Q && B.call(w, H, Q); const oe = w[c] = () => { if (w.readyState === w.DONE) if (!I.aborted && w[a] && h.state === J) { const U = w[n.__symbol__("loadfalse")]; if (0 !== w.status && U && U.length > 0) { const re = h.invoke; h.invoke = function () { const ee = w[n.__symbol__("loadfalse")]; for (let W = 0; W < ee.length; W++)ee[W] === h && ee.splice(W, 1); !I.aborted && h.state === J && re.call(h) }, U.push(h) } else h.invoke() } else !I.aborted && !1 === w[a] && (w[d] = !0) }; return N.call(w, H, oe), w[i] || (w[i] = h), p.apply(w, I.args), w[a] = !0, h } function R() { } function _(h) { const I = h.data; return I.aborted = !0, G.apply(I.target, I.args) } const K = le(L, "open", () => function (h, I) { return h[o] = 0 == I[2], h[y] = I[1], K.apply(h, I) }), X = A("fetchTaskAborting"), j = A("fetchTaskScheduling"), p = le(L, "send", () => function (h, I) { if (!0 === n.current[j] || h[o]) return p.apply(h, I); { const w = { target: h, url: h[y], isPeriodic: !1, args: I, aborted: !1 }, Q = Me("XMLHttpRequest.send", R, w, q, _); h && !0 === h[d] && !w.aborted && Q.state === J && Q.invoke() } }), G = le(L, "abort", () => function (h, I) { const w = function Z(h) { return h[i] }(h); if (w && "string" == typeof w.type) { if (null == w.cancelFn || w.data && w.data.aborted) return; w.zone.cancelTask(w) } else if (!0 === n.current[X]) return G.apply(h, I) }) }(e); const i = A("xhrTask"), o = A("xhrSync"), c = A("xhrListener"), a = A("xhrScheduled"), y = A("xhrURL"), d = A("xhrErrorBeforeScheduled") }), Zone.__load_patch("geolocation", e => { e.navigator && e.navigator.geolocation && function at(e, n) { const i = e.constructor.name; for (let o = 0; o < n.length; o++) { const c = n[o], a = e[c]; if (a) { if (!Fe(ie(e, c))) continue; e[c] = (d => { const P = function () { return d.apply(this, Le(arguments, i + "." + c)) }; return ue(P, d), P })(a) } } }(e.navigator.geolocation, ["getCurrentPosition", "watchPosition"]) }), Zone.__load_patch("PromiseRejectionEvent", (e, n) => { function i(o) { return function (c) { Qe(e, o).forEach(y => { const d = e.PromiseRejectionEvent; if (d) { const P = new d(o, { promise: c.promise, reason: c.rejection }); y.invoke(P) } }) } } e.PromiseRejectionEvent && (n[A("unhandledPromiseRejectionHandler")] = i("unhandledrejection"), n[A("rejectionHandledHandler")] = i("rejectionhandled")) }) } }, ie => { ie(ie.s = 435) }]); (() => { "use strict"; var e, v = {}, i = {}; function n(e) { var a = i[e]; if (void 0 !== a) return a.exports; var r = i[e] = { exports: {} }; return v[e](r, r.exports, n), r.exports } n.m = v, e = [], n.O = (a, r, u, f) => { if (!r) { var o = 1 / 0; for (l = 0; l < e.length; l++) { for (var [r, u, f] = e[l], s = !0, t = 0; t < r.length; t++)(!1 & f || o >= f) && Object.keys(n.O).every(d => n.O[d](r[t])) ? r.splice(t--, 1) : (s = !1, f < o && (o = f)); if (s) { e.splice(l--, 1); var c = u(); void 0 !== c && (a = c) } } return a } f = f || 0; for (var l = e.length; l > 0 && e[l - 1][2] > f; l--)e[l] = e[l - 1]; e[l] = [r, u, f] }, n.n = e => { var a = e && e.__esModule ? () => e.default : () => e; return n.d(a, { a }), a }, n.d = (e, a) => { for (var r in a) n.o(a, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: a[r] }) }, n.o = (e, a) => Object.prototype.hasOwnProperty.call(e, a), (() => { var e = { 666: 0 }; n.O.j = u => 0 === e[u]; var a = (u, f) => { var t, c, [l, o, s] = f, _ = 0; if (l.some(b => 0 !== e[b])) { for (t in o) n.o(o, t) && (n.m[t] = o[t]); if (s) var p = s(n) } for (u && u(f); _ < l.length; _++)n.o(e, c = l[_]) && e[c] && e[c][0](), e[c] = 0; return n.O(p) }, r = self.webpackChunkflo_client_plugin = self.webpackChunkflo_client_plugin || []; r.forEach(a.bind(null, 0)), r.push = a.bind(null, r.push.bind(r)) })() })(); "use strict"; (self.webpackChunkflo_client_plugin = self.webpackChunkflo_client_plugin || []).push([[179], { 702: () => { function se(e) { return "function" == typeof e } function Ar(e) { const t = e(o => { Error.call(o), o.stack = (new Error).stack }); return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t } const Sr = Ar(e => function (t) { e(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((o, i) => `${i + 1}) ${o.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t }); function gi(e, n) { if (e) { const t = e.indexOf(n); 0 <= t && e.splice(t, 1) } } class Yt { constructor(n) { this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let n; if (!this.closed) { this.closed = !0; const { _parentage: t } = this; if (t) if (this._parentage = null, Array.isArray(t)) for (const r of t) r.remove(this); else t.remove(this); const { initialTeardown: o } = this; if (se(o)) try { o() } catch (r) { n = r instanceof Sr ? r.errors : [r] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const r of i) try { Pd(r) } catch (s) { n = n ?? [], s instanceof Sr ? n = [...n, ...s.errors] : n.push(s) } } if (n) throw new Sr(n) } } add(n) { var t; if (n && n !== this) if (this.closed) Pd(n); else { if (n instanceof Yt) { if (n.closed || n._hasParent(this)) return; n._addParent(this) } (this._finalizers = null !== (t = this._finalizers) && void 0 !== t ? t : []).push(n) } } _hasParent(n) { const { _parentage: t } = this; return t === n || Array.isArray(t) && t.includes(n) } _addParent(n) { const { _parentage: t } = this; this._parentage = Array.isArray(t) ? (t.push(n), t) : t ? [t, n] : n } _removeParent(n) { const { _parentage: t } = this; t === n ? this._parentage = null : Array.isArray(t) && gi(t, n) } remove(n) { const { _finalizers: t } = this; t && gi(t, n), n instanceof Yt && n._removeParent(this) } } Yt.EMPTY = (() => { const e = new Yt; return e.closed = !0, e })(); const Od = Yt.EMPTY; function Nd(e) { return e instanceof Yt || e && "closed" in e && se(e.remove) && se(e.add) && se(e.unsubscribe) } function Pd(e) { se(e) ? e() : e.unsubscribe() } const Un = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, xr = { setTimeout(e, n, ...t) { const { delegate: o } = xr; return o?.setTimeout ? o.setTimeout(e, n, ...t) : setTimeout(e, n, ...t) }, clearTimeout(e) { const { delegate: n } = xr; return (n?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function kd(e) { xr.setTimeout(() => { const { onUnhandledError: n } = Un; if (!n) throw e; n(e) }) } function Na() { } const yC = Pa("C", void 0, void 0); function Pa(e, n, t) { return { kind: e, value: n, error: t } } let $n = null; function Mr(e) { if (Un.useDeprecatedSynchronousErrorHandling) { const n = !$n; if (n && ($n = { errorThrown: !1, error: null }), e(), n) { const { errorThrown: t, error: o } = $n; if ($n = null, t) throw o } } else e() } class ka extends Yt { constructor(n) { super(), this.isStopped = !1, n ? (this.destination = n, Nd(n) && n.add(this)) : this.destination = IC } static create(n, t, o) { return new mi(n, t, o) } next(n) { this.isStopped ? Ra(function CC(e) { return Pa("N", e, void 0) }(n), this) : this._next(n) } error(n) { this.isStopped ? Ra(function vC(e) { return Pa("E", void 0, e) }(n), this) : (this.isStopped = !0, this._error(n)) } complete() { this.isStopped ? Ra(yC, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(n) { this.destination.next(n) } _error(n) { try { this.destination.error(n) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const DC = Function.prototype.bind; function La(e, n) { return DC.call(e, n) } class bC { constructor(n) { this.partialObserver = n } next(n) { const { partialObserver: t } = this; if (t.next) try { t.next(n) } catch (o) { Fr(o) } } error(n) { const { partialObserver: t } = this; if (t.error) try { t.error(n) } catch (o) { Fr(o) } else Fr(n) } complete() { const { partialObserver: n } = this; if (n.complete) try { n.complete() } catch (t) { Fr(t) } } } class mi extends ka { constructor(n, t, o) { let i; if (super(), se(n) || !n) i = { next: n ?? void 0, error: t ?? void 0, complete: o ?? void 0 }; else { let r; this && Un.useDeprecatedNextContext ? (r = Object.create(n), r.unsubscribe = () => this.unsubscribe(), i = { next: n.next && La(n.next, r), error: n.error && La(n.error, r), complete: n.complete && La(n.complete, r) }) : i = n } this.destination = new bC(i) } } function Fr(e) { Un.useDeprecatedSynchronousErrorHandling ? function wC(e) { Un.useDeprecatedSynchronousErrorHandling && $n && ($n.errorThrown = !0, $n.error = e) }(e) : kd(e) } function Ra(e, n) { const { onStoppedNotification: t } = Un; t && xr.setTimeout(() => t(e, n)) } const IC = { closed: !0, next: Na, error: function EC(e) { throw e }, complete: Na }, Va = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Ba(e) { return e } let Qe = (() => { class e { constructor(t) { t && (this._subscribe = t) } lift(t) { const o = new e; return o.source = this, o.operator = t, o } subscribe(t, o, i) { const r = function AC(e) { return e && e instanceof ka || function TC(e) { return e && se(e.next) && se(e.error) && se(e.complete) }(e) && Nd(e) }(t) ? t : new mi(t, o, i); return Mr(() => { const { operator: s, source: a } = this; r.add(s ? s.call(r, a) : a ? this._subscribe(r) : this._trySubscribe(r)) }), r } _trySubscribe(t) { try { return this._subscribe(t) } catch (o) { t.error(o) } } forEach(t, o) { return new (o = Rd(o))((i, r) => { const s = new mi({ next: a => { try { t(a) } catch (l) { r(l), s.unsubscribe() } }, error: r, complete: i }); this.subscribe(s) }) } _subscribe(t) { var o; return null === (o = this.source) || void 0 === o ? void 0 : o.subscribe(t) } [Va]() { return this } pipe(...t) { return function Ld(e) { return 0 === e.length ? Ba : 1 === e.length ? e[0] : function (t) { return e.reduce((o, i) => i(o), t) } }(t)(this) } toPromise(t) { return new (t = Rd(t))((o, i) => { let r; this.subscribe(s => r = s, s => i(s), () => o(r)) }) } } return e.create = n => new e(n), e })(); function Rd(e) { var n; return null !== (n = e ?? Un.Promise) && void 0 !== n ? n : Promise } const SC = Ar(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let qn = (() => { class e extends Qe { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(t) { const o = new Vd(this, this); return o.operator = t, o } _throwIfClosed() { if (this.closed) throw new SC } next(t) { Mr(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const o of this.currentObservers) o.next(t) } }) } error(t) { Mr(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = t; const { observers: o } = this; for (; o.length;)o.shift().error(t) } }) } complete() { Mr(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: t } = this; for (; t.length;)t.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var t; return (null === (t = this.observers) || void 0 === t ? void 0 : t.length) > 0 } _trySubscribe(t) { return this._throwIfClosed(), super._trySubscribe(t) } _subscribe(t) { return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t) } _innerSubscribe(t) { const { hasError: o, isStopped: i, observers: r } = this; return o || i ? Od : (this.currentObservers = null, r.push(t), new Yt(() => { this.currentObservers = null, gi(r, t) })) } _checkFinalizedStatuses(t) { const { hasError: o, thrownError: i, isStopped: r } = this; o ? t.error(i) : r && t.complete() } asObservable() { const t = new Qe; return t.source = this, t } } return e.create = (n, t) => new Vd(n, t), e })(); class Vd extends qn { constructor(n, t) { super(), this.destination = n, this.source = t } next(n) { var t, o; null === (o = null === (t = this.destination) || void 0 === t ? void 0 : t.next) || void 0 === o || o.call(t, n) } error(n) { var t, o; null === (o = null === (t = this.destination) || void 0 === t ? void 0 : t.error) || void 0 === o || o.call(t, n) } complete() { var n, t; null === (t = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === t || t.call(n) } _subscribe(n) { var t, o; return null !== (o = null === (t = this.source) || void 0 === t ? void 0 : t.subscribe(n)) && void 0 !== o ? o : Od } } function Jt(e) { return n => { if (function xC(e) { return se(e?.lift) }(n)) return n.lift(function (t) { try { return e(t, this) } catch (o) { this.error(o) } }); throw new TypeError("Unable to lift unknown Observable type") } } function At(e, n, t, o, i) { return new MC(e, n, t, o, i) } class MC extends ka { constructor(n, t, o, i, r, s) { super(n), this.onFinalize = r, this.shouldUnsubscribe = s, this._next = t ? function (a) { try { t(a) } catch (l) { n.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { n.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = o ? function () { try { o() } catch (a) { n.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: t } = this; super.unsubscribe(), !t && (null === (n = this.onFinalize) || void 0 === n || n.call(this)) } } } function Sn(e, n) { return Jt((t, o) => { let i = 0; t.subscribe(At(o, r => { o.next(e.call(n, r, i++)) })) }) } function xn(e) { return this instanceof xn ? (this.v = e, this) : new xn(e) } function Ud(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = function $a(e) { var n = "function" == typeof Symbol && Symbol.iterator, t = n && e[n], o = 0; if (t) return t.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && o >= e.length && (e = void 0), { value: e && e[o++], done: !e } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), t = {}, o("next"), o("throw"), o("return"), t[Symbol.asyncIterator] = function () { return this }, t); function o(r) { t[r] = e[r] && function (s) { return new Promise(function (a, l) { !function i(r, s, a, l) { Promise.resolve(l).then(function (u) { r({ value: u, done: a }) }, s) }(a, l, (s = e[r](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const qa = e => e && "number" == typeof e.length && "function" != typeof e; function $d(e) { return se(e?.then) } function qd(e) { return se(e[Va]) } function Gd(e) { return Symbol.asyncIterator && se(e?.[Symbol.asyncIterator]) } function Qd(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const zd = function ZC() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Wd(e) { return se(e?.[zd]) } function Kd(e) { return function Hd(e, n, t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, o = t.apply(e, n || []), r = []; return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function () { return this }, i; function s(p) { o[p] && (i[p] = function (g) { return new Promise(function (C, w) { r.push([p, g, C, w]) > 1 || a(p, g) }) }) } function a(p, g) { try { !function l(p) { p.value instanceof xn ? Promise.resolve(p.value.v).then(u, c) : d(r[0][2], p) }(o[p](g)) } catch (C) { d(r[0][3], C) } } function u(p) { a("next", p) } function c(p) { a("throw", p) } function d(p, g) { p(g), r.shift(), r.length && a(r[0][0], r[0][1]) } }(this, arguments, function* () { const t = e.getReader(); try { for (; ;) { const { value: o, done: i } = yield xn(t.read()); if (i) return yield xn(void 0); yield yield xn(o) } } finally { t.releaseLock() } }) } function Yd(e) { return se(e?.getReader) } function St(e) { if (e instanceof Qe) return e; if (null != e) { if (qd(e)) return function XC(e) { return new Qe(n => { const t = e[Va](); if (se(t.subscribe)) return t.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (qa(e)) return function ew(e) { return new Qe(n => { for (let t = 0; t < e.length && !n.closed; t++)n.next(e[t]); n.complete() }) }(e); if ($d(e)) return function tw(e) { return new Qe(n => { e.then(t => { n.closed || (n.next(t), n.complete()) }, t => n.error(t)).then(null, kd) }) }(e); if (Gd(e)) return Jd(e); if (Wd(e)) return function nw(e) { return new Qe(n => { for (const t of e) if (n.next(t), n.closed) return; n.complete() }) }(e); if (Yd(e)) return function ow(e) { return Jd(Kd(e)) }(e) } throw Qd(e) } function Jd(e) { return new Qe(n => { (function iw(e, n) { var t, o, i, r; return function Bd(e, n, t, o) { return new (t || (t = Promise))(function (r, s) { function a(c) { try { u(o.next(c)) } catch (d) { s(d) } } function l(c) { try { u(o.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? r(c.value) : function i(r) { return r instanceof t ? r : new t(function (s) { s(r) }) }(c.value).then(a, l) } u((o = o.apply(e, n || [])).next()) }) }(this, void 0, void 0, function* () { try { for (t = Ud(e); !(o = yield t.next()).done;)if (n.next(o.value), n.closed) return } catch (s) { i = { error: s } } finally { try { o && !o.done && (r = t.return) && (yield r.call(t)) } finally { if (i) throw i.error } } n.complete() }) })(e, n).catch(t => n.error(t)) }) } function Mn(e, n, t, o = 0, i = !1) { const r = n.schedule(function () { t(), i ? e.add(this.schedule(null, o)) : this.unsubscribe() }, o); if (e.add(r), !i) return r } function _i(e, n, t = 1 / 0) { return se(n) ? _i((o, i) => Sn((r, s) => n(o, r, i, s))(St(e(o, i))), t) : ("number" == typeof n && (t = n), Jt((o, i) => function rw(e, n, t, o, i, r, s, a) { const l = []; let u = 0, c = 0, d = !1; const p = () => { d && !l.length && !u && n.complete() }, g = w => u < o ? C(w) : l.push(w), C = w => { r && n.next(w), u++; let D = !1; St(t(w, c++)).subscribe(At(n, I => { i?.(I), r ? g(I) : n.next(I) }, () => { D = !0 }, void 0, () => { if (D) try { for (u--; l.length && u < o;) { const I = l.shift(); s ? Mn(n, s, () => C(I)) : C(I) } p() } catch (I) { n.error(I) } })) }; return e.subscribe(At(n, g, () => { d = !0, p() })), () => { a?.() } }(o, i, e, t))) } const Ga = new Qe(e => e.complete()); function Qa(e) { return e[e.length - 1] } function Zd(e) { return se(Qa(e)) ? e.pop() : void 0 } function Xd(e) { return function lw(e) { return e && se(e.schedule) }(Qa(e)) ? e.pop() : void 0 } function ef(e, n = 0) { return Jt((t, o) => { t.subscribe(At(o, i => Mn(o, e, () => o.next(i), n), () => Mn(o, e, () => o.complete(), n), i => Mn(o, e, () => o.error(i), n))) }) } function tf(e, n = 0) { return Jt((t, o) => { o.add(e.schedule(() => t.subscribe(o), n)) }) } function nf(e, n) { if (!e) throw new Error("Iterable cannot be null"); return new Qe(t => { Mn(t, n, () => { const o = e[Symbol.asyncIterator](); Mn(t, n, () => { o.next().then(i => { i.done ? t.complete() : t.next(i.value) }) }, 0, !0) }) }) } function za(e, n) { return n ? function gw(e, n) { if (null != e) { if (qd(e)) return function cw(e, n) { return St(e).pipe(tf(n), ef(n)) }(e, n); if (qa(e)) return function fw(e, n) { return new Qe(t => { let o = 0; return n.schedule(function () { o === e.length ? t.complete() : (t.next(e[o++]), t.closed || this.schedule()) }) }) }(e, n); if ($d(e)) return function dw(e, n) { return St(e).pipe(tf(n), ef(n)) }(e, n); if (Gd(e)) return nf(e, n); if (Wd(e)) return function hw(e, n) { return new Qe(t => { let o; return Mn(t, n, () => { o = e[zd](), Mn(t, n, () => { let i, r; try { ({ value: i, done: r } = o.next()) } catch (s) { return void t.error(s) } r ? t.complete() : t.next(i) }, 0, !0) }), () => se(o?.return) && o.return() }) }(e, n); if (Yd(e)) return function pw(e, n) { return nf(Kd(e), n) }(e, n) } throw Qd(e) }(e, n) : St(e) } function of(...e) { const n = Xd(e), t = function uw(e, n) { return "number" == typeof Qa(e) ? e.pop() : n }(e, 1 / 0), o = e; return o.length ? 1 === o.length ? St(o[0]) : function sw(e = 1 / 0) { return _i(Ba, e) }(t)(za(o, n)) : Ga } function Or(e = {}) { const { connector: n = (() => new qn), resetOnError: t = !0, resetOnComplete: o = !0, resetOnRefCountZero: i = !0 } = e; return r => { let s, a, l, u = 0, c = !1, d = !1; const p = () => { a?.unsubscribe(), a = void 0 }, g = () => { p(), s = l = void 0, c = d = !1 }, C = () => { const w = s; g(), w?.unsubscribe() }; return Jt((w, D) => { u++, !d && !c && p(); const I = l = l ?? n(); D.add(() => { u--, 0 === u && !d && !c && (a = Wa(C, i)) }), I.subscribe(D), !s && u > 0 && (s = new mi({ next: F => I.next(F), error: F => { d = !0, p(), a = Wa(g, t, F), I.error(F) }, complete: () => { c = !0, p(), a = Wa(g, o), I.complete() } }), St(w).subscribe(s)) })(r) } } function Wa(e, n, ...t) { if (!0 === n) return void e(); if (!1 === n) return; const o = new mi({ next: () => { o.unsubscribe(), e() } }); return n(...t).subscribe(o) } function fe(e) { for (let n in e) if (e[n] === fe) return n; throw Error("Could not find renamed property on target object.") } function Ka(e, n) { for (const t in n) n.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n[t]) } function ge(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(ge).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const n = e.toString(); if (null == n) return "" + n; const t = n.indexOf("\n"); return -1 === t ? n : n.substring(0, t) } function Ya(e, n) { return null == e || "" === e ? null === n ? "" : n : null == n || "" === n ? e : e + " " + n } const mw = fe({ __forward_ref__: fe }); function me(e) { return e.__forward_ref__ = me, e.toString = function () { return ge(this()) }, e } function U(e) { return Ja(e) ? e() : e } function Ja(e) { return "function" == typeof e && e.hasOwnProperty(mw) && e.__forward_ref__ === me } function Za(e) { return e && !!e.\u0275providers } const Nr = "https://g.co/ng/security#xss"; class O extends Error { constructor(n, t) { super(Pr(n, t)), this.code = n } } function Pr(e, n) { return `NG0${Math.abs(e)}${n ? ": " + n.trim() : ""}` } function z(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function kr(e, n) { throw new O(-201, !1) } function xt(e, n) { null == e && function ue(e, n, t, o) { throw new Error(`ASSERTION ERROR: ${e}` + (null == o ? "" : ` [Expected=> ${t} ${o} ${n} <=Actual]`)) }(n, e, null, "!=") } function J(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Je(e) { return { providers: e.providers || [], imports: e.imports || [] } } function Lr(e) { return rf(e, Rr) || rf(e, af) } function rf(e, n) { return e.hasOwnProperty(n) ? e[n] : null } function sf(e) { return e && (e.hasOwnProperty(Xa) || e.hasOwnProperty(bw)) ? e[Xa] : null } const Rr = fe({ \u0275prov: fe }), Xa = fe({ \u0275inj: fe }), af = fe({ ngInjectableDef: fe }), bw = fe({ ngInjectorDef: fe }); var G = (() => ((G = G || {})[G.Default = 0] = "Default", G[G.Host = 1] = "Host", G[G.Self = 2] = "Self", G[G.SkipSelf = 4] = "SkipSelf", G[G.Optional = 8] = "Optional", G))(); let el; function Mt(e) { const n = el; return el = e, n } function lf(e, n, t) { const o = Lr(e); return o && "root" == o.providedIn ? void 0 === o.value ? o.value = o.factory() : o.value : t & G.Optional ? null : void 0 !== n ? n : void kr(ge(e)) } const Ce = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), yi = {}, tl = "__NG_DI_FLAG__", Vr = "ngTempTokenPath", Iw = "ngTokenPath", Tw = /\n/gm, Aw = "\u0275", uf = "__source"; let vi; function go(e) { const n = vi; return vi = e, n } function Sw(e, n = G.Default) { if (void 0 === vi) throw new O(-203, !1); return null === vi ? lf(e, void 0, n) : vi.get(e, n & G.Optional ? null : void 0, n) } function q(e, n = G.Default) { return (function Ew() { return el }() || Sw)(U(e), n) } function mo(e, n = G.Default) { return q(e, Br(n)) } function Br(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function nl(e) { const n = []; for (let t = 0; t < e.length; t++) { const o = U(e[t]); if (Array.isArray(o)) { if (0 === o.length) throw new O(900, !1); let i, r = G.Default; for (let s = 0; s < o.length; s++) { const a = o[s], l = xw(a); "number" == typeof l ? -1 === l ? i = a.token : r |= l : i = a } n.push(q(i, r)) } else n.push(q(o)) } return n } function Ci(e, n) { return e[tl] = n, e.prototype[tl] = n, e } function xw(e) { return e[tl] } function fn(e) { return { toString: e }.toString() } var Zt = (() => ((Zt = Zt || {})[Zt.OnPush = 0] = "OnPush", Zt[Zt.Default = 1] = "Default", Zt))(), Xt = (() => { return (e = Xt || (Xt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Xt; var e })(); const hn = {}, ae = [], jr = fe({ \u0275cmp: fe }), ol = fe({ \u0275dir: fe }), il = fe({ \u0275pipe: fe }), df = fe({ \u0275mod: fe }), pn = fe({ \u0275fac: fe }), wi = fe({ __NG_ELEMENT_ID__: fe }); let Ow = 0; function he(e) { return fn(() => { const n = hf(e), t = { ...n, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === Zt.OnPush, directiveDefs: null, pipeDefs: null, dependencies: n.standalone && e.dependencies || null, getStandaloneInjector: null, data: e.data || {}, encapsulation: e.encapsulation || Xt.Emulated, id: "c" + Ow++, styles: e.styles || ae, _: null, schemas: e.schemas || null, tView: null }; pf(t); const o = e.dependencies; return t.directiveDefs = Hr(o, !1), t.pipeDefs = Hr(o, !0), t }) } function Pw(e) { return ce(e) || Ze(e) } function kw(e) { return null !== e } function it(e) { return fn(() => ({ type: e.type, bootstrap: e.bootstrap || ae, declarations: e.declarations || ae, imports: e.imports || ae, exports: e.exports || ae, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function ff(e, n) { if (null == e) return hn; const t = {}; for (const o in e) if (e.hasOwnProperty(o)) { let i = e[o], r = i; Array.isArray(i) && (r = i[1], i = i[0]), t[i] = o, n && (n[i] = r) } return t } function W(e) { return fn(() => { const n = hf(e); return pf(n), n }) } function ft(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, standalone: !0 === e.standalone, onDestroy: e.type.prototype.ngOnDestroy || null } } function ce(e) { return e[jr] || null } function Ze(e) { return e[ol] || null } function ht(e) { return e[il] || null } function hf(e) { const n = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: n, exportAs: e.exportAs || null, standalone: !0 === e.standalone, selectors: e.selectors || ae, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: ff(e.inputs, n), outputs: ff(e.outputs) } } function pf(e) { e.features?.forEach(n => n(e)) } function Hr(e, n) { if (!e) return null; const t = n ? ht : Pw; return () => ("function" == typeof e ? e() : e).map(o => t(o)).filter(kw) } const gn = 0, P = 1, Z = 2, Me = 3, Bt = 4, Gn = 5, Xe = 6, _o = 7, Oe = 8, Ur = 9, $r = 10, ee = 11, rl = 12, bi = 13, gf = 14, yo = 15, et = 16, Ei = 17, vo = 18, en = 19, Ii = 20, mf = 21, we = 22, sl = 1, _f = 2, qr = 7, Gr = 8, Co = 9, rt = 10; function Dt(e) { return Array.isArray(e) && "object" == typeof e[sl] } function jt(e) { return Array.isArray(e) && !0 === e[sl] } function al(e) { return 0 != (4 & e.flags) } function Ti(e) { return e.componentOffset > -1 } function Qr(e) { return 1 == (1 & e.flags) } function Ht(e) { return !!e.template } function Rw(e) { return 0 != (256 & e[Z]) } function Qn(e, n) { return e.hasOwnProperty(pn) ? e[pn] : null } class Cf { constructor(n, t, o) { this.previousValue = n, this.currentValue = t, this.firstChange = o } isFirstChange() { return this.firstChange } } function Te() { return wf } function wf(e) { return e.type.prototype.ngOnChanges && (e.setInput = Hw), jw } function jw() { const e = bf(this), n = e?.current; if (n) { const t = e.previous; if (t === hn) e.previous = n; else for (let o in n) t[o] = n[o]; e.current = null, this.ngOnChanges(n) } } function Hw(e, n, t, o) { const i = this.declaredInputs[t], r = bf(e) || function Uw(e, n) { return e[Df] = n }(e, { previous: hn, current: null }), s = r.current || (r.current = {}), a = r.previous, l = a[i]; s[i] = new Cf(l && l.currentValue, n, a === hn), e[o] = n } Te.ngInherit = !0; const Df = "__ngSimpleChanges__"; function bf(e) { return e[Df] || null } const Ft = function (e, n, t) { }, Ef = "svg"; function ze(e) { for (; Array.isArray(e);)e = e[gn]; return e } function zr(e, n) { return ze(n[e]) } function bt(e, n) { return ze(n[e.index]) } function Tf(e, n) { return e.data[n] } function wo(e, n) { return e[n] } function pt(e, n) { const t = n[e]; return Dt(t) ? t : t[gn] } function Wr(e) { return 64 == (64 & e[Z]) } function On(e, n) { return null == n ? null : e[n] } function Af(e) { e[vo] = 0 } function ul(e, n) { e[Gn] += n; let t = e, o = e[Me]; for (; null !== o && (1 === n && 1 === t[Gn] || -1 === n && 0 === t[Gn]);)o[Gn] += n, t = o, o = o[Me] } const K = { lFrame: Rf(null), bindingsEnabled: !0 }; function xf() { return K.bindingsEnabled } function T() { return K.lFrame.lView } function ie() { return K.lFrame.tView } function S(e) { return K.lFrame.contextLView = e, e[Oe] } function x(e) { return K.lFrame.contextLView = null, e } function We() { let e = Mf(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Mf() { return K.lFrame.currentTNode } function tn(e, n) { const t = K.lFrame; t.currentTNode = e, t.isParent = n } function cl() { return K.lFrame.isParent } function dl() { K.lFrame.isParent = !1 } function st() { const e = K.lFrame; let n = e.bindingRootIndex; return -1 === n && (n = e.bindingRootIndex = e.tView.bindingStartIndex), n } function Do() { return K.lFrame.bindingIndex++ } function _n(e) { const n = K.lFrame, t = n.bindingIndex; return n.bindingIndex = n.bindingIndex + e, t } function tD(e, n) { const t = K.lFrame; t.bindingIndex = t.bindingRootIndex = e, fl(n) } function fl(e) { K.lFrame.currentDirectiveIndex = e } function Pf() { return K.lFrame.currentQueryIndex } function pl(e) { K.lFrame.currentQueryIndex = e } function oD(e) { const n = e[P]; return 2 === n.type ? n.declTNode : 1 === n.type ? e[Xe] : null } function kf(e, n, t) { if (t & G.SkipSelf) { let i = n, r = e; for (; !(i = i.parent, null !== i || t & G.Host || (i = oD(r), null === i || (r = r[yo], 10 & i.type)));); if (null === i) return !1; n = i, e = r } const o = K.lFrame = Lf(); return o.currentTNode = n, o.lView = e, !0 } function gl(e) { const n = Lf(), t = e[P]; K.lFrame = n, n.currentTNode = t.firstChild, n.lView = e, n.tView = t, n.contextLView = e, n.bindingIndex = t.bindingStartIndex, n.inI18n = !1 } function Lf() { const e = K.lFrame, n = null === e ? null : e.child; return null === n ? Rf(e) : n } function Rf(e) { const n = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = n), n } function Vf() { const e = K.lFrame; return K.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Bf = Vf; function ml() { const e = Vf(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function at() { return K.lFrame.selectedIndex } function zn(e) { K.lFrame.selectedIndex = e } function Ae() { const e = K.lFrame; return Tf(e.tView, e.selectedIndex) } function Kr() { K.lFrame.currentNamespace = Ef } function Yr(e, n) { for (let t = n.directiveStart, o = n.directiveEnd; t < o; t++) { const r = e.data[t].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = r; s && (e.contentHooks ?? (e.contentHooks = [])).push(-t, s), a && ((e.contentHooks ?? (e.contentHooks = [])).push(t, a), (e.contentCheckHooks ?? (e.contentCheckHooks = [])).push(t, a)), l && (e.viewHooks ?? (e.viewHooks = [])).push(-t, l), u && ((e.viewHooks ?? (e.viewHooks = [])).push(t, u), (e.viewCheckHooks ?? (e.viewCheckHooks = [])).push(t, u)), null != c && (e.destroyHooks ?? (e.destroyHooks = [])).push(t, c) } } function Jr(e, n, t) { jf(e, n, 3, t) } function Zr(e, n, t, o) { (3 & e[Z]) === t && jf(e, n, t, o) } function _l(e, n) { let t = e[Z]; (3 & t) === n && (t &= 2047, t += 1, e[Z] = t) } function jf(e, n, t, o) { const r = o ?? -1, s = n.length - 1; let a = 0; for (let l = void 0 !== o ? 65535 & e[vo] : 0; l < s; l++)if ("number" == typeof n[l + 1]) { if (a = n[l], null != o && a >= o) break } else n[l] < 0 && (e[vo] += 65536), (a < r || -1 == r) && (dD(e, t, n, l), e[vo] = (4294901760 & e[vo]) + l + 2), l++ } function dD(e, n, t, o) { const i = t[o] < 0, r = t[o + 1], a = e[i ? -t[o] : t[o]]; if (i) { if (e[Z] >> 11 < e[vo] >> 16 && (3 & e[Z]) === n) { e[Z] += 2048, Ft(4, a, r); try { r.call(a) } finally { Ft(5, a, r) } } } else { Ft(4, a, r); try { r.call(a) } finally { Ft(5, a, r) } } } const bo = -1; class Si { constructor(n, t, o) { this.factory = n, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = o } } function vl(e, n, t) { let o = 0; for (; o < t.length;) { const i = t[o]; if ("number" == typeof i) { if (0 !== i) break; o++; const r = t[o++], s = t[o++], a = t[o++]; e.setAttribute(n, s, a, r) } else { const r = i, s = t[++o]; Uf(r) ? e.setProperty(n, r, s) : e.setAttribute(n, r, s), o++ } } return o } function Hf(e) { return 3 === e || 4 === e || 6 === e } function Uf(e) { return 64 === e.charCodeAt(0) } function xi(e, n) { if (null !== n && 0 !== n.length) if (null === e || 0 === e.length) e = n.slice(); else { let t = -1; for (let o = 0; o < n.length; o++) { const i = n[o]; "number" == typeof i ? t = i : 0 === t || $f(e, t, i, null, -1 === t || 2 === t ? n[++o] : null) } } return e } function $f(e, n, t, o, i) { let r = 0, s = e.length; if (-1 === n) s = -1; else for (; r < e.length;) { const a = e[r++]; if ("number" == typeof a) { if (a === n) { s = -1; break } if (a > n) { s = r - 1; break } } } for (; r < e.length;) { const a = e[r]; if ("number" == typeof a) break; if (a === t) { if (null === o) return void (null !== i && (e[r + 1] = i)); if (o === e[r + 1]) return void (e[r + 2] = i) } r++, null !== o && r++, null !== i && r++ } -1 !== s && (e.splice(s, 0, n), r = s + 1), e.splice(r++, 0, t), null !== o && e.splice(r++, 0, o), null !== i && e.splice(r++, 0, i) } function qf(e) { return e !== bo } function Xr(e) { return 32767 & e } function es(e, n) { let t = function gD(e) { return e >> 16 }(e), o = n; for (; t > 0;)o = o[yo], t--; return o } let Cl = !0; function ts(e) { const n = Cl; return Cl = e, n } const Gf = 255, Qf = 5; let mD = 0; const nn = {}; function ns(e, n) { const t = zf(e, n); if (-1 !== t) return t; const o = n[P]; o.firstCreatePass && (e.injectorIndex = n.length, wl(o.data, e), wl(n, null), wl(o.blueprint, null)); const i = Dl(e, n), r = e.injectorIndex; if (qf(i)) { const s = Xr(i), a = es(i, n), l = a[P].data; for (let u = 0; u < 8; u++)n[r + u] = a[s + u] | l[s + u] } return n[r + 8] = i, r } function wl(e, n) { e.push(0, 0, 0, 0, 0, 0, 0, 0, n) } function zf(e, n) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === n[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Dl(e, n) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let t = 0, o = null, i = n; for (; null !== i;) { if (o = eh(i), null === o) return bo; if (t++, i = i[yo], -1 !== o.injectorIndex) return o.injectorIndex | t << 16 } return bo } function bl(e, n, t) { !function _D(e, n, t) { let o; "string" == typeof t ? o = t.charCodeAt(0) || 0 : t.hasOwnProperty(wi) && (o = t[wi]), null == o && (o = t[wi] = mD++); const i = o & Gf; n.data[e + (i >> Qf)] |= 1 << i }(e, n, t) } function Wf(e, n, t) { if (t & G.Optional || void 0 !== e) return e; kr() } function Kf(e, n, t, o) { if (t & G.Optional && void 0 === o && (o = null), !(t & (G.Self | G.Host))) { const i = e[Ur], r = Mt(void 0); try { return i ? i.get(n, o, t & G.Optional) : lf(n, o, t & G.Optional) } finally { Mt(r) } } return Wf(o, 0, t) } function Yf(e, n, t, o = G.Default, i) { if (null !== e) { if (1024 & n[Z]) { const s = function DD(e, n, t, o, i) { let r = e, s = n; for (; null !== r && null !== s && 1024 & s[Z] && !(256 & s[Z]);) { const a = Jf(r, s, t, o | G.Self, nn); if (a !== nn) return a; let l = r.parent; if (!l) { const u = s[mf]; if (u) { const c = u.get(t, nn, o); if (c !== nn) return c } l = eh(s), s = s[yo] } r = l } return i }(e, n, t, o, nn); if (s !== nn) return s } const r = Jf(e, n, t, o, nn); if (r !== nn) return r } return Kf(n, t, o, i) } function Jf(e, n, t, o, i) { const r = function CD(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const n = e.hasOwnProperty(wi) ? e[wi] : void 0; return "number" == typeof n ? n >= 0 ? n & Gf : wD : n }(t); if ("function" == typeof r) { if (!kf(n, e, o)) return o & G.Host ? Wf(i, 0, o) : Kf(n, t, o, i); try { const s = r(o); if (null != s || o & G.Optional) return s; kr() } finally { Bf() } } else if ("number" == typeof r) { let s = null, a = zf(e, n), l = bo, u = o & G.Host ? n[et][Xe] : null; for ((-1 === a || o & G.SkipSelf) && (l = -1 === a ? Dl(e, n) : n[a + 8], l !== bo && Xf(o, !1) ? (s = n[P], a = Xr(l), n = es(l, n)) : a = -1); -1 !== a;) { const c = n[P]; if (Zf(r, a, c.data)) { const d = vD(a, n, t, s, o, u); if (d !== nn) return d } l = n[a + 8], l !== bo && Xf(o, n[P].data[a + 8] === u) && Zf(r, a, n) ? (s = c, a = Xr(l), n = es(l, n)) : a = -1 } } return i } function vD(e, n, t, o, i, r) { const s = n[P], a = s.data[e + 8], c = os(a, s, t, null == o ? Ti(a) && Cl : o != s && 0 != (3 & a.type), i & G.Host && r === a); return null !== c ? Wn(n, s, c, a) : nn } function os(e, n, t, o, i) { const r = e.providerIndexes, s = n.data, a = 1048575 & r, l = e.directiveStart, c = r >> 20, p = i ? a + c : e.directiveEnd; for (let g = o ? a : a + c; g < p; g++) { const C = s[g]; if (g < l && t === C || g >= l && C.type === t) return g } if (i) { const g = s[l]; if (g && Ht(g) && g.type === t) return l } return null } function Wn(e, n, t, o) { let i = e[t]; const r = n.data; if (function fD(e) { return e instanceof Si }(i)) { const s = i; s.resolving && function _w(e, n) { const t = n ? `. Dependency path: ${n.join(" > ")} > ${e}` : ""; throw new O(-200, `Circular dependency in DI detected for ${e}${t}`) }(function le(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : z(e) }(r[t])); const a = ts(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? Mt(s.injectImpl) : null; kf(e, o, G.Default); try { i = e[t] = s.factory(void 0, r, e, o), n.firstCreatePass && t >= o.directiveStart && function cD(e, n, t) { const { ngOnChanges: o, ngOnInit: i, ngDoCheck: r } = n.type.prototype; if (o) { const s = wf(n); (t.preOrderHooks ?? (t.preOrderHooks = [])).push(e, s), (t.preOrderCheckHooks ?? (t.preOrderCheckHooks = [])).push(e, s) } i && (t.preOrderHooks ?? (t.preOrderHooks = [])).push(0 - e, i), r && ((t.preOrderHooks ?? (t.preOrderHooks = [])).push(e, r), (t.preOrderCheckHooks ?? (t.preOrderCheckHooks = [])).push(e, r)) }(t, r[t], n) } finally { null !== l && Mt(l), ts(a), s.resolving = !1, Bf() } } return i } function Zf(e, n, t) { return !!(t[n + (e >> Qf)] & 1 << e) } function Xf(e, n) { return !(e & G.Self || e & G.Host && n) } class Eo { constructor(n, t) { this._tNode = n, this._lView = t } get(n, t, o) { return Yf(this._tNode, this._lView, n, Br(o), t) } } function wD() { return new Eo(We(), T()) } function Ke(e) { return fn(() => { const n = e.prototype.constructor, t = n[pn] || El(n), o = Object.prototype; let i = Object.getPrototypeOf(e.prototype).constructor; for (; i && i !== o;) { const r = i[pn] || El(i); if (r && r !== t) return r; i = Object.getPrototypeOf(i) } return r => new r }) } function El(e) { return Ja(e) ? () => { const n = El(U(e)); return n && n() } : Qn(e) } function eh(e) { const n = e[P], t = n.type; return 2 === t ? n.declTNode : 1 === t ? e[Xe] : null } const To = "__parameters__"; function So(e, n, t) { return fn(() => { const o = function Tl(e) { return function (...t) { if (e) { const o = e(...t); for (const i in o) this[i] = o[i] } } }(n); function i(...r) { if (this instanceof i) return o.apply(this, r), this; const s = new i(...r); return a.annotation = s, a; function a(l, u, c) { const d = l.hasOwnProperty(To) ? l[To] : Object.defineProperty(l, To, { value: [] })[To]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), l } } return t && (i.prototype = Object.create(t.prototype)), i.prototype.ngMetadataName = e, i.annotationCls = i, i }) } class B { constructor(n, t) { this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = J({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Kn(e, n) { e.forEach(t => Array.isArray(t) ? Kn(t, n) : n(t)) } function nh(e, n, t) { n >= e.length ? e.push(t) : e.splice(n, 0, t) } function is(e, n) { return n >= e.length - 1 ? e.pop() : e.splice(n, 1)[0] } function Et(e, n, t) { let o = xo(e, n); return o >= 0 ? e[1 | o] = t : (o = ~o, function TD(e, n, t, o) { let i = e.length; if (i == n) e.push(t, o); else if (1 === i) e.push(o, e[0]), e[0] = t; else { for (i--, e.push(e[i - 1], e[i]); i > n;)e[i] = e[i - 2], i--; e[n] = t, e[n + 1] = o } }(e, o, n, t)), o } function Sl(e, n) { const t = xo(e, n); if (t >= 0) return e[1 | t] } function xo(e, n) { return function oh(e, n, t) { let o = 0, i = e.length >> t; for (; i !== o;) { const r = o + (i - o >> 1), s = e[r << t]; if (n === s) return r << t; s > n ? i = r : o = r + 1 } return ~(i << t) }(e, n, 1) } const ss = Ci(So("Optional"), 8), as = Ci(So("SkipSelf"), 4); var gt = (() => ((gt = gt || {})[gt.Important = 1] = "Important", gt[gt.DashCase = 2] = "DashCase", gt))(); const Pl = new Map; let WD = 0; const Ll = "__ngContext__"; function tt(e, n) { Dt(n) ? (e[Ll] = n[Ii], function YD(e) { Pl.set(e[Ii], e) }(n)) : e[Ll] = n } let Rl; function Vl(e, n) { return Rl(e, n) } function Li(e) { const n = e[Me]; return jt(n) ? n[Me] : n } function Bl(e) { return bh(e[bi]) } function jl(e) { return bh(e[Bt]) } function bh(e) { for (; null !== e && !jt(e);)e = e[Bt]; return e } function Fo(e, n, t, o, i) { if (null != o) { let r, s = !1; jt(o) ? r = o : Dt(o) && (s = !0, o = o[gn]); const a = ze(o); 0 === e && null !== t ? null == i ? xh(n, t, a) : Yn(n, t, a, i || null, !0) : 1 === e && null !== t ? Yn(n, t, a, i || null, !0) : 2 === e ? function zl(e, n, t) { const o = cs(e, n); o && function m1(e, n, t, o) { e.removeChild(n, t, o) }(e, o, n, t) }(n, a, s) : 3 === e && n.destroyNode(a), null != r && function v1(e, n, t, o, i) { const r = t[qr]; r !== ze(t) && Fo(n, e, o, r, i); for (let a = rt; a < t.length; a++) { const l = t[a]; Ri(l[P], l, e, n, o, r) } }(n, e, r, t, i) } } function Ul(e, n, t) { return e.createElement(n, t) } function Ih(e, n) { const t = e[Co], o = t.indexOf(n), i = n[Me]; 512 & n[Z] && (n[Z] &= -513, ul(i, -1)), t.splice(o, 1) } function $l(e, n) { if (e.length <= rt) return; const t = rt + n, o = e[t]; if (o) { const i = o[Ei]; null !== i && i !== e && Ih(i, o), n > 0 && (e[t - 1][Bt] = o[Bt]); const r = is(e, rt + n); !function l1(e, n) { Ri(e, n, n[ee], 2, null, null), n[gn] = null, n[Xe] = null }(o[P], o); const s = r[en]; null !== s && s.detachView(r[P]), o[Me] = null, o[Bt] = null, o[Z] &= -65 } return o } function Th(e, n) { if (!(128 & n[Z])) { const t = n[ee]; t.destroyNode && Ri(e, n, t, 3, null, null), function d1(e) { let n = e[bi]; if (!n) return ql(e[P], e); for (; n;) { let t = null; if (Dt(n)) t = n[bi]; else { const o = n[rt]; o && (t = o) } if (!t) { for (; n && !n[Bt] && n !== e;)Dt(n) && ql(n[P], n), n = n[Me]; null === n && (n = e), Dt(n) && ql(n[P], n), t = n && n[Bt] } n = t } }(n) } } function ql(e, n) { if (!(128 & n[Z])) { n[Z] &= -65, n[Z] |= 128, function g1(e, n) { let t; if (null != e && null != (t = e.destroyHooks)) for (let o = 0; o < t.length; o += 2) { const i = n[t[o]]; if (!(i instanceof Si)) { const r = t[o + 1]; if (Array.isArray(r)) for (let s = 0; s < r.length; s += 2) { const a = i[r[s]], l = r[s + 1]; Ft(4, a, l); try { l.call(a) } finally { Ft(5, a, l) } } else { Ft(4, i, r); try { r.call(i) } finally { Ft(5, i, r) } } } } }(e, n), function p1(e, n) { const t = e.cleanup, o = n[_o]; let i = -1; if (null !== t) for (let r = 0; r < t.length - 1; r += 2)if ("string" == typeof t[r]) { const s = t[r + 3]; s >= 0 ? o[i = s]() : o[i = -s].unsubscribe(), r += 2 } else { const s = o[i = t[r + 1]]; t[r].call(s) } if (null !== o) { for (let r = i + 1; r < o.length; r++)(0, o[r])(); n[_o] = null } }(e, n), 1 === n[P].type && n[ee].destroy(); const t = n[Ei]; if (null !== t && jt(n[Me])) { t !== n[Me] && Ih(t, n); const o = n[en]; null !== o && o.detachView(e) } !function JD(e) { Pl.delete(e[Ii]) }(n) } } function Ah(e, n, t) { return function Sh(e, n, t) { let o = n; for (; null !== o && 40 & o.type;)o = (n = o).parent; if (null === o) return t[gn]; { const { componentOffset: i } = o; if (i > -1) { const { encapsulation: r } = e.data[o.directiveStart + i]; if (r === Xt.None || r === Xt.Emulated) return null } return bt(o, t) } }(e, n.parent, t) } function Yn(e, n, t, o, i) { e.insertBefore(n, t, o, i) } function xh(e, n, t) { e.appendChild(n, t) } function Mh(e, n, t, o, i) { null !== o ? Yn(e, n, t, o, i) : xh(e, n, t) } function cs(e, n) { return e.parentNode(n) } let Gl, hs, Yl, ps, Nh = function Oh(e, n, t) { return 40 & e.type ? bt(e, t) : null }; function ds(e, n, t, o) { const i = Ah(e, o, n), r = n[ee], a = function Fh(e, n, t) { return Nh(e, n, t) }(o.parent || n[Xe], o, n); if (null != i) if (Array.isArray(t)) for (let l = 0; l < t.length; l++)Mh(r, i, t[l], a, !1); else Mh(r, i, t, a, !1); void 0 !== Gl && Gl(r, o, n, t, i) } function fs(e, n) { if (null !== n) { const t = n.type; if (3 & t) return bt(n, e); if (4 & t) return Ql(-1, e[n.index]); if (8 & t) { const o = n.child; if (null !== o) return fs(e, o); { const i = e[n.index]; return jt(i) ? Ql(-1, i) : ze(i) } } if (32 & t) return Vl(n, e)() || ze(e[n.index]); { const o = kh(e, n); return null !== o ? Array.isArray(o) ? o[0] : fs(Li(e[et]), o) : fs(e, n.next) } } return null } function kh(e, n) { return null !== n ? e[et][Xe].projection[n.projection] : null } function Ql(e, n) { const t = rt + e + 1; if (t < n.length) { const o = n[t], i = o[P].firstChild; if (null !== i) return fs(o, i) } return n[qr] } function Wl(e, n, t, o, i, r, s) { for (; null != t;) { const a = o[t.index], l = t.type; if (s && 0 === n && (a && tt(ze(a), o), t.flags |= 2), 32 != (32 & t.flags)) if (8 & l) Wl(e, n, t.child, o, i, r, !1), Fo(n, e, i, a, r); else if (32 & l) { const u = Vl(t, o); let c; for (; c = u();)Fo(n, e, i, c, r); Fo(n, e, i, a, r) } else 16 & l ? Lh(e, n, o, t, i, r) : Fo(n, e, i, a, r); t = s ? t.projectionNext : t.next } } function Ri(e, n, t, o, i, r) { Wl(t, o, e.firstChild, n, i, r, !1) } function Lh(e, n, t, o, i, r) { const s = t[et], l = s[Xe].projection[o.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)Fo(n, e, i, l[u], r); else Wl(e, n, l, s[Me], i, r, !0) } function Rh(e, n, t) { "" === t ? e.removeAttribute(n, "class") : e.setAttribute(n, "class", t) } function Vh(e, n, t) { const { mergedAttrs: o, classes: i, styles: r } = t; null !== o && vl(e, n, o), null !== i && Rh(e, n, i), null !== r && function w1(e, n, t) { e.setAttribute(n, "style", t) }(e, n, r) } function Oo(e) { return function Kl() { if (void 0 === hs && (hs = null, Ce.trustedTypes)) try { hs = Ce.trustedTypes.createPolicy("angular", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return hs }()?.createHTML(e) || e } function Jl() { if (void 0 === ps && (ps = null, Ce.trustedTypes)) try { ps = Ce.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch { } return ps } function jh(e) { return Jl()?.createHTML(e) || e } function Uh(e) { return Jl()?.createScriptURL(e) || e } class Jn { constructor(n) { this.changingThisBreaksApplicationSecurity = n } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Nr})` } } class T1 extends Jn { getTypeName() { return "HTML" } } class A1 extends Jn { getTypeName() { return "Style" } } class S1 extends Jn { getTypeName() { return "Script" } } class x1 extends Jn { getTypeName() { return "URL" } } class M1 extends Jn { getTypeName() { return "ResourceURL" } } function It(e) { return e instanceof Jn ? e.changingThisBreaksApplicationSecurity : e } function on(e, n) { const t = function F1(e) { return e instanceof Jn && e.getTypeName() || null }(e); if (null != t && t !== n) { if ("ResourceURL" === t && "URL" === n) return !0; throw new Error(`Required a safe ${n}, got a ${t} (see ${Nr})`) } return t === n } class R1 { constructor(n) { this.inertDocumentHelper = n } getInertBodyElement(n) { n = "<body><remove></remove>" + n; try { const t = (new window.DOMParser).parseFromString(Oo(n), "text/html").body; return null === t ? this.inertDocumentHelper.getInertBodyElement(n) : (t.removeChild(t.firstChild), t) } catch { return null } } } class V1 { constructor(n) { this.defaultDoc = n, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert") } getInertBodyElement(n) { const t = this.inertDocument.createElement("template"); return t.innerHTML = Oo(n), t } } const j1 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function gs(e) { return (e = String(e)).match(j1) ? e : "unsafe:" + e } function yn(e) { const n = {}; for (const t of e.split(",")) n[t] = !0; return n } function Vi(...e) { const n = {}; for (const t of e) for (const o in t) t.hasOwnProperty(o) && (n[o] = !0); return n } const qh = yn("area,br,col,hr,img,wbr"), Gh = yn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Qh = yn("rp,rt"), Zl = Vi(qh, Vi(Gh, yn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Vi(Qh, yn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Vi(Qh, Gh)), Xl = yn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), zh = Vi(Xl, yn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), yn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), H1 = yn("script,style,template"); class U1 { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(n) { let t = n.firstChild, o = !0; for (; t;)if (t.nodeType === Node.ELEMENT_NODE ? o = this.startElement(t) : t.nodeType === Node.TEXT_NODE ? this.chars(t.nodeValue) : this.sanitizedSomething = !0, o && t.firstChild) t = t.firstChild; else for (; t;) { t.nodeType === Node.ELEMENT_NODE && this.endElement(t); let i = this.checkClobberedElement(t, t.nextSibling); if (i) { t = i; break } t = this.checkClobberedElement(t, t.parentNode) } return this.buf.join("") } startElement(n) { const t = n.nodeName.toLowerCase(); if (!Zl.hasOwnProperty(t)) return this.sanitizedSomething = !0, !H1.hasOwnProperty(t); this.buf.push("<"), this.buf.push(t); const o = n.attributes; for (let i = 0; i < o.length; i++) { const r = o.item(i), s = r.name, a = s.toLowerCase(); if (!zh.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = r.value; Xl[a] && (l = gs(l)), this.buf.push(" ", s, '="', Wh(l), '"') } return this.buf.push(">"), !0 } endElement(n) { const t = n.nodeName.toLowerCase(); Zl.hasOwnProperty(t) && !qh.hasOwnProperty(t) && (this.buf.push("</"), this.buf.push(t), this.buf.push(">")) } chars(n) { this.buf.push(Wh(n)) } checkClobberedElement(n, t) { if (t && (n.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${n.outerHTML}`); return t } } const $1 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, q1 = /([^\#-~ |!])/g; function Wh(e) { return e.replace(/&/g, "&amp;").replace($1, function (n) { return "&#" + (1024 * (n.charCodeAt(0) - 55296) + (n.charCodeAt(1) - 56320) + 65536) + ";" }).replace(q1, function (n) { return "&#" + n.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let ms; function Kh(e, n) { let t = null; try { ms = ms || function $h(e) { const n = new V1(e); return function B1() { try { return !!(new window.DOMParser).parseFromString(Oo(""), "text/html") } catch { return !1 } }() ? new R1(n) : n }(e); let o = n ? String(n) : ""; t = ms.getInertBodyElement(o); let i = 5, r = o; do { if (0 === i) throw new Error("Failed to sanitize html because the input is unstable"); i--, o = r, r = t.innerHTML, t = ms.getInertBodyElement(o) } while (o !== r); return Oo((new U1).sanitizeChildren(eu(t) || t)) } finally { if (t) { const o = eu(t) || t; for (; o.firstChild;)o.removeChild(o.firstChild) } } } function eu(e) { return "content" in e && function G1(e) { return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName }(e) ? e.content : null } var _e = (() => ((_e = _e || {})[_e.NONE = 0] = "NONE", _e[_e.HTML = 1] = "HTML", _e[_e.STYLE = 2] = "STYLE", _e[_e.SCRIPT = 3] = "SCRIPT", _e[_e.URL = 4] = "URL", _e[_e.RESOURCE_URL = 5] = "RESOURCE_URL", _e))(); function vn(e) { const n = Bi(); return n ? jh(n.sanitize(_e.HTML, e) || "") : on(e, "HTML") ? jh(It(e)) : Kh(function Bh() { return void 0 !== Yl ? Yl : typeof document < "u" ? document : void 0 }(), z(e)) } function tu(e) { const n = Bi(); if (n) return Uh(n.sanitize(_e.RESOURCE_URL, e) || ""); if (on(e, "ResourceURL")) return Uh(It(e)); throw new O(904, !1) } function Bi() { const e = T(); return e && e[rl] } const Jh = new B("ENVIRONMENT_INITIALIZER"), Zh = new B("INJECTOR", -1), Xh = new B("INJECTOR_DEF_TYPES"); class ep { get(n, t = yi) { if (t === yi) { const o = new Error(`NullInjectorError: No provider for ${ge(n)}!`); throw o.name = "NullInjectorError", o } return t } } function X1(...e) { return { \u0275providers: tp(0, e), \u0275fromNgModule: !0 } } function tp(e, ...n) { const t = [], o = new Set; let i; return Kn(n, r => { const s = r; nu(s, t, [], o) && (i || (i = []), i.push(s)) }), void 0 !== i && np(i, t), t } function np(e, n) { for (let t = 0; t < e.length; t++) { const { providers: i } = e[t]; ou(i, r => { n.push(r) }) } } function nu(e, n, t, o) { if (!(e = U(e))) return !1; let i = null, r = sf(e); const s = !r && ce(e); if (r || s) { if (s && !s.standalone) return !1; i = e } else { const l = e.ngModule; if (r = sf(l), !r) return !1; i = l } const a = o.has(i); if (s) { if (a) return !1; if (o.add(i), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const u of l) nu(u, n, t, o) } } else { if (!r) return !1; { if (null != r.imports && !a) { let u; o.add(i); try { Kn(r.imports, c => { nu(c, n, t, o) && (u || (u = []), u.push(c)) }) } finally { } void 0 !== u && np(u, n) } if (!a) { const u = Qn(i) || (() => new i); n.push({ provide: i, useFactory: u, deps: ae }, { provide: Xh, useValue: i, multi: !0 }, { provide: Jh, useValue: () => q(i), multi: !0 }) } const l = r.providers; null == l || a || ou(l, c => { n.push(c) }) } } return i !== e && void 0 !== e.providers } function ou(e, n) { for (let t of e) Za(t) && (t = t.\u0275providers), Array.isArray(t) ? ou(t, n) : n(t) } const eb = fe({ provide: String, useValue: fe }); function iu(e) { return null !== e && "object" == typeof e && eb in e } function Zn(e) { return "function" == typeof e } const ru = new B("Set Injector scope."), _s = {}, nb = {}; let su; function ys() { return void 0 === su && (su = new ep), su } class Xn { } class rp extends Xn { get destroyed() { return this._destroyed } constructor(n, t, o, i) { super(), this.parent = t, this.source = o, this.scopes = i, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, lu(n, s => this.processProvider(s)), this.records.set(Zh, No(void 0, this)), i.has("environment") && this.records.set(Xn, No(void 0, this)); const r = this.records.get(ru); null != r && "string" == typeof r.value && this.scopes.add(r.value), this.injectorDefTypes = new Set(this.get(Xh.multi, ae, G.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const n of this._ngOnDestroyHooks) n.ngOnDestroy(); for (const n of this._onDestroyHooks) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(n) { this._onDestroyHooks.push(n) } runInContext(n) { this.assertNotDestroyed(); const t = go(this), o = Mt(void 0); try { return n() } finally { go(t), Mt(o) } } get(n, t = yi, o = G.Default) { this.assertNotDestroyed(), o = Br(o); const i = go(this), r = Mt(void 0); try { if (!(o & G.SkipSelf)) { let a = this.records.get(n); if (void 0 === a) { const l = function ab(e) { return "function" == typeof e || "object" == typeof e && e instanceof B }(n) && Lr(n); a = l && this.injectableDefInScope(l) ? No(au(n), _s) : null, this.records.set(n, a) } if (null != a) return this.hydrate(n, a) } return (o & G.Self ? ys() : this.parent).get(n, t = o & G.Optional && t === yi ? null : t) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[Vr] = s[Vr] || []).unshift(ge(n)), i) throw s; return function Mw(e, n, t, o) { const i = e[Vr]; throw n[uf] && i.unshift(n[uf]), e.message = function Fw(e, n, t, o = null) { e = e && "\n" === e.charAt(0) && e.charAt(1) == Aw ? e.slice(2) : e; let i = ge(n); if (Array.isArray(n)) i = n.map(ge).join(" -> "); else if ("object" == typeof n) { let r = []; for (let s in n) if (n.hasOwnProperty(s)) { let a = n[s]; r.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : ge(a))) } i = `{${r.join(", ")}}` } return `${t}${o ? "(" + o + ")" : ""}[${i}]: ${e.replace(Tw, "\n  ")}` }("\n" + e.message, i, t, o), e[Iw] = i, e[Vr] = null, e }(s, n, "R3InjectorError", this.source) } throw s } finally { Mt(r), go(i) } } resolveInjectorInitializers() { const n = go(this), t = Mt(void 0); try { const o = this.get(Jh.multi, ae, G.Self); for (const i of o) i() } finally { go(n), Mt(t) } } toString() { const n = [], t = this.records; for (const o of t.keys()) n.push(ge(o)); return `R3Injector[${n.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new O(205, !1) } processProvider(n) { let t = Zn(n = U(n)) ? n : U(n && n.provide); const o = function ib(e) { return iu(e) ? No(void 0, e.useValue) : No(sp(e), _s) }(n); if (Zn(n) || !0 !== n.multi) this.records.get(t); else { let i = this.records.get(t); i || (i = No(void 0, _s, !0), i.factory = () => nl(i.multi), this.records.set(t, i)), t = n, i.multi.push(n) } this.records.set(t, o) } hydrate(n, t) { return t.value === _s && (t.value = nb, t.value = t.factory()), "object" == typeof t.value && t.value && function sb(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(t.value) && this._ngOnDestroyHooks.add(t.value), t.value } injectableDefInScope(n) { if (!n.providedIn) return !1; const t = U(n.providedIn); return "string" == typeof t ? "any" === t || this.scopes.has(t) : this.injectorDefTypes.has(t) } } function au(e) { const n = Lr(e), t = null !== n ? n.factory : Qn(e); if (null !== t) return t; if (e instanceof B) throw new O(204, !1); if (e instanceof Function) return function ob(e) { const n = e.length; if (n > 0) throw function Oi(e, n) { const t = []; for (let o = 0; o < e; o++)t.push(n); return t }(n, "?"), new O(204, !1); const t = function Dw(e) { return e && (e[Rr] || e[af]) || null }(e); return null !== t ? () => t.factory(e) : () => new e }(e); throw new O(204, !1) } function sp(e, n, t) { let o; if (Zn(e)) { const i = U(e); return Qn(i) || au(i) } if (iu(e)) o = () => U(e.useValue); else if (function ip(e) { return !(!e || !e.useFactory) }(e)) o = () => e.useFactory(...nl(e.deps || [])); else if (function op(e) { return !(!e || !e.useExisting) }(e)) o = () => q(U(e.useExisting)); else { const i = U(e && (e.useClass || e.provide)); if (!function rb(e) { return !!e.deps }(e)) return Qn(i) || au(i); o = () => new i(...nl(e.deps)) } return o } function No(e, n, t = !1) { return { factory: e, value: n, multi: t ? [] : void 0 } } function lu(e, n) { for (const t of e) Array.isArray(t) ? lu(t, n) : t && Za(t) ? lu(t.\u0275providers, n) : n(t) } class lb { } class ap { } class cb { resolveComponentFactory(n) { throw function ub(e) { const n = Error(`No component factory found for ${ge(e)}. Did you add it to @NgModule.entryComponents?`); return n.ngComponent = e, n }(n) } } let Po = (() => { class e { } return e.NULL = new cb, e })(); function db() { return ko(We(), T()) } function ko(e, n) { return new Nt(bt(e, n)) } let Nt = (() => { class e { constructor(t) { this.nativeElement = t } } return e.__NG_ELEMENT_ID__ = db, e })(); function fb(e) { return e instanceof Nt ? e.nativeElement : e } class up { } let eo = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function hb() { const e = T(), t = pt(We().index, e); return (Dt(t) ? t : e)[ee] }(), e })(), pb = (() => { class e { } return e.\u0275prov = J({ token: e, providedIn: "root", factory: () => null }), e })(); class ji { constructor(n) { this.full = n, this.major = n.split(".")[0], this.minor = n.split(".")[1], this.patch = n.split(".").slice(2).join(".") } } const gb = new ji("15.2.10"), uu = {}, cu = "ngOriginalError"; function du(e) { return e[cu] } class Lo { constructor() { this._console = console } handleError(n) { const t = this._findOriginalError(n); this._console.error("ERROR", n), t && this._console.error("ORIGINAL ERROR", t) } _findOriginalError(n) { let t = n && du(n); for (; t && du(t);)t = du(t); return t || null } } function cp(e) { return e.ownerDocument } function fp(e, n, t) { let o = e.length; for (; ;) { const i = e.indexOf(n, t); if (-1 === i) return i; if (0 === i || e.charCodeAt(i - 1) <= 32) { const r = n.length; if (i + r === o || e.charCodeAt(i + r) <= 32) return i } t = i + 1 } } const hp = "ng-template"; function Ib(e, n, t) { let o = 0, i = !0; for (; o < e.length;) { let r = e[o++]; if ("string" == typeof r && i) { const s = e[o++]; if (t && "class" === r && -1 !== fp(s.toLowerCase(), n, 0)) return !0 } else { if (1 === r) { for (; o < e.length && "string" == typeof (r = e[o++]);)if (r.toLowerCase() === n) return !0; return !1 } "number" == typeof r && (i = !1) } } return !1 } function pp(e) { return 4 === e.type && e.value !== hp } function Tb(e, n, t) { return n === (4 !== e.type || t ? e.value : hp) } function Ab(e, n, t) { let o = 4; const i = e.attrs || [], r = function Mb(e) { for (let n = 0; n < e.length; n++)if (Hf(e[n])) return n; return e.length }(i); let s = !1; for (let a = 0; a < n.length; a++) { const l = n[a]; if ("number" != typeof l) { if (!s) if (4 & o) { if (o = 2 | 1 & o, "" !== l && !Tb(e, l, t) || "" === l && 1 === n.length) { if (Ut(o)) return !1; s = !0 } } else { const u = 8 & o ? l : n[++a]; if (8 & o && null !== e.attrs) { if (!Ib(e.attrs, u, t)) { if (Ut(o)) return !1; s = !0 } continue } const d = Sb(8 & o ? "class" : l, i, pp(e), t); if (-1 === d) { if (Ut(o)) return !1; s = !0; continue } if ("" !== u) { let p; p = d > r ? "" : i[d + 1].toLowerCase(); const g = 8 & o ? p : null; if (g && -1 !== fp(g, u, 0) || 2 & o && u !== p) { if (Ut(o)) return !1; s = !0 } } } } else { if (!s && !Ut(o) && !Ut(l)) return !1; if (s && Ut(l)) continue; s = !1, o = l | 1 & o } } return Ut(o) || s } function Ut(e) { return 0 == (1 & e) } function Sb(e, n, t, o) { if (null === n) return -1; let i = 0; if (o || !t) { let r = !1; for (; i < n.length;) { const s = n[i]; if (s === e) return i; if (3 === s || 6 === s) r = !0; else { if (1 === s || 2 === s) { let a = n[++i]; for (; "string" == typeof a;)a = n[++i]; continue } if (4 === s) break; if (0 === s) { i += 4; continue } } i += r ? 1 : 2 } return -1 } return function Fb(e, n) { let t = e.indexOf(4); if (t > -1) for (t++; t < e.length;) { const o = e[t]; if ("number" == typeof o) return -1; if (o === n) return t; t++ } return -1 }(n, e) } function gp(e, n, t = !1) { for (let o = 0; o < n.length; o++)if (Ab(e, n[o], t)) return !0; return !1 } function mp(e, n) { return e ? ":not(" + n.trim() + ")" : n } function Nb(e) { let n = e[0], t = 1, o = 2, i = "", r = !1; for (; t < e.length;) { let s = e[t]; if ("string" == typeof s) if (2 & o) { const a = e[++t]; i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & o ? i += "." + s : 4 & o && (i += " " + s); else "" !== i && !Ut(s) && (n += mp(r, i), i = ""), o = s, r = r || !Ut(o); t++ } return "" !== i && (n += mp(r, i)), n } const Y = {}; function f(e) { _p(ie(), T(), at() + e, !1) } function _p(e, n, t, o) { if (!o) if (3 == (3 & n[Z])) { const r = e.preOrderCheckHooks; null !== r && Jr(n, r, t) } else { const r = e.preOrderHooks; null !== r && Zr(n, r, 0, t) } zn(t) } function wp(e, n = null, t = null, o) { const i = Dp(e, n, t, o); return i.resolveInjectorInitializers(), i } function Dp(e, n = null, t = null, o, i = new Set) { const r = [t || ae, X1(e)]; return o = o || ("object" == typeof e ? void 0 : ge(e)), new rp(r, n || ys(), o || null, i) } let $e = (() => { class e { static create(t, o) { if (Array.isArray(t)) return wp({ name: "" }, o, t, ""); { const i = t.name ?? ""; return wp({ name: i }, t.parent, t.providers, i) } } } return e.THROW_IF_NOT_FOUND = yi, e.NULL = new ep, e.\u0275prov = J({ token: e, providedIn: "any", factory: () => q(Zh) }), e.__NG_ELEMENT_ID__ = -1, e })(); function b(e, n = G.Default) { const t = T(); return null === t ? q(e, n) : Yf(We(), t, U(e), n) } function xp(e, n) { const t = e.contentQueries; if (null !== t) for (let o = 0; o < t.length; o += 2) { const r = t[o + 1]; if (-1 !== r) { const s = e.data[r]; pl(t[o]), s.contentQueries(2, n[r], r) } } } function Cs(e, n, t, o, i, r, s, a, l, u, c) { const d = n.blueprint.slice(); return d[gn] = i, d[Z] = 76 | o, (null !== c || e && 1024 & e[Z]) && (d[Z] |= 1024), Af(d), d[Me] = d[yo] = e, d[Oe] = t, d[$r] = s || e && e[$r], d[ee] = a || e && e[ee], d[rl] = l || e && e[rl] || null, d[Ur] = u || e && e[Ur] || null, d[Xe] = r, d[Ii] = function KD() { return WD++ }(), d[mf] = c, d[et] = 2 == n.type ? e[et] : d, d } function Bo(e, n, t, o, i) { let r = e.data[n]; if (null === r) r = function mu(e, n, t, o, i) { const r = Mf(), s = cl(), l = e.data[n] = function sE(e, n, t, o, i, r) { return { type: t, index: o, insertBeforeIndex: null, injectorIndex: n ? n.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: n, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? r : r && r.parent, t, n, o, i); return null === e.firstChild && (e.firstChild = l), null !== r && (s ? null == r.child && null !== l.parent && (r.child = l) : null === r.next && (r.next = l, l.prev = r)), l }(e, n, t, o, i), function eD() { return K.lFrame.inI18n }() && (r.flags |= 32); else if (64 & r.type) { r.type = t, r.value = o, r.attrs = i; const s = function Ai() { const e = K.lFrame, n = e.currentTNode; return e.isParent ? n : n.parent }(); r.injectorIndex = null === s ? -1 : s.injectorIndex } return tn(r, !0), r } function Hi(e, n, t, o) { if (0 === t) return -1; const i = n.length; for (let r = 0; r < t; r++)n.push(o), e.blueprint.push(o), e.data.push(null); return i } function _u(e, n, t) { gl(n); try { const o = e.viewQuery; null !== o && Tu(1, o, t); const i = e.template; null !== i && Mp(e, n, i, 1, t), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && xp(e, n), e.staticViewQueries && Tu(2, e.viewQuery, t); const r = e.components; null !== r && function oE(e, n) { for (let t = 0; t < n.length; t++)TE(e, n[t]) }(n, r) } catch (o) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), o } finally { n[Z] &= -5, ml() } } function ws(e, n, t, o) { const i = n[Z]; if (128 != (128 & i)) { gl(n); try { Af(n), function Of(e) { return K.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== t && Mp(e, n, t, 2, o); const s = 3 == (3 & i); if (s) { const u = e.preOrderCheckHooks; null !== u && Jr(n, u, null) } else { const u = e.preOrderHooks; null !== u && Zr(n, u, 0, null), _l(n, 0) } if (function EE(e) { for (let n = Bl(e); null !== n; n = jl(n)) { if (!n[_f]) continue; const t = n[Co]; for (let o = 0; o < t.length; o++) { const i = t[o]; 512 & i[Z] || ul(i[Me], 1), i[Z] |= 512 } } }(n), function bE(e) { for (let n = Bl(e); null !== n; n = jl(n))for (let t = rt; t < n.length; t++) { const o = n[t], i = o[P]; Wr(o) && ws(i, o, i.template, o[Oe]) } }(n), null !== e.contentQueries && xp(e, n), s) { const u = e.contentCheckHooks; null !== u && Jr(n, u) } else { const u = e.contentHooks; null !== u && Zr(n, u, 1), _l(n, 1) } !function tE(e, n) { const t = e.hostBindingOpCodes; if (null !== t) try { for (let o = 0; o < t.length; o++) { const i = t[o]; if (i < 0) zn(~i); else { const r = i, s = t[++o], a = t[++o]; tD(s, r), a(2, n[r]) } } } finally { zn(-1) } }(e, n); const a = e.components; null !== a && function nE(e, n) { for (let t = 0; t < n.length; t++)IE(e, n[t]) }(n, a); const l = e.viewQuery; if (null !== l && Tu(2, l, o), s) { const u = e.viewCheckHooks; null !== u && Jr(n, u) } else { const u = e.viewHooks; null !== u && Zr(n, u, 2), _l(n, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), n[Z] &= -41, 512 & n[Z] && (n[Z] &= -513, ul(n[Me], -1)) } finally { ml() } } } function Mp(e, n, t, o, i) { const r = at(), s = 2 & o; try { zn(-1), s && n.length > we && _p(e, n, we, !1), Ft(s ? 2 : 0, i), t(o, i) } finally { zn(r), Ft(s ? 3 : 1, i) } } function yu(e, n, t) { if (al(n)) { const i = n.directiveEnd; for (let r = n.directiveStart; r < i; r++) { const s = e.data[r]; s.contentQueries && s.contentQueries(1, t[r], r) } } } function vu(e, n, t) { xf() && (function hE(e, n, t, o) { const i = t.directiveStart, r = t.directiveEnd; Ti(t) && function CE(e, n, t) { const o = bt(n, e), i = Fp(t), r = e[$r], s = Ds(e, Cs(e, i, null, t.onPush ? 32 : 16, o, n, r, r.createRenderer(o, t), null, null, null)); e[n.index] = s }(n, t, e.data[i + t.componentOffset]), e.firstCreatePass || ns(t, n), tt(o, n); const s = t.initialInputs; for (let a = i; a < r; a++) { const l = e.data[a], u = Wn(n, e, a, t); tt(u, n), null !== s && wE(0, a - i, u, l, 0, s), Ht(l) && (pt(t.index, n)[Oe] = Wn(n, e, a, t)) } }(e, n, t, bt(t, n)), 64 == (64 & t.flags) && Lp(e, n, t)) } function Cu(e, n, t = bt) { const o = n.localNames; if (null !== o) { let i = n.index + 1; for (let r = 0; r < o.length; r += 2) { const s = o[r + 1], a = -1 === s ? t(n, e) : e[s]; e[i++] = a } } } function Fp(e) { const n = e.tView; return null === n || n.incompleteFirstPass ? e.tView = wu(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : n } function wu(e, n, t, o, i, r, s, a, l, u) { const c = we + o, d = c + i, p = function iE(e, n) { const t = []; for (let o = 0; o < n; o++)t.push(o < e ? null : Y); return t }(c, d), g = "function" == typeof u ? u() : u; return p[P] = { type: e, blueprint: p, template: t, queries: null, viewQuery: a, declTNode: n, data: p.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: g, incompleteFirstPass: !1 } } function Op(e, n, t, o) { const i = Vp(n); null === t ? i.push(o) : (i.push(t), e.firstCreatePass && Bp(e).push(o, i.length - 1)) } function Np(e, n, t, o) { for (let i in e) if (e.hasOwnProperty(i)) { t = null === t ? {} : t; const r = e[i]; null === o ? Pp(t, n, i, r) : o.hasOwnProperty(i) && Pp(t, n, o[i], r) } return t } function Pp(e, n, t, o) { e.hasOwnProperty(t) ? e[t].push(n, o) : e[t] = [n, o] } function Tt(e, n, t, o, i, r, s, a) { const l = bt(n, t); let c, u = n.inputs; !a && null != u && (c = u[o]) ? (Au(e, t, c, o, i), Ti(n) && function uE(e, n) { const t = pt(n, e); 16 & t[Z] || (t[Z] |= 32) }(t, n.index)) : 3 & n.type && (o = function lE(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(o), i = null != s ? s(i, n.value || "", o) : i, r.setProperty(l, o, i)) } function Du(e, n, t, o) { if (xf()) { const i = null === o ? null : { "": -1 }, r = function gE(e, n) { const t = e.directiveRegistry; let o = null, i = null; if (t) for (let r = 0; r < t.length; r++) { const s = t[r]; if (gp(n, s.selectors, !1)) if (o || (o = []), Ht(s)) if (null !== s.findHostDirectiveDefs) { const a = []; i = i || new Map, s.findHostDirectiveDefs(s, a, i), o.unshift(...a, s), bu(e, n, a.length) } else o.unshift(s), bu(e, n, 0); else i = i || new Map, s.findHostDirectiveDefs?.(s, o, i), o.push(s) } return null === o ? null : [o, i] }(e, t); let s, a; null === r ? s = a = null : [s, a] = r, null !== s && kp(e, n, t, s, i, a), i && function mE(e, n, t) { if (n) { const o = e.localNames = []; for (let i = 0; i < n.length; i += 2) { const r = t[n[i + 1]]; if (null == r) throw new O(-301, !1); o.push(n[i], r) } } }(t, o, i) } t.mergedAttrs = xi(t.mergedAttrs, t.attrs) } function kp(e, n, t, o, i, r) { for (let u = 0; u < o.length; u++)bl(ns(t, n), e, o[u].type); !function yE(e, n, t) { e.flags |= 1, e.directiveStart = n, e.directiveEnd = n + t, e.providerIndexes = n }(t, e.data.length, o.length); for (let u = 0; u < o.length; u++) { const c = o[u]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, l = Hi(e, n, o.length, null); for (let u = 0; u < o.length; u++) { const c = o[u]; t.mergedAttrs = xi(t.mergedAttrs, c.hostAttrs), vE(e, t, n, l, c), _E(l, c, i), null !== c.contentQueries && (t.flags |= 4), (null !== c.hostBindings || null !== c.hostAttrs || 0 !== c.hostVars) && (t.flags |= 64); const d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ?? (e.preOrderHooks = [])).push(t.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ?? (e.preOrderCheckHooks = [])).push(t.index), a = !0), l++ } !function aE(e, n, t) { const i = n.directiveEnd, r = e.data, s = n.attrs, a = []; let l = null, u = null; for (let c = n.directiveStart; c < i; c++) { const d = r[c], p = t ? t.get(d) : null, C = p ? p.outputs : null; l = Np(d.inputs, c, l, p ? p.inputs : null), u = Np(d.outputs, c, u, C); const w = null === l || null === s || pp(n) ? null : DE(l, c, s); a.push(w) } null !== l && (l.hasOwnProperty("class") && (n.flags |= 8), l.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = l, n.outputs = u }(e, t, r) } function Lp(e, n, t) { const o = t.directiveStart, i = t.directiveEnd, r = t.index, s = function nD() { return K.lFrame.currentDirectiveIndex }(); try { zn(r); for (let a = o; a < i; a++) { const l = e.data[a], u = n[a]; fl(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && pE(l, u) } } finally { zn(-1), fl(s) } } function pE(e, n) { null !== e.hostBindings && e.hostBindings(1, n) } function bu(e, n, t) { n.componentOffset = t, (e.components ?? (e.components = [])).push(n.index) } function _E(e, n, t) { if (t) { if (n.exportAs) for (let o = 0; o < n.exportAs.length; o++)t[n.exportAs[o]] = e; Ht(n) && (t[""] = e) } } function vE(e, n, t, o, i) { e.data[o] = i; const r = i.factory || (i.factory = Qn(i.type)), s = new Si(r, Ht(i), b); e.blueprint[o] = s, t[o] = s, function dE(e, n, t, o, i) { const r = i.hostBindings; if (r) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~n.index; (function fE(e) { let n = e.length; for (; n > 0;) { const t = e[--n]; if ("number" == typeof t && t < 0) return t } return 0 })(s) != a && s.push(a), s.push(t, o, r) } }(e, n, o, Hi(e, t, i.hostVars, Y), i) } function rn(e, n, t, o, i, r) { const s = bt(e, n); !function Eu(e, n, t, o, i, r, s) { if (null == r) e.removeAttribute(n, i, t); else { const a = null == s ? z(r) : s(r, o || "", i); e.setAttribute(n, i, a, t) } }(n[ee], s, r, e.value, t, o, i) } function wE(e, n, t, o, i, r) { const s = r[n]; if (null !== s) { const a = o.setInput; for (let l = 0; l < s.length;) { const u = s[l++], c = s[l++], d = s[l++]; null !== a ? o.setInput(t, d, u, c) : t[c] = d } } } function DE(e, n, t) { let o = null, i = 0; for (; i < t.length;) { const r = t[i]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; if (e.hasOwnProperty(r)) { null === o && (o = []); const s = e[r]; for (let a = 0; a < s.length; a += 2)if (s[a] === n) { o.push(r, s[a + 1], t[i + 1]); break } } i += 2 } else i += 2; else i += 4 } return o } function Rp(e, n, t, o) { return [e, !0, !1, n, null, 0, o, t, null, null] } function IE(e, n) { const t = pt(n, e); if (Wr(t)) { const o = t[P]; 48 & t[Z] ? ws(o, t, o.template, t[Oe]) : t[Gn] > 0 && Iu(t) } } function Iu(e) { for (let o = Bl(e); null !== o; o = jl(o))for (let i = rt; i < o.length; i++) { const r = o[i]; if (Wr(r)) if (512 & r[Z]) { const s = r[P]; ws(s, r, s.template, r[Oe]) } else r[Gn] > 0 && Iu(r) } const t = e[P].components; if (null !== t) for (let o = 0; o < t.length; o++) { const i = pt(t[o], e); Wr(i) && i[Gn] > 0 && Iu(i) } } function TE(e, n) { const t = pt(n, e), o = t[P]; (function AE(e, n) { for (let t = n.length; t < e.blueprint.length; t++)n.push(e.blueprint[t]) })(o, t), _u(o, t, t[Oe]) } function Ds(e, n) { return e[bi] ? e[gf][Bt] = n : e[bi] = n, e[gf] = n, n } function bs(e) { for (; e;) { e[Z] |= 32; const n = Li(e); if (Rw(e) && !n) return e; e = n } return null } function Es(e, n, t, o = !0) { const i = n[$r]; i.begin && i.begin(); try { ws(e, n, e.template, t) } catch (s) { throw o && Hp(n, s), s } finally { i.end && i.end() } } function Tu(e, n, t) { pl(0), n(e, t) } function Vp(e) { return e[_o] || (e[_o] = []) } function Bp(e) { return e.cleanup || (e.cleanup = []) } function Hp(e, n) { const t = e[Ur], o = t ? t.get(Lo, null) : null; o && o.handleError(n) } function Au(e, n, t, o, i) { for (let r = 0; r < t.length;) { const s = t[r++], a = t[r++], l = n[s], u = e.data[s]; null !== u.setInput ? u.setInput(l, i, o, a) : l[a] = i } } function wn(e, n, t) { const o = zr(n, e); !function Eh(e, n, t) { e.setValue(n, t) }(e[ee], o, t) } function Is(e, n, t) { let o = t ? e.styles : null, i = t ? e.classes : null, r = 0; if (null !== n) for (let s = 0; s < n.length; s++) { const a = n[s]; "number" == typeof a ? r = a : 1 == r ? i = Ya(i, a) : 2 == r && (o = Ya(o, a + ": " + n[++s] + ";")) } t ? e.styles = o : e.stylesWithoutHost = o, t ? e.classes = i : e.classesWithoutHost = i } function Ts(e, n, t, o, i = !1) { for (; null !== t;) { const r = n[t.index]; if (null !== r && o.push(ze(r)), jt(r)) for (let a = rt; a < r.length; a++) { const l = r[a], u = l[P].firstChild; null !== u && Ts(l[P], l, u, o) } const s = t.type; if (8 & s) Ts(e, n, t.child, o); else if (32 & s) { const a = Vl(t, n); let l; for (; l = a();)o.push(l) } else if (16 & s) { const a = kh(n, t); if (Array.isArray(a)) o.push(...a); else { const l = Li(n[et]); Ts(l[P], l, a, o, !0) } } t = i ? t.projectionNext : t.next } return o } class Ui { get rootNodes() { const n = this._lView, t = n[P]; return Ts(t, n, t.firstChild, []) } constructor(n, t) { this._lView = n, this._cdRefInjectingView = t, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[Oe] } set context(n) { this._lView[Oe] = n } get destroyed() { return 128 == (128 & this._lView[Z]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const n = this._lView[Me]; if (jt(n)) { const t = n[Gr], o = t ? t.indexOf(this) : -1; o > -1 && ($l(n, o), is(t, o)) } this._attachedToViewContainer = !1 } Th(this._lView[P], this._lView) } onDestroy(n) { Op(this._lView[P], this._lView, null, n) } markForCheck() { bs(this._cdRefInjectingView || this._lView) } detach() { this._lView[Z] &= -65 } reattach() { this._lView[Z] |= 64 } detectChanges() { Es(this._lView[P], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new O(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function c1(e, n) { Ri(e, n, n[ee], 2, null, null) }(this._lView[P], this._lView) } attachToAppRef(n) { if (this._attachedToViewContainer) throw new O(902, !1); this._appRef = n } } class SE extends Ui { constructor(n) { super(n), this._view = n } detectChanges() { const n = this._view; Es(n[P], n, n[Oe], !1) } checkNoChanges() { } get context() { return null } } class Up extends Po { constructor(n) { super(), this.ngModule = n } resolveComponentFactory(n) { const t = ce(n); return new $i(t, this.ngModule) } } function $p(e) { const n = []; for (let t in e) e.hasOwnProperty(t) && n.push({ propName: e[t], templateName: t }); return n } class ME { constructor(n, t) { this.injector = n, this.parentInjector = t } get(n, t, o) { o = Br(o); const i = this.injector.get(n, uu, o); return i !== uu || t === uu ? i : this.parentInjector.get(n, t, o) } } class $i extends ap { get inputs() { return $p(this.componentDef.inputs) } get outputs() { return $p(this.componentDef.outputs) } constructor(n, t) { super(), this.componentDef = n, this.ngModule = t, this.componentType = n.type, this.selector = function Pb(e) { return e.map(Nb).join(",") }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!t } create(n, t, o, i) { let r = (i = i || this.ngModule) instanceof Xn ? i : i?.injector; r && null !== this.componentDef.getStandaloneInjector && (r = this.componentDef.getStandaloneInjector(r) || r); const s = r ? new ME(n, r) : n, a = s.get(up, null); if (null === a) throw new O(407, !1); const l = s.get(pb, null), u = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = o ? function rE(e, n, t) { return e.selectRootElement(n, t === Xt.ShadowDom) }(u, o, this.componentDef.encapsulation) : Ul(u, c, function xE(e) { const n = e.toLowerCase(); return "svg" === n ? Ef : "math" === n ? "math" : null }(c)), p = this.componentDef.onPush ? 288 : 272, g = wu(0, null, null, 1, 0, null, null, null, null, null), C = Cs(null, g, null, p, null, null, a, u, l, s, null); let w, D; gl(C); try { const I = this.componentDef; let F, E = null; I.findHostDirectiveDefs ? (F = [], E = new Map, I.findHostDirectiveDefs(I, F, E), F.push(I)) : F = [I]; const L = function OE(e, n) { const t = e[P], o = we; return e[o] = n, Bo(t, o, 2, "#host", null) }(C, d), te = function NE(e, n, t, o, i, r, s, a) { const l = i[P]; !function PE(e, n, t, o) { for (const i of e) n.mergedAttrs = xi(n.mergedAttrs, i.hostAttrs); null !== n.mergedAttrs && (Is(n, n.mergedAttrs, !0), null !== t && Vh(o, t, n)) }(o, e, n, s); const u = r.createRenderer(n, t), c = Cs(i, Fp(t), null, t.onPush ? 32 : 16, i[e.index], e, r, u, a || null, null, null); return l.firstCreatePass && bu(l, e, o.length - 1), Ds(i, c), i[e.index] = c }(L, d, I, F, C, a, u); D = Tf(g, we), d && function LE(e, n, t, o) { if (o) vl(e, t, ["ng-version", gb.full]); else { const { attrs: i, classes: r } = function kb(e) { const n = [], t = []; let o = 1, i = 2; for (; o < e.length;) { let r = e[o]; if ("string" == typeof r) 2 === i ? "" !== r && n.push(r, e[++o]) : 8 === i && t.push(r); else { if (!Ut(i)) break; i = r } o++ } return { attrs: n, classes: t } }(n.selectors[0]); i && vl(e, t, i), r && r.length > 0 && Rh(e, t, r.join(" ")) } }(u, I, d, o), void 0 !== t && function RE(e, n, t) { const o = e.projection = []; for (let i = 0; i < n.length; i++) { const r = t[i]; o.push(null != r ? Array.from(r) : null) } }(D, this.ngContentSelectors, t), w = function kE(e, n, t, o, i, r) { const s = We(), a = i[P], l = bt(s, i); kp(a, i, s, t, null, o); for (let c = 0; c < t.length; c++)tt(Wn(i, a, s.directiveStart + c, s), i); Lp(a, i, s), l && tt(l, i); const u = Wn(i, a, s.directiveStart + s.componentOffset, s); if (e[Oe] = i[Oe] = u, null !== r) for (const c of r) c(u, n); return yu(a, s, e), u }(te, I, F, E, C, [VE]), _u(g, C, null) } finally { ml() } return new FE(this.componentType, w, ko(D, C), C, D) } } class FE extends lb { constructor(n, t, o, i, r) { super(), this.location = o, this._rootLView = i, this._tNode = r, this.instance = t, this.hostView = this.changeDetectorRef = new SE(i), this.componentType = n } setInput(n, t) { const o = this._tNode.inputs; let i; if (null !== o && (i = o[n])) { const r = this._rootLView; Au(r[P], r, i, n, t), bs(pt(this._tNode.index, r)) } } get injector() { return new Eo(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(n) { this.hostView.onDestroy(n) } } function VE() { const e = We(); Yr(T()[P], e) } function oe(e) { let n = function qp(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), t = !0; const o = [e]; for (; n;) { let i; if (Ht(e)) i = n.\u0275cmp || n.\u0275dir; else { if (n.\u0275cmp) throw new O(903, !1); i = n.\u0275dir } if (i) { if (t) { o.push(i); const s = e; s.inputs = Su(e.inputs), s.declaredInputs = Su(e.declaredInputs), s.outputs = Su(e.outputs); const a = i.hostBindings; a && UE(e, a); const l = i.viewQuery, u = i.contentQueries; if (l && jE(e, l), u && HE(e, u), Ka(e.inputs, i.inputs), Ka(e.declaredInputs, i.declaredInputs), Ka(e.outputs, i.outputs), Ht(i) && i.data.animation) { const c = e.data; c.animation = (c.animation || []).concat(i.data.animation) } } const r = i.features; if (r) for (let s = 0; s < r.length; s++) { const a = r[s]; a && a.ngInherit && a(e), a === oe && (t = !1) } } n = Object.getPrototypeOf(n) } !function BE(e) { let n = 0, t = null; for (let o = e.length - 1; o >= 0; o--) { const i = e[o]; i.hostVars = n += i.hostVars, i.hostAttrs = xi(i.hostAttrs, t = xi(t, i.hostAttrs)) } }(o) } function Su(e) { return e === hn ? {} : e === ae ? [] : e } function jE(e, n) { const t = e.viewQuery; e.viewQuery = t ? (o, i) => { n(o, i), t(o, i) } : n } function HE(e, n) { const t = e.contentQueries; e.contentQueries = t ? (o, i, r) => { n(o, i, r), t(o, i, r) } : n } function UE(e, n) { const t = e.hostBindings; e.hostBindings = t ? (o, i) => { n(o, i), t(o, i) } : n } function As(e) { return !!xu(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function xu(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function sn(e, n, t) { return e[n] = t } function nt(e, n, t) { return !Object.is(e[n], t) && (e[n] = t, !0) } function to(e, n, t, o) { const i = nt(e, n, t); return nt(e, n + 1, o) || i } function De(e, n, t, o) { const i = T(); return nt(i, Do(), n) && (ie(), rn(Ae(), i, e, n, t, o)), De } function Ho(e, n, t, o) { return nt(e, Do(), t) ? n + z(t) + o : Y } function Uo(e, n, t, o, i, r) { const a = to(e, function mn() { return K.lFrame.bindingIndex }(), t, i); return _n(2), a ? n + z(t) + o + z(i) + r : Y } function v(e, n, t, o, i, r, s, a) { const l = T(), u = ie(), c = e + we, d = u.firstCreatePass ? function ZE(e, n, t, o, i, r, s, a, l) { const u = n.consts, c = Bo(n, e, 4, s || null, On(u, a)); Du(n, t, c, On(u, l)), Yr(n, c); const d = c.tView = wu(2, c, o, i, r, n.directiveRegistry, n.pipeRegistry, null, n.schemas, u); return null !== n.queries && (n.queries.template(n, c), d.queries = n.queries.embeddedTView(c)), c }(c, u, l, n, t, o, i, r, s) : u.data[c]; tn(d, !1); const p = l[ee].createComment(""); ds(u, l, p, d), tt(p, l), Ds(l, l[c] = Rp(p, l, p, d)), Qr(d) && vu(u, l, d), null != s && Cu(l, d, a) } function kt(e) { return wo(function Xw() { return K.lFrame.contextLView }(), we + e) } function h(e, n, t) { const o = T(); return nt(o, Do(), n) && Tt(ie(), Ae(), o, e, n, o[ee], t, !1), h } function Mu(e, n, t, o, i) { const s = i ? "class" : "style"; Au(e, t, n.inputs[s], s, o) } function y(e, n, t, o) { const i = T(), r = ie(), s = we + e, a = i[ee], l = r.firstCreatePass ? function eI(e, n, t, o, i, r) { const s = n.consts, l = Bo(n, e, 2, o, On(s, i)); return Du(n, t, l, On(s, r)), null !== l.attrs && Is(l, l.attrs, !1), null !== l.mergedAttrs && Is(l, l.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, l), l }(s, r, i, n, t, o) : r.data[s], u = i[s] = Ul(a, n, function uD() { return K.lFrame.currentNamespace }()), c = Qr(l); return tn(l, !0), Vh(a, u, l), 32 != (32 & l.flags) && ds(r, i, u, l), 0 === function Ww() { return K.lFrame.elementDepthCount }() && tt(u, i), function Kw() { K.lFrame.elementDepthCount++ }(), c && (vu(r, i, l), yu(r, l, i)), null !== o && Cu(i, l), y } function _() { let e = We(); cl() ? dl() : (e = e.parent, tn(e, !1)); const n = e; !function Yw() { K.lFrame.elementDepthCount-- }(); const t = ie(); return t.firstCreatePass && (Yr(t, e), al(e) && t.queries.elementEnd(e)), null != n.classesWithoutHost && function hD(e) { return 0 != (8 & e.flags) }(n) && Mu(t, n, T(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function pD(e) { return 0 != (16 & e.flags) }(n) && Mu(t, n, T(), n.stylesWithoutHost, !1), _ } function k(e, n, t, o) { return y(e, n, t, o), _(), k } function Ee(e, n, t) { const o = T(), i = ie(), r = e + we, s = i.firstCreatePass ? function tI(e, n, t, o, i) { const r = n.consts, s = On(r, o), a = Bo(n, e, 8, "ng-container", s); return null !== s && Is(a, s, !0), Du(n, t, a, On(r, i)), null !== n.queries && n.queries.elementStart(n, a), a }(r, i, o, n, t) : i.data[r]; tn(s, !0); const a = o[r] = o[ee].createComment(""); return ds(i, o, a, s), tt(a, o), Qr(s) && (vu(i, o, s), yu(i, s, o)), null != t && Cu(o, s), Ee } function Ie() { let e = We(); const n = ie(); return cl() ? dl() : (e = e.parent, tn(e, !1)), n.firstCreatePass && (Yr(n, e), al(e) && n.queries.elementEnd(e)), Ie } function no(e, n, t) { return Ee(e, n, t), Ie(), no } function R() { return T() } function xs(e) { return !!e && "function" == typeof e.then } function og(e) { return !!e && "function" == typeof e.subscribe } const ig = og; function M(e, n, t, o) { const i = T(), r = ie(), s = We(); return function sg(e, n, t, o, i, r, s) { const a = Qr(o), u = e.firstCreatePass && Bp(e), c = n[Oe], d = Vp(n); let p = !0; if (3 & o.type || s) { const w = bt(o, n), D = s ? s(w) : w, I = d.length, F = s ? L => s(ze(L[o.index])) : o.index; let E = null; if (!s && a && (E = function nI(e, n, t, o) { const i = e.cleanup; if (null != i) for (let r = 0; r < i.length - 1; r += 2) { const s = i[r]; if (s === t && i[r + 1] === o) { const a = n[_o], l = i[r + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (r += 2) } return null }(e, n, i, o.index)), null !== E) (E.__ngLastListenerFn__ || E).__ngNextListenerFn__ = r, E.__ngLastListenerFn__ = r, p = !1; else { r = lg(o, n, c, r, !1); const L = t.listen(D, i, r); d.push(r, L), u && u.push(i, F, I, I + 1) } } else r = lg(o, n, c, r, !1); const g = o.outputs; let C; if (p && null !== g && (C = g[i])) { const w = C.length; if (w) for (let D = 0; D < w; D += 2) { const te = n[C[D]][C[D + 1]].subscribe(r), pe = d.length; d.push(r, te), u && u.push(i, o.index, pe, -(pe + 1)) } } }(r, i, i[ee], s, e, n, o), M } function ag(e, n, t, o) { try { return Ft(6, n, t), !1 !== t(o) } catch (i) { return Hp(e, i), !1 } finally { Ft(7, n, t) } } function lg(e, n, t, o, i) { return function r(s) { if (s === Function) return o; bs(e.componentOffset > -1 ? pt(e.index, n) : n); let l = ag(n, t, o, s), u = r.__ngNextListenerFn__; for (; u;)l = ag(n, t, u, s) && l, u = u.__ngNextListenerFn__; return i && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function m(e = 1) { return function iD(e) { return (K.lFrame.contextLView = function rD(e, n) { for (; e > 0;)n = n[yo], e--; return n }(e, K.lFrame.contextLView))[Oe] }(e) } function qe(e, n, t) { return Ms(e, "", n, "", t), qe } function Ms(e, n, t, o, i) { const r = T(), s = Ho(r, n, t, o); return s !== Y && Tt(ie(), Ae(), r, e, s, r[ee], i, !1), Ms } function Fs(e, n) { return e << 17 | n << 2 } function Nn(e) { return e >> 17 & 32767 } function Fu(e) { return 2 | e } function oo(e) { return (131068 & e) >> 2 } function Ou(e, n) { return -131069 & e | n << 2 } function Nu(e) { return 1 | e } function _g(e, n, t, o, i) { const r = e[t + 1], s = null === n; let a = o ? Nn(r) : oo(r), l = !1; for (; 0 !== a && (!1 === l || s);) { const c = e[a + 1]; dI(e[a], n) && (l = !0, e[a + 1] = o ? Nu(c) : Fu(c)), a = o ? Nn(c) : oo(c) } l && (e[t + 1] = o ? Fu(r) : Nu(r)) } function dI(e, n) { return null === e || null == n || (Array.isArray(e) ? e[1] : e) === n || !(!Array.isArray(e) || "string" != typeof n) && xo(e, n) >= 0 } const je = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function yg(e) { return e.substring(je.key, je.keyEnd) } function vg(e, n) { const t = je.textEnd; return t === n ? -1 : (n = je.keyEnd = function gI(e, n, t) { for (; n < t && e.charCodeAt(n) > 32;)n++; return n }(e, je.key = n, t), Ko(e, n, t)) } function Ko(e, n, t) { for (; n < t && e.charCodeAt(n) <= 32;)n++; return n } function Os(e, n) { return function $t(e, n, t, o) { const i = T(), r = ie(), s = _n(2); r.firstUpdatePass && Tg(r, e, s, o), n !== Y && nt(i, s, n) && Sg(r, r.data[at()], i, i[ee], e, i[s + 1] = function TI(e, n) { return null == e || "" === e || ("string" == typeof n ? e += n : "object" == typeof e && (e = ge(It(e)))), e }(n, t), o, s) }(e, n, null, !0), Os } function Pu(e) { !function qt(e, n, t, o) { const i = ie(), r = _n(2); i.firstUpdatePass && Tg(i, null, r, o); const s = T(); if (t !== Y && nt(s, r, t)) { const a = i.data[at()]; if (Mg(a, o) && !Ig(i, r)) { let l = o ? a.classesWithoutHost : a.stylesWithoutHost; null !== l && (t = Ya(l, t || "")), Mu(i, a, s, t, o) } else !function II(e, n, t, o, i, r, s, a) { i === Y && (i = ae); let l = 0, u = 0, c = 0 < i.length ? i[0] : null, d = 0 < r.length ? r[0] : null; for (; null !== c || null !== d;) { const p = l < i.length ? i[l + 1] : void 0, g = u < r.length ? r[u + 1] : void 0; let w, C = null; c === d ? (l += 2, u += 2, p !== g && (C = d, w = g)) : null === d || null !== c && c < d ? (l += 2, C = c) : (u += 2, C = d, w = g), null !== C && Sg(e, n, t, o, C, w, s, a), c = l < i.length ? i[l] : null, d = u < r.length ? r[u] : null } }(i, a, s, s[ee], s[r + 1], s[r + 1] = function bI(e, n, t) { if (null == t || "" === t) return ae; const o = [], i = It(t); if (Array.isArray(i)) for (let r = 0; r < i.length; r++)e(o, i[r], !0); else if ("object" == typeof i) for (const r in i) i.hasOwnProperty(r) && e(o, r, i[r]); else "string" == typeof i && n(o, i); return o }(e, n, t), o, r) } }(EI, ln, e, !0) } function ln(e, n) { for (let t = function hI(e) { return function wg(e) { je.key = 0, je.keyEnd = 0, je.value = 0, je.valueEnd = 0, je.textEnd = e.length }(e), vg(e, Ko(e, 0, je.textEnd)) }(n); t >= 0; t = vg(n, t))Et(e, yg(n), !0) } function Ig(e, n) { return n >= e.expandoStartIndex } function Tg(e, n, t, o) { const i = e.data; if (null === i[t + 1]) { const r = i[at()], s = Ig(e, t); Mg(r, o) && null === n && !s && (n = !1), n = function vI(e, n, t, o) { const i = function hl(e) { const n = K.lFrame.currentDirectiveIndex; return -1 === n ? null : e[n] }(e); let r = o ? n.residualClasses : n.residualStyles; if (null === i) 0 === (o ? n.classBindings : n.styleBindings) && (t = Gi(t = ku(null, e, n, t, o), n.attrs, o), r = null); else { const s = n.directiveStylingLast; if (-1 === s || e[s] !== i) if (t = ku(i, e, n, t, o), null === r) { let l = function CI(e, n, t) { const o = t ? n.classBindings : n.styleBindings; if (0 !== oo(o)) return e[Nn(o)] }(e, n, o); void 0 !== l && Array.isArray(l) && (l = ku(null, e, n, l[1], o), l = Gi(l, n.attrs, o), function wI(e, n, t, o) { e[Nn(t ? n.classBindings : n.styleBindings)] = o }(e, n, o, l)) } else r = function DI(e, n, t) { let o; const i = n.directiveEnd; for (let r = 1 + n.directiveStylingLast; r < i; r++)o = Gi(o, e[r].hostAttrs, t); return Gi(o, n.attrs, t) }(e, n, o) } return void 0 !== r && (o ? n.residualClasses = r : n.residualStyles = r), t }(i, r, n, o), function uI(e, n, t, o, i, r) { let s = r ? n.classBindings : n.styleBindings, a = Nn(s), l = oo(s); e[o] = t; let c, u = !1; if (Array.isArray(t) ? (c = t[1], (null === c || xo(t, c) > 0) && (u = !0)) : c = t, i) if (0 !== l) { const p = Nn(e[a + 1]); e[o + 1] = Fs(p, a), 0 !== p && (e[p + 1] = Ou(e[p + 1], o)), e[a + 1] = function aI(e, n) { return 131071 & e | n << 17 }(e[a + 1], o) } else e[o + 1] = Fs(a, 0), 0 !== a && (e[a + 1] = Ou(e[a + 1], o)), a = o; else e[o + 1] = Fs(l, 0), 0 === a ? a = o : e[l + 1] = Ou(e[l + 1], o), l = o; u && (e[o + 1] = Fu(e[o + 1])), _g(e, c, o, !0), _g(e, c, o, !1), function cI(e, n, t, o, i) { const r = i ? e.residualClasses : e.residualStyles; null != r && "string" == typeof n && xo(r, n) >= 0 && (t[o + 1] = Nu(t[o + 1])) }(n, c, e, o, r), s = Fs(a, l), r ? n.classBindings = s : n.styleBindings = s }(i, r, n, t, s, o) } } function ku(e, n, t, o, i) { let r = null; const s = t.directiveEnd; let a = t.directiveStylingLast; for (-1 === a ? a = t.directiveStart : a++; a < s && (r = n[a], o = Gi(o, r.hostAttrs, i), r !== e);)a++; return null !== e && (t.directiveStylingLast = a), o } function Gi(e, n, t) { const o = t ? 1 : 2; let i = -1; if (null !== n) for (let r = 0; r < n.length; r++) { const s = n[r]; "number" == typeof s ? i = s : i === o && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), Et(e, s, !!t || n[++r])) } return void 0 === e ? null : e } function EI(e, n, t) { const o = String(n); "" !== o && !o.includes(" ") && Et(e, o, t) } function Sg(e, n, t, o, i, r, s, a) { if (!(3 & n.type)) return; const l = e.data, u = l[a + 1], c = function lI(e) { return 1 == (1 & e) }(u) ? xg(l, n, t, i, oo(u), s) : void 0; Ns(c) || (Ns(r) || function sI(e) { return 2 == (2 & e) }(u) && (r = xg(l, null, t, i, a, s)), function C1(e, n, t, o, i) { if (n) i ? e.addClass(t, o) : e.removeClass(t, o); else { let r = -1 === o.indexOf("-") ? void 0 : gt.DashCase; null == i ? e.removeStyle(t, o, r) : ("string" == typeof i && i.endsWith("!important") && (i = i.slice(0, -10), r |= gt.Important), e.setStyle(t, o, i, r)) } }(o, s, zr(at(), t), i, r)) } function xg(e, n, t, o, i, r) { const s = null === n; let a; for (; i > 0;) { const l = e[i], u = Array.isArray(l), c = u ? l[1] : l, d = null === c; let p = t[i + 1]; p === Y && (p = d ? ae : void 0); let g = d ? Sl(p, o) : c === o ? p : void 0; if (u && !Ns(g) && (g = Sl(l, o)), Ns(g) && (a = g, s)) return a; const C = e[i + 1]; i = s ? Nn(C) : oo(C) } if (null !== n) { let l = r ? n.residualClasses : n.residualStyles; null != l && (a = Sl(l, o)) } return a } function Ns(e) { return void 0 !== e } function Mg(e, n) { return 0 != (e.flags & (n ? 8 : 16)) } function A(e, n = "") { const t = T(), o = ie(), i = e + we, r = o.firstCreatePass ? Bo(o, i, 1, n, null) : o.data[i], s = t[i] = function Hl(e, n) { return e.createText(n) }(t[ee], n); ds(o, t, s, r), tn(r, !1) } function j(e) { return _t("", e, ""), j } function _t(e, n, t) { const o = T(), i = Ho(o, e, n, t); return i !== Y && wn(o, at(), i), _t } function Ps(e, n, t, o, i) { const r = T(), s = Uo(r, e, n, t, o, i); return s !== Y && wn(r, at(), s), Ps } const Jo = "en-US"; let Jg = Jo; function Vu(e, n, t, o, i) { if (e = U(e), Array.isArray(e)) for (let r = 0; r < e.length; r++)Vu(e[r], n, t, o, i); else { const r = ie(), s = T(); let a = Zn(e) ? e : U(e.provide), l = sp(e); const u = We(), c = 1048575 & u.providerIndexes, d = u.directiveStart, p = u.providerIndexes >> 20; if (Zn(e) || !e.multi) { const g = new Si(l, i, b), C = ju(a, n, i ? c : c + p, d); -1 === C ? (bl(ns(u, s), r, a), Bu(r, e, n.length), n.push(a), u.directiveStart++, u.directiveEnd++, i && (u.providerIndexes += 1048576), t.push(g), s.push(g)) : (t[C] = g, s[C] = g) } else { const g = ju(a, n, c + p, d), C = ju(a, n, c, c + p), D = C >= 0 && t[C]; if (i && !D || !i && !(g >= 0 && t[g])) { bl(ns(u, s), r, a); const I = function G0(e, n, t, o, i) { const r = new Si(e, t, b); return r.multi = [], r.index = n, r.componentProviders = 0, Dm(r, i, o && !t), r }(i ? q0 : $0, t.length, i, o, l); !i && D && (t[C].providerFactory = I), Bu(r, e, n.length, 0), n.push(a), u.directiveStart++, u.directiveEnd++, i && (u.providerIndexes += 1048576), t.push(I), s.push(I) } else Bu(r, e, g > -1 ? g : C, Dm(t[i ? C : g], l, !i && o)); !i && o && D && t[C].componentProviders++ } } } function Bu(e, n, t, o) { const i = Zn(n), r = function tb(e) { return !!e.useClass }(n); if (i || r) { const l = (r ? U(n.useClass) : n).prototype.ngOnDestroy; if (l) { const u = e.destroyHooks || (e.destroyHooks = []); if (!i && n.multi) { const c = u.indexOf(t); -1 === c ? u.push(t, [o, l]) : u[c + 1].push(o, l) } else u.push(t, l) } } } function Dm(e, n, t) { return t && e.componentProviders++, e.multi.push(n) - 1 } function ju(e, n, t, o) { for (let i = t; i < o; i++)if (n[i] === e) return i; return -1 } function $0(e, n, t, o) { return Hu(this.multi, []) } function q0(e, n, t, o) { const i = this.multi; let r; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Wn(t, t[P], this.providerFactory.index, o); r = a.slice(0, s), Hu(i, r); for (let l = s; l < a.length; l++)r.push(a[l]) } else r = [], Hu(i, r); return r } function Hu(e, n) { for (let t = 0; t < e.length; t++)n.push((0, e[t])()); return n } function de(e, n = []) { return t => { t.providersResolver = (o, i) => function U0(e, n, t) { const o = ie(); if (o.firstCreatePass) { const i = Ht(e); Vu(t, o.data, o.blueprint, i, !0), Vu(n, o.data, o.blueprint, i, !1) } }(o, i ? i(e) : e, n) } } class Zo { } class Q0 { } class bm extends Zo { constructor(n, t) { super(), this._parent = t, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Up(this); const o = function wt(e, n) { const t = e[df] || null; if (!t && !0 === n) throw new Error(`Type ${ge(e)} does not have '\u0275mod' property.`); return t }(n); this._bootstrapComponents = function Cn(e) { return e instanceof Function ? e() : e }(o.bootstrap), this._r3Injector = Dp(n, t, [{ provide: Zo, useValue: this }, { provide: Po, useValue: this.componentFactoryResolver }], ge(n), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(n) } get injector() { return this._r3Injector } destroy() { const n = this._r3Injector; !n.destroyed && n.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(n) { this.destroyCbs.push(n) } } class Uu extends Q0 { constructor(n) { super(), this.moduleType = n } create(n) { return new bm(this.moduleType, n) } } function Se(e, n, t, o) { return Om(T(), st(), e, n, t, o) } function Bs(e, n, t, o, i) { return function Nm(e, n, t, o, i, r, s) { const a = n + t; return to(e, a, i, r) ? sn(e, a + 2, s ? o.call(s, i, r) : o(i, r)) : Ji(e, a + 2) }(T(), st(), e, n, t, o, i) } function Ji(e, n) { const t = e[n]; return t === Y ? void 0 : t } function Om(e, n, t, o, i, r) { const s = n + t; return nt(e, s, i) ? sn(e, s + 1, r ? o.call(r, i) : o(i)) : Ji(e, s + 1) } function Zi(e, n) { const t = ie(); let o; const i = e + we; t.firstCreatePass ? (o = function fT(e, n) { if (n) for (let t = n.length - 1; t >= 0; t--) { const o = n[t]; if (e === o.name) return o } }(n, t.pipeRegistry), t.data[i] = o, o.onDestroy && (t.destroyHooks ?? (t.destroyHooks = [])).push(i, o.onDestroy)) : o = t.data[i]; const r = o.factory || (o.factory = Qn(o.type)), s = Mt(b); try { const a = ts(!1), l = r(); return ts(a), function XE(e, n, t, o) { t >= e.data.length && (e.data[t] = null, e.blueprint[t] = null), n[t] = o }(t, T(), i, l), l } finally { Mt(s) } } function Xi(e, n, t) { const o = e + we, i = T(), r = wo(i, o); return function er(e, n) { return e[P].data[n].pure }(i, o) ? Om(i, st(), n, r.transform, t, r) : r.transform(t) } function qu(e) { return n => { setTimeout(e, void 0, n) } } const Q = class _T extends qn { constructor(n = !1) { super(), this.__isAsync = n } emit(n) { super.next(n) } subscribe(n, t, o) { let i = n, r = t || (() => null), s = o; if (n && "object" == typeof n) { const l = n; i = l.next?.bind(l), r = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (r = qu(r), i && (i = qu(i)), s && (s = qu(s))); const a = super.subscribe({ next: i, error: r, complete: s }); return n instanceof Yt && n.add(a), a } }; function yT() { return this._results[Symbol.iterator]() } class Gu { get changes() { return this._changes || (this._changes = new Q) } constructor(n = !1) { this._emitDistinctChangesOnly = n, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const t = Gu.prototype; t[Symbol.iterator] || (t[Symbol.iterator] = yT) } get(n) { return this._results[n] } map(n) { return this._results.map(n) } filter(n) { return this._results.filter(n) } find(n) { return this._results.find(n) } reduce(n, t) { return this._results.reduce(n, t) } forEach(n) { this._results.forEach(n) } some(n) { return this._results.some(n) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(n, t) { const o = this; o.dirty = !1; const i = function Ot(e) { return e.flat(Number.POSITIVE_INFINITY) }(n); (this._changesDetected = !function ED(e, n, t) { if (e.length !== n.length) return !1; for (let o = 0; o < e.length; o++) { let i = e[o], r = n[o]; if (t && (i = t(i), r = t(r)), r !== i) return !1 } return !0 }(o._results, i, t)) && (o._results = i, o.length = i.length, o.last = i[this.length - 1], o.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Dn = (() => { class e { } return e.__NG_ELEMENT_ID__ = wT, e })(); const vT = Dn, CT = class extends vT { constructor(n, t, o) { super(), this._declarationLView = n, this._declarationTContainer = t, this.elementRef = o } createEmbeddedView(n, t) { const o = this._declarationTContainer.tView, i = Cs(this._declarationLView, o, n, 16, null, o.declTNode, null, null, null, null, t || null); i[Ei] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[en]; return null !== s && (i[en] = s.createEmbeddedView(o)), _u(o, i, n), new Ui(i) } }; function wT() { return js(We(), T()) } function js(e, n) { return 4 & e.type ? new CT(n, e, ko(e, n)) : null } let un = (() => { class e { } return e.__NG_ELEMENT_ID__ = DT, e })(); function DT() { return Bm(We(), T()) } const bT = un, Rm = class extends bT { constructor(n, t, o) { super(), this._lContainer = n, this._hostTNode = t, this._hostLView = o } get element() { return ko(this._hostTNode, this._hostLView) } get injector() { return new Eo(this._hostTNode, this._hostLView) } get parentInjector() { const n = Dl(this._hostTNode, this._hostLView); if (qf(n)) { const t = es(n, this._hostLView), o = Xr(n); return new Eo(t[P].data[o + 8], t) } return new Eo(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(n) { const t = Vm(this._lContainer); return null !== t && t[n] || null } get length() { return this._lContainer.length - rt } createEmbeddedView(n, t, o) { let i, r; "number" == typeof o ? i = o : null != o && (i = o.index, r = o.injector); const s = n.createEmbeddedView(t || {}, r); return this.insert(s, i), s } createComponent(n, t, o, i, r) { const s = n && !function Fi(e) { return "function" == typeof e }(n); let a; if (s) a = t; else { const d = t || {}; a = d.index, o = d.injector, i = d.projectableNodes, r = d.environmentInjector || d.ngModuleRef } const l = s ? n : new $i(ce(n)), u = o || this.parentInjector; if (!r && null == l.ngModule) { const p = (s ? u : this.parentInjector).get(Xn, null); p && (r = p) } const c = l.create(u, i, void 0, r); return this.insert(c.hostView, a), c } insert(n, t) { const o = n._lView, i = o[P]; if (function zw(e) { return jt(e[Me]) }(o)) { const c = this.indexOf(n); if (-1 !== c) this.detach(c); else { const d = o[Me], p = new Rm(d, d[Xe], d[Me]); p.detach(p.indexOf(n)) } } const r = this._adjustIndex(t), s = this._lContainer; !function f1(e, n, t, o) { const i = rt + o, r = t.length; o > 0 && (t[i - 1][Bt] = n), o < r - rt ? (n[Bt] = t[i], nh(t, rt + o, n)) : (t.push(n), n[Bt] = null), n[Me] = t; const s = n[Ei]; null !== s && t !== s && function h1(e, n) { const t = e[Co]; n[et] !== n[Me][Me][et] && (e[_f] = !0), null === t ? e[Co] = [n] : t.push(n) }(s, n); const a = n[en]; null !== a && a.insertView(e), n[Z] |= 64 }(i, o, s, r); const a = Ql(r, s), l = o[ee], u = cs(l, s[qr]); return null !== u && function u1(e, n, t, o, i, r) { o[gn] = i, o[Xe] = n, Ri(e, o, t, 1, i, r) }(i, s[Xe], l, o, u, a), n.attachToViewContainerRef(), nh(Qu(s), r, n), n } move(n, t) { return this.insert(n, t) } indexOf(n) { const t = Vm(this._lContainer); return null !== t ? t.indexOf(n) : -1 } remove(n) { const t = this._adjustIndex(n, -1), o = $l(this._lContainer, t); o && (is(Qu(this._lContainer), t), Th(o[P], o)) } detach(n) { const t = this._adjustIndex(n, -1), o = $l(this._lContainer, t); return o && null != is(Qu(this._lContainer), t) ? new Ui(o) : null } _adjustIndex(n, t = 0) { return n ?? this.length + t } }; function Vm(e) { return e[Gr] } function Qu(e) { return e[Gr] || (e[Gr] = []) } function Bm(e, n) { let t; const o = n[e.index]; if (jt(o)) t = o; else { let i; if (8 & e.type) i = ze(o); else { const r = n[ee]; i = r.createComment(""); const s = bt(e, n); Yn(r, cs(r, s), i, function _1(e, n) { return e.nextSibling(n) }(r, s), !1) } n[e.index] = t = Rp(o, n, i, e), Ds(n, t) } return new Rm(t, e, n) } class zu { constructor(n) { this.queryList = n, this.matches = null } clone() { return new zu(this.queryList) } setDirty() { this.queryList.setDirty() } } class Wu { constructor(n = []) { this.queries = n } createEmbeddedView(n) { const t = n.queries; if (null !== t) { const o = null !== n.contentQueries ? n.contentQueries[0] : t.length, i = []; for (let r = 0; r < o; r++) { const s = t.getByIndex(r); i.push(this.queries[s.indexInDeclarationView].clone()) } return new Wu(i) } return null } insertView(n) { this.dirtyQueriesWithMatches(n) } detachView(n) { this.dirtyQueriesWithMatches(n) } dirtyQueriesWithMatches(n) { for (let t = 0; t < this.queries.length; t++)null !== qm(n, t).matches && this.queries[t].setDirty() } } class jm { constructor(n, t, o = null) { this.predicate = n, this.flags = t, this.read = o } } class Ku { constructor(n = []) { this.queries = n } elementStart(n, t) { for (let o = 0; o < this.queries.length; o++)this.queries[o].elementStart(n, t) } elementEnd(n) { for (let t = 0; t < this.queries.length; t++)this.queries[t].elementEnd(n) } embeddedTView(n) { let t = null; for (let o = 0; o < this.length; o++) { const i = null !== t ? t.length : 0, r = this.getByIndex(o).embeddedTView(n, i); r && (r.indexInDeclarationView = o, null !== t ? t.push(r) : t = [r]) } return null !== t ? new Ku(t) : null } template(n, t) { for (let o = 0; o < this.queries.length; o++)this.queries[o].template(n, t) } getByIndex(n) { return this.queries[n] } get length() { return this.queries.length } track(n) { this.queries.push(n) } } class Yu { constructor(n, t = -1) { this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = t } elementStart(n, t) { this.isApplyingToNode(t) && this.matchTNode(n, t) } elementEnd(n) { this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1) } template(n, t) { this.elementStart(n, t) } embeddedTView(n, t) { return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, t), new Yu(this.metadata)) : null } isApplyingToNode(n) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const t = this._declarationNodeIndex; let o = n.parent; for (; null !== o && 8 & o.type && o.index !== t;)o = o.parent; return t === (null !== o ? o.index : -1) } return this._appliesToNextNode } matchTNode(n, t) { const o = this.metadata.predicate; if (Array.isArray(o)) for (let i = 0; i < o.length; i++) { const r = o[i]; this.matchTNodeWithReadOption(n, t, ET(t, r)), this.matchTNodeWithReadOption(n, t, os(t, n, r, !1, !1)) } else o === Dn ? 4 & t.type && this.matchTNodeWithReadOption(n, t, -1) : this.matchTNodeWithReadOption(n, t, os(t, n, o, !1, !1)) } matchTNodeWithReadOption(n, t, o) { if (null !== o) { const i = this.metadata.read; if (null !== i) if (i === Nt || i === un || i === Dn && 4 & t.type) this.addMatch(t.index, -2); else { const r = os(t, n, i, !1, !1); null !== r && this.addMatch(t.index, r) } else this.addMatch(t.index, o) } } addMatch(n, t) { null === this.matches ? this.matches = [n, t] : this.matches.push(n, t) } } function ET(e, n) { const t = e.localNames; if (null !== t) for (let o = 0; o < t.length; o += 2)if (t[o] === n) return t[o + 1]; return null } function TT(e, n, t, o) { return -1 === t ? function IT(e, n) { return 11 & e.type ? ko(e, n) : 4 & e.type ? js(e, n) : null }(n, e) : -2 === t ? function AT(e, n, t) { return t === Nt ? ko(n, e) : t === Dn ? js(n, e) : t === un ? Bm(n, e) : void 0 }(e, n, o) : Wn(e, e[P], t, n) } function Hm(e, n, t, o) { const i = n[en].queries[o]; if (null === i.matches) { const r = e.data, s = t.matches, a = []; for (let l = 0; l < s.length; l += 2) { const u = s[l]; a.push(u < 0 ? null : TT(n, r[u], s[l + 1], t.metadata.read)) } i.matches = a } return i.matches } function Ju(e, n, t, o) { const i = e.queries.getByIndex(t), r = i.matches; if (null !== r) { const s = Hm(e, n, i, t); for (let a = 0; a < r.length; a += 2) { const l = r[a]; if (l > 0) o.push(s[a / 2]); else { const u = r[a + 1], c = n[-l]; for (let d = rt; d < c.length; d++) { const p = c[d]; p[Ei] === p[Me] && Ju(p[P], p, u, o) } if (null !== c[Co]) { const d = c[Co]; for (let p = 0; p < d.length; p++) { const g = d[p]; Ju(g[P], g, u, o) } } } } } return o } function ro(e) { const n = T(), t = ie(), o = Pf(); pl(o + 1); const i = qm(t, o); if (e.dirty && function Qw(e) { return 4 == (4 & e[Z]) }(n) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) e.reset([]); else { const r = i.crossesNgTemplate ? Ju(t, n, o, []) : Hm(t, n, i, o); e.reset(r, fb), e.notifyOnChanges() } return !0 } return !1 } function so(e, n, t) { const o = ie(); o.firstCreatePass && (function $m(e, n, t) { null === e.queries && (e.queries = new Ku), e.queries.track(new Yu(n, t)) }(o, new jm(e, n, t), -1), 2 == (2 & n) && (o.staticViewQueries = !0)), function Um(e, n, t) { const o = new Gu(4 == (4 & t)); Op(e, n, o, o.destroy), null === n[en] && (n[en] = new Wu), n[en].queries.push(new zu(o)) }(o, T(), n) } function ao() { return function xT(e, n) { return e[en].queries[n].queryList }(T(), Pf()) } function qm(e, n) { return e.queries.getByIndex(n) } function tr(e, n) { return js(e, n) } function Us(...e) { } const u_ = new B("Application Initializer"); let $s = (() => { class e { constructor(t) { this.appInits = t, this.resolve = Us, this.reject = Us, this.initialized = !1, this.done = !1, this.donePromise = new Promise((o, i) => { this.resolve = o, this.reject = i }) } runInitializers() { if (this.initialized) return; const t = [], o = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const r = this.appInits[i](); if (xs(r)) t.push(r); else if (ig(r)) { const s = new Promise((a, l) => { r.subscribe({ complete: a, error: l }) }); t.push(s) } } Promise.all(t).then(() => { o() }).catch(i => { this.reject(i) }), 0 === t.length && o(), this.initialized = !0 } } return e.\u0275fac = function (t) { return new (t || e)(q(u_, 8)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const or = new B("AppId", { providedIn: "root", factory: function c_() { return `${nc()}${nc()}${nc()}` } }); function nc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const d_ = new B("Platform Initializer"), oc = new B("Platform ID", { providedIn: "platform", factory: () => "unknown" }), bn = new B("LocaleId", { providedIn: "root", factory: () => mo(bn, G.Optional | G.SkipSelf) || function YT() { return typeof $localize < "u" && $localize.locale || Jo }() }), tA = (() => Promise.resolve(0))(); function ic(e) { typeof Zone > "u" ? tA.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Ye { constructor({ enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: t = !1, shouldCoalesceRunChangeDetection: o = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Q(!1), this.onMicrotaskEmpty = new Q(!1), this.onStable = new Q(!1), this.onError = new Q(!1), typeof Zone > "u") throw new O(908, !1); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !o && t, i.shouldCoalesceRunChangeDetection = o, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function nA() { let e = Ce.requestAnimationFrame, n = Ce.cancelAnimationFrame; if (typeof Zone < "u" && e && n) { const t = e[Zone.__symbol__("OriginalDelegate")]; t && (e = t); const o = n[Zone.__symbol__("OriginalDelegate")]; o && (n = o) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: n } }().nativeRequestAnimationFrame, function rA(e) { const n = () => { !function iA(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(Ce, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, sc(e), e.isCheckStableRunning = !0, rc(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), sc(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (t, o, i, r, s, a) => { try { return p_(e), t.invokeTask(i, r, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === r.type || e.shouldCoalesceRunChangeDetection) && n(), g_(e) } }, onInvoke: (t, o, i, r, s, a, l) => { try { return p_(e), t.invoke(i, r, s, a, l) } finally { e.shouldCoalesceRunChangeDetection && n(), g_(e) } }, onHasTask: (t, o, i, r) => { t.hasTask(i, r), o === i && ("microTask" == r.change ? (e._hasPendingMicrotasks = r.microTask, sc(e), rc(e)) : "macroTask" == r.change && (e.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (t, o, i, r) => (t.handleError(i, r), e.runOutsideAngular(() => e.onError.emit(r)), !1) }) }(i) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Ye.isInAngularZone()) throw new O(909, !1) } static assertNotInAngularZone() { if (Ye.isInAngularZone()) throw new O(909, !1) } run(n, t, o) { return this._inner.run(n, t, o) } runTask(n, t, o, i) { const r = this._inner, s = r.scheduleEventTask("NgZoneEvent: " + i, n, oA, Us, Us); try { return r.runTask(s, t, o) } finally { r.cancelTask(s) } } runGuarded(n, t, o) { return this._inner.runGuarded(n, t, o) } runOutsideAngular(n) { return this._outer.run(n) } } const oA = {}; function rc(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function sc(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function p_(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function g_(e) { e._nesting--, rc(e) } class sA { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Q, this.onMicrotaskEmpty = new Q, this.onStable = new Q, this.onError = new Q } run(n, t, o) { return n.apply(t, o) } runGuarded(n, t, o) { return n.apply(t, o) } runOutsideAngular(n) { return n() } runTask(n, t, o, i) { return n.apply(t, o) } } const m_ = new B(""), qs = new B(""); let uc, ac = (() => { class e { constructor(t, o, i) { this._ngZone = t, this.registry = o, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, uc || (function aA(e) { uc = e }(i), i.addToWindow(o)), this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Ye.assertNotInAngularZone(), ic(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) ic(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(o => !o.updateCb || !o.updateCb(t) || (clearTimeout(o.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, o, i) { let r = -1; o && o > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, o)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: i }) } whenStable(t, o, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, o, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(t) { this.registry.registerApplication(t, this) } unregisterApplication(t) { this.registry.unregisterApplication(t) } findProviders(t, o, i) { return [] } } return e.\u0275fac = function (t) { return new (t || e)(q(Ye), q(lc), q(qs)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(), lc = (() => { class e { constructor() { this._applications = new Map } registerApplication(t, o) { this._applications.set(t, o) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, o = !0) { return uc?.findTestabilityInTree(this, t, o) ?? null } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const En = !1; let Pn = null; const __ = new B("AllowMultipleToken"), cc = new B("PlatformDestroyListeners"), lA = new B("appBootstrapListener"); function v_(e, n, t = []) { const o = `Platform: ${n}`, i = new B(o); return (r = []) => { let s = dc(); if (!s || s.injector.get(__, !1)) { const a = [...t, ...r, { provide: i, useValue: !0 }]; e ? e(a) : function dA(e) { if (Pn && !Pn.get(__, !1)) throw new O(400, !1); Pn = e; const n = e.get(w_); (function y_(e) { const n = e.get(d_, null); n && n.forEach(t => t()) })(e) }(function C_(e = [], n) { return $e.create({ name: n, providers: [{ provide: ru, useValue: "platform" }, { provide: cc, useValue: new Set([() => Pn = null]) }, ...e] }) }(a, o)) } return function hA(e) { const n = dc(); if (!n) throw new O(401, !1); return n }() } } function dc() { return Pn?.get(w_) ?? null } let w_ = (() => { class e { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, o) { const i = function b_(e, n) { let t; return t = "noop" === e ? new sA : ("zone.js" === e ? void 0 : e) || new Ye(n), t }(o?.ngZone, function D_(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(o)), r = [{ provide: Ye, useValue: i }]; return i.run(() => { const s = $e.create({ providers: r, parent: this.injector, name: t.moduleType.name }), a = t.create(s), l = a.injector.get(Lo, null); if (!l) throw new O(402, !1); return i.runOutsideAngular(() => { const u = i.onError.subscribe({ next: c => { l.handleError(c) } }); a.onDestroy(() => { Qs(this._modules, a), u.unsubscribe() }) }), function E_(e, n, t) { try { const o = t(); return xs(o) ? o.catch(i => { throw n.runOutsideAngular(() => e.handleError(i)), i }) : o } catch (o) { throw n.runOutsideAngular(() => e.handleError(o)), o } }(l, i, () => { const u = a.injector.get($s); return u.runInitializers(), u.donePromise.then(() => (function Zg(e) { xt(e, "Expected localeId to be defined"), "string" == typeof e && (Jg = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(bn, Jo) || Jo), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(t, o = []) { const i = I_({}, o); return function uA(e, n, t) { const o = new Uu(t); return Promise.resolve(o) }(0, 0, t).then(r => this.bootstrapModuleFactory(r, i)) } _moduleDoBootstrap(t) { const o = t.injector.get(Gs); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(i => o.bootstrap(i)); else { if (!t.instance.ngDoBootstrap) throw new O(-403, !1); t.instance.ngDoBootstrap(o) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new O(404, !1); this._modules.slice().forEach(o => o.destroy()), this._destroyListeners.forEach(o => o()); const t = this._injector.get(cc, null); t && (t.forEach(o => o()), t.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (t) { return new (t || e)(q($e)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function I_(e, n) { return Array.isArray(n) ? n.reduce(I_, e) : { ...e, ...n } } let Gs = (() => { class e { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(t, o, i) { this._zone = t, this._injector = o, this._exceptionHandler = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const r = new Qe(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new Qe(a => { let l; this._zone.runOutsideAngular(() => { l = this._zone.onStable.subscribe(() => { Ye.assertNotInAngularZone(), ic(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const u = this._zone.onUnstable.subscribe(() => { Ye.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { l.unsubscribe(), u.unsubscribe() } }); this.isStable = of(r, s.pipe(Or())) } bootstrap(t, o) { const i = t instanceof ap; if (!this._injector.get($s).done) { !i && function Di(e) { const n = ce(e) || Ze(e) || ht(e); return null !== n && n.standalone }(t); throw new O(405, En) } let s; s = i ? t : this._injector.get(Po).resolveComponentFactory(t), this.componentTypes.push(s.componentType); const a = function cA(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Zo), u = s.create($e.NULL, [], o || s.selector, a), c = u.location.nativeElement, d = u.injector.get(m_, null); return d?.registerApplication(c), u.onDestroy(() => { this.detachView(u.hostView), Qs(this.components, u), d?.unregisterApplication(c) }), this._loadComponent(u), u } tick() { if (this._runningTick) throw new O(101, !1); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const o = t; this._views.push(o), o.attachToAppRef(this) } detachView(t) { const o = t; Qs(this._views, o), o.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t); const o = this._injector.get(lA, []); o.push(...this._bootstrapListeners), o.forEach(i => i(t)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(t => t()), this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(t) { return this._destroyListeners.push(t), () => Qs(this._destroyListeners, t) } destroy() { if (this._destroyed) throw new O(406, !1); const t = this._injector; t.destroy && !t.destroyed && t.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (t) { return new (t || e)(q(Ye), q(Xn), q(Lo)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function Qs(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } let ti = (() => { class e { } return e.__NG_ELEMENT_ID__ = gA, e })(); function gA(e) { return function mA(e, n, t) { if (Ti(e) && !t) { const o = pt(e.index, n); return new Ui(o, o) } return 47 & e.type ? new Ui(n[et], n) : null }(We(), T(), 16 == (16 & e)) } class M_ { constructor() { } supports(n) { return As(n) } create(n) { return new DA(n) } } const wA = (e, n) => n; class DA { constructor(n) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || wA } forEachItem(n) { let t; for (t = this._itHead; null !== t; t = t._next)n(t) } forEachOperation(n) { let t = this._itHead, o = this._removalsHead, i = 0, r = null; for (; t || o;) { const s = !o || t && t.currentIndex < O_(o, i, r) ? t : o, a = O_(s, i, r), l = s.currentIndex; if (s === o) i--, o = o._nextRemoved; else if (t = t._next, null == s.previousIndex) i++; else { r || (r = []); const u = a - i, c = l - i; if (u != c) { for (let p = 0; p < u; p++) { const g = p < r.length ? r[p] : r[p] = 0, C = g + p; c <= C && C < u && (r[p] = g + 1) } r[s.previousIndex] = c - u } } a !== l && n(s, a, l) } } forEachPreviousItem(n) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachMovedItem(n) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } forEachIdentityChange(n) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)n(t) } diff(n) { if (null == n && (n = []), !As(n)) throw new O(900, !1); return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let i, r, s, t = this._itHead, o = !1; if (Array.isArray(n)) { this.length = n.length; for (let a = 0; a < this.length; a++)r = n[a], s = this._trackByFn(a, r), null !== t && Object.is(t.trackById, s) ? (o && (t = this._verifyReinsertion(t, r, s, a)), Object.is(t.item, r) || this._addIdentityChange(t, r)) : (t = this._mismatch(t, r, s, a), o = !0), t = t._next } else i = 0, function KE(e, n) { if (Array.isArray(e)) for (let t = 0; t < e.length; t++)n(e[t]); else { const t = e[Symbol.iterator](); let o; for (; !(o = t.next()).done;)n(o.value) } }(n, a => { s = this._trackByFn(i, a), null !== t && Object.is(t.trackById, s) ? (o && (t = this._verifyReinsertion(t, a, s, i)), Object.is(t.item, a) || this._addIdentityChange(t, a)) : (t = this._mismatch(t, a, s, i), o = !0), t = t._next, i++ }), this.length = i; return this._truncate(t), this.collection = n, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let n; for (n = this._previousItHead = this._itHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._additionsHead; null !== n; n = n._nextAdded)n.previousIndex = n.currentIndex; for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)n.previousIndex = n.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(n, t, o, i) { let r; return null === n ? r = this._itTail : (r = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(o, null)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._reinsertAfter(n, r, i)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(o, i)) ? (Object.is(n.item, t) || this._addIdentityChange(n, t), this._moveAfter(n, r, i)) : n = this._addAfter(new bA(t, o), r, i), n } _verifyReinsertion(n, t, o, i) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(o, null); return null !== r ? n = this._reinsertAfter(r, n._prev, i) : n.currentIndex != i && (n.currentIndex = i, this._addToMoves(n, i)), n } _truncate(n) { for (; null !== n;) { const t = n._next; this._addToRemovals(this._unlink(n)), n = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(n, t, o) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(n); const i = n._prevRemoved, r = n._nextRemoved; return null === i ? this._removalsHead = r : i._nextRemoved = r, null === r ? this._removalsTail = i : r._prevRemoved = i, this._insertAfter(n, t, o), this._addToMoves(n, o), n } _moveAfter(n, t, o) { return this._unlink(n), this._insertAfter(n, t, o), this._addToMoves(n, o), n } _addAfter(n, t, o) { return this._insertAfter(n, t, o), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n } _insertAfter(n, t, o) { const i = null === t ? this._itHead : t._next; return n._next = i, n._prev = t, null === i ? this._itTail = n : i._prev = n, null === t ? this._itHead = n : t._next = n, null === this._linkedRecords && (this._linkedRecords = new F_), this._linkedRecords.put(n), n.currentIndex = o, n } _remove(n) { return this._addToRemovals(this._unlink(n)) } _unlink(n) { null !== this._linkedRecords && this._linkedRecords.remove(n); const t = n._prev, o = n._next; return null === t ? this._itHead = o : t._next = o, null === o ? this._itTail = t : o._prev = t, n } _addToMoves(n, t) { return n.previousIndex === t || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n } _addToRemovals(n) { return null === this._unlinkedRecords && (this._unlinkedRecords = new F_), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n } _addIdentityChange(n, t) { return n.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n } } class bA { constructor(n, t) { this.item = n, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class EA { constructor() { this._head = null, this._tail = null } add(n) { null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n) } get(n, t) { let o; for (o = this._head; null !== o; o = o._nextDup)if ((null === t || t <= o.currentIndex) && Object.is(o.trackById, n)) return o; return null } remove(n) { const t = n._prevDup, o = n._nextDup; return null === t ? this._head = o : t._nextDup = o, null === o ? this._tail = t : o._prevDup = t, null === this._head } } class F_ { constructor() { this.map = new Map } put(n) { const t = n.trackById; let o = this.map.get(t); o || (o = new EA, this.map.set(t, o)), o.add(n) } get(n, t) { const i = this.map.get(n); return i ? i.get(n, t) : null } remove(n) { const t = n.trackById; return this.map.get(t).remove(n) && this.map.delete(t), n } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function O_(e, n, t) { const o = e.previousIndex; if (null === o) return o; let i = 0; return t && o < t.length && (i = t[o]), o + n + i } class N_ { constructor() { } supports(n) { return n instanceof Map || xu(n) } create() { return new IA } } class IA { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(n) { let t; for (t = this._mapHead; null !== t; t = t._next)n(t) } forEachPreviousItem(n) { let t; for (t = this._previousMapHead; null !== t; t = t._nextPrevious)n(t) } forEachChangedItem(n) { let t; for (t = this._changesHead; null !== t; t = t._nextChanged)n(t) } forEachAddedItem(n) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)n(t) } forEachRemovedItem(n) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)n(t) } diff(n) { if (n) { if (!(n instanceof Map || xu(n))) throw new O(900, !1) } else n = new Map; return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let t = this._mapHead; if (this._appendAfter = null, this._forEach(n, (o, i) => { if (t && t.key === i) this._maybeAddToChanges(t, o), this._appendAfter = t, t = t._next; else { const r = this._getOrCreateRecordForKey(i, o); t = this._insertBeforeOrAppend(t, r) } }), t) { t._prev && (t._prev._next = null), this._removalsHead = t; for (let o = t; null !== o; o = o._nextRemoved)o === this._mapHead && (this._mapHead = null), this._records.delete(o.key), o._nextRemoved = o._next, o.previousValue = o.currentValue, o.currentValue = null, o._prev = null, o._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(n, t) { if (n) { const o = n._prev; return t._next = n, t._prev = o, n._prev = t, o && (o._next = t), n === this._mapHead && (this._mapHead = t), this._appendAfter = n, n } return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null } _getOrCreateRecordForKey(n, t) { if (this._records.has(n)) { const i = this._records.get(n); this._maybeAddToChanges(i, t); const r = i._prev, s = i._next; return r && (r._next = s), s && (s._prev = r), i._next = null, i._prev = null, i } const o = new TA(n); return this._records.set(n, o), o.currentValue = t, this._addToAdditions(o), o } _reset() { if (this.isDirty) { let n; for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._changesHead; null !== n; n = n._nextChanged)n.previousValue = n.currentValue; for (n = this._additionsHead; null != n; n = n._nextAdded)n.previousValue = n.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(n, t) { Object.is(t, n.currentValue) || (n.previousValue = n.currentValue, n.currentValue = t, this._addToChanges(n)) } _addToAdditions(n) { null === this._additionsHead ? this._additionsHead = this._additionsTail = n : (this._additionsTail._nextAdded = n, this._additionsTail = n) } _addToChanges(n) { null === this._changesHead ? this._changesHead = this._changesTail = n : (this._changesTail._nextChanged = n, this._changesTail = n) } _forEach(n, t) { n instanceof Map ? n.forEach(t) : Object.keys(n).forEach(o => t(n[o], o)) } } class TA { constructor(n) { this.key = n, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function P_() { return new Ks([new M_]) } let Ks = (() => { class e { constructor(t) { this.factories = t } static create(t, o) { if (null != o) { const i = o.factories.slice(); t = t.concat(i) } return new e(t) } static extend(t) { return { provide: e, useFactory: o => e.create(t, o || P_()), deps: [[e, new as, new ss]] } } find(t) { const o = this.factories.find(i => i.supports(t)); if (null != o) return o; throw new O(901, !1) } } return e.\u0275prov = J({ token: e, providedIn: "root", factory: P_ }), e })(); function k_() { return new ir([new N_]) } let ir = (() => { class e { constructor(t) { this.factories = t } static create(t, o) { if (o) { const i = o.factories.slice(); t = t.concat(i) } return new e(t) } static extend(t) { return { provide: e, useFactory: o => e.create(t, o || k_()), deps: [[e, new as, new ss]] } } find(t) { const o = this.factories.find(i => i.supports(t)); if (o) return o; throw new O(901, !1) } } return e.\u0275prov = J({ token: e, providedIn: "root", factory: k_ }), e })(); const xA = v_(null, "core", []); let MA = (() => { class e { constructor(t) { } } return e.\u0275fac = function (t) { return new (t || e)(q(Gs)) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({}), e })(); let _c = null; function ni() { return _c } class NA { } const Lt = new B("DocumentToken"); function G_(e, n) { n = encodeURIComponent(n); for (const t of e.split(";")) { const o = t.indexOf("="), [i, r] = -1 == o ? [t, ""] : [t.slice(0, o), t.slice(o + 1)]; if (i.trim() === n) return decodeURIComponent(r) } return null } const Ac = /\s+/, Q_ = []; let zt = (() => { class e { constructor(t, o, i, r) { this._iterableDiffers = t, this._keyValueDiffers = o, this._ngEl = i, this._renderer = r, this.initialClasses = Q_, this.stateMap = new Map } set klass(t) { this.initialClasses = null != t ? t.trim().split(Ac) : Q_ } set ngClass(t) { this.rawClass = "string" == typeof t ? t.trim().split(Ac) : t } ngDoCheck() { for (const o of this.initialClasses) this._updateState(o, !0); const t = this.rawClass; if (Array.isArray(t) || t instanceof Set) for (const o of t) this._updateState(o, !0); else if (null != t) for (const o of Object.keys(t)) this._updateState(o, Boolean(t[o])); this._applyStateDiff() } _updateState(t, o) { const i = this.stateMap.get(t); void 0 !== i ? (i.enabled !== o && (i.changed = !0, i.enabled = o), i.touched = !0) : this.stateMap.set(t, { enabled: o, changed: !0, touched: !0 }) } _applyStateDiff() { for (const t of this.stateMap) { const o = t[0], i = t[1]; i.changed ? (this._toggleClass(o, i.enabled), i.changed = !1) : i.touched || (i.enabled && this._toggleClass(o, !1), this.stateMap.delete(o)), i.touched = !1 } } _toggleClass(t, o) { (t = t.trim()).length > 0 && t.split(Ac).forEach(i => { o ? this._renderer.addClass(this._ngEl.nativeElement, i) : this._renderer.removeClass(this._ngEl.nativeElement, i) }) } } return e.\u0275fac = function (t) { return new (t || e)(b(Ks), b(ir), b(Nt), b(eo)) }, e.\u0275dir = W({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), e })(); class vS { constructor(n, t, o, i) { this.$implicit = n, this.ngForOf = t, this.index = o, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let ct = (() => { class e { set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } constructor(t, o, i) { this._viewContainer = t, this._template = o, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const t = this._ngForOf; !this._differ && t && (this._differ = this._differs.find(t).create(this.ngForTrackBy)) } if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const o = this._viewContainer; t.forEachOperation((i, r, s) => { if (null == i.previousIndex) o.createEmbeddedView(this._template, new vS(i.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) o.remove(null === r ? void 0 : r); else if (null !== r) { const a = o.get(r); o.move(a, s), K_(a, i) } }); for (let i = 0, r = o.length; i < r; i++) { const a = o.get(i).context; a.index = i, a.count = r, a.ngForOf = this._ngForOf } t.forEachIdentityChange(i => { K_(o.get(i.currentIndex), i) }) } static ngTemplateContextGuard(t, o) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(b(un), b(Dn), b(Ks)) }, e.\u0275dir = W({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function K_(e, n) { e.context.$implicit = n.item } let Ue = (() => { class e { constructor(t, o) { this._viewContainer = t, this._context = new wS, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = o } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { Y_("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { Y_("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, o) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(b(un), b(Dn)) }, e.\u0275dir = W({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), e })(); class wS { constructor() { this.$implicit = null, this.ngIf = null } } function Y_(e, n) { if (n && !n.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${ge(n)}'.`) } let ar = (() => { class e { constructor(t) { this._viewContainerRef = t, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(t) { if (t.ngTemplateOutlet || t.ngTemplateOutletInjector) { const o = this._viewContainerRef; if (this._viewRef && o.remove(o.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: i, ngTemplateOutletContext: r, ngTemplateOutletInjector: s } = this; this._viewRef = o.createEmbeddedView(i, r, s ? { injector: s } : void 0) } else this._viewRef = null } else this._viewRef && t.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return e.\u0275fac = function (t) { return new (t || e)(b(un)) }, e.\u0275dir = W({ type: e, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [Te] }), e })(); class TS { createSubscription(n, t) { return n.subscribe({ next: t, error: o => { throw o } }) } dispose(n) { n.unsubscribe() } } class AS { createSubscription(n, t) { return n.then(t, o => { throw o }) } dispose(n) { } } const SS = new AS, xS = new TS; let Mc = (() => { class e { constructor(t) { this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null, this._ref = t } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, o => this._updateLatestValue(t, o)) } _selectStrategy(t) { if (xs(t)) return SS; if (og(t)) return xS; throw function Wt(e, n) { return new O(2100, !1) }() } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, o) { t === this._obj && (this._latestValue = o, this._ref.markForCheck()) } } return e.\u0275fac = function (t) { return new (t || e)(b(ti, 16)) }, e.\u0275pipe = ft({ name: "async", type: e, pure: !1, standalone: !0 }), e })(), oi = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({}), e })(); class ty { } class bx extends NA { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class kc extends bx { static makeCurrent() { !function OA(e) { _c || (_c = e) }(new kc) } onAndCancel(n, t, o) { return n.addEventListener(t, o, !1), () => { n.removeEventListener(t, o, !1) } } dispatchEvent(n, t) { n.dispatchEvent(t) } remove(n) { n.parentNode && n.parentNode.removeChild(n) } createElement(n, t) { return (t = t || this.getDefaultDocument()).createElement(n) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(n) { return n.nodeType === Node.ELEMENT_NODE } isShadowRoot(n) { return n instanceof DocumentFragment } getGlobalEventTarget(n, t) { return "window" === t ? window : "document" === t ? n : "body" === t ? n.body : null } getBaseHref(n) { const t = function Ex() { return ur = ur || document.querySelector("base"), ur ? ur.getAttribute("href") : null }(); return null == t ? null : function Ix(e) { aa = aa || document.createElement("a"), aa.setAttribute("href", e); const n = aa.pathname; return "/" === n.charAt(0) ? n : `/${n}` }(t) } resetBaseElement() { ur = null } getUserAgent() { return window.navigator.userAgent } getCookie(n) { return G_(document.cookie, n) } } let aa, ur = null; const sy = new B("TRANSITION_ID"), Ax = [{ provide: u_, useFactory: function Tx(e, n, t) { return () => { t.get($s).donePromise.then(() => { const o = ni(), i = n.querySelectorAll(`style[ng-transition="${e}"]`); for (let r = 0; r < i.length; r++)o.remove(i[r]) }) } }, deps: [sy, Lt, $e], multi: !0 }]; let xx = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const la = new B("EventManagerPlugins"); let ua = (() => { class e { constructor(t, o) { this._zone = o, this._eventNameToPlugin = new Map, t.forEach(i => { i.manager = this }), this._plugins = t.slice().reverse() } addEventListener(t, o, i) { return this._findPluginFor(o).addEventListener(t, o, i) } addGlobalEventListener(t, o, i) { return this._findPluginFor(o).addGlobalEventListener(t, o, i) } getZone() { return this._zone } _findPluginFor(t) { const o = this._eventNameToPlugin.get(t); if (o) return o; const i = this._plugins; for (let r = 0; r < i.length; r++) { const s = i[r]; if (s.supports(t)) return this._eventNameToPlugin.set(t, s), s } throw new Error(`No event manager plugin found for event ${t}`) } } return e.\u0275fac = function (t) { return new (t || e)(q(la), q(Ye)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); class ay { constructor(n) { this._doc = n } addGlobalEventListener(n, t, o) { const i = ni().getGlobalEventTarget(this._doc, n); if (!i) throw new Error(`Unsupported event target ${i} for event ${t}`); return this.addEventListener(i, t, o) } } let ly = (() => { class e { constructor() { this.usageCount = new Map } addStyles(t) { for (const o of t) 1 === this.changeUsageCount(o, 1) && this.onStyleAdded(o) } removeStyles(t) { for (const o of t) 0 === this.changeUsageCount(o, -1) && this.onStyleRemoved(o) } onStyleRemoved(t) { } onStyleAdded(t) { } getAllStyles() { return this.usageCount.keys() } changeUsageCount(t, o) { const i = this.usageCount; let r = i.get(t) ?? 0; return r += o, r > 0 ? i.set(t, r) : i.delete(t), r } ngOnDestroy() { for (const t of this.getAllStyles()) this.onStyleRemoved(t); this.usageCount.clear() } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(), cr = (() => { class e extends ly { constructor(t) { super(), this.doc = t, this.styleRef = new Map, this.hostNodes = new Set, this.resetHostNodes() } onStyleAdded(t) { for (const o of this.hostNodes) this.addStyleToHost(o, t) } onStyleRemoved(t) { const o = this.styleRef; o.get(t)?.forEach(r => r.remove()), o.delete(t) } ngOnDestroy() { super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes() } addHost(t) { this.hostNodes.add(t); for (const o of this.getAllStyles()) this.addStyleToHost(t, o) } removeHost(t) { this.hostNodes.delete(t) } addStyleToHost(t, o) { const i = this.doc.createElement("style"); i.textContent = o, t.appendChild(i); const r = this.styleRef.get(o); r ? r.push(i) : this.styleRef.set(o, [i]) } resetHostNodes() { const t = this.hostNodes; t.clear(), t.add(this.doc.head) } } return e.\u0275fac = function (t) { return new (t || e)(q(Lt)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const Lc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Rc = /%COMP%/g, dy = new B("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function fy(e, n) { return n.flat(100).map(t => t.replace(Rc, e)) } function hy(e) { return n => { if ("__ngUnwrap__" === n) return e; !1 === e(n) && (n.preventDefault(), n.returnValue = !1) } } let Vc = (() => { class e { constructor(t, o, i, r) { this.eventManager = t, this.sharedStylesHost = o, this.appId = i, this.removeStylesOnCompDestory = r, this.rendererByCompId = new Map, this.defaultRenderer = new Bc(t) } createRenderer(t, o) { if (!t || !o) return this.defaultRenderer; const i = this.getOrCreateRenderer(t, o); return i instanceof my ? i.applyToHost(t) : i instanceof jc && i.applyStyles(), i } getOrCreateRenderer(t, o) { const i = this.rendererByCompId; let r = i.get(o.id); if (!r) { const s = this.eventManager, a = this.sharedStylesHost, l = this.removeStylesOnCompDestory; switch (o.encapsulation) { case Xt.Emulated: r = new my(s, a, o, this.appId, l); break; case Xt.ShadowDom: return new Lx(s, a, t, o); default: r = new jc(s, a, o, l) }r.onDestroy = () => i.delete(o.id), i.set(o.id, r) } return r } ngOnDestroy() { this.rendererByCompId.clear() } begin() { } end() { } } return e.\u0275fac = function (t) { return new (t || e)(q(ua), q(cr), q(or), q(dy)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); class Bc { constructor(n) { this.eventManager = n, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(n, t) { return t ? document.createElementNS(Lc[t] || t, n) : document.createElement(n) } createComment(n) { return document.createComment(n) } createText(n) { return document.createTextNode(n) } appendChild(n, t) { (gy(n) ? n.content : n).appendChild(t) } insertBefore(n, t, o) { n && (gy(n) ? n.content : n).insertBefore(t, o) } removeChild(n, t) { n && n.removeChild(t) } selectRootElement(n, t) { let o = "string" == typeof n ? document.querySelector(n) : n; if (!o) throw new Error(`The selector "${n}" did not match any elements`); return t || (o.textContent = ""), o } parentNode(n) { return n.parentNode } nextSibling(n) { return n.nextSibling } setAttribute(n, t, o, i) { if (i) { t = i + ":" + t; const r = Lc[i]; r ? n.setAttributeNS(r, t, o) : n.setAttribute(t, o) } else n.setAttribute(t, o) } removeAttribute(n, t, o) { if (o) { const i = Lc[o]; i ? n.removeAttributeNS(i, t) : n.removeAttribute(`${o}:${t}`) } else n.removeAttribute(t) } addClass(n, t) { n.classList.add(t) } removeClass(n, t) { n.classList.remove(t) } setStyle(n, t, o, i) { i & (gt.DashCase | gt.Important) ? n.style.setProperty(t, o, i & gt.Important ? "important" : "") : n.style[t] = o } removeStyle(n, t, o) { o & gt.DashCase ? n.style.removeProperty(t) : n.style[t] = "" } setProperty(n, t, o) { n[t] = o } setValue(n, t) { n.nodeValue = t } listen(n, t, o) { return "string" == typeof n ? this.eventManager.addGlobalEventListener(n, t, hy(o)) : this.eventManager.addEventListener(n, t, hy(o)) } } function gy(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class Lx extends Bc { constructor(n, t, o, i) { super(n), this.sharedStylesHost = t, this.hostEl = o, this.shadowRoot = o.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const r = fy(i.id, i.styles); for (const s of r) { const a = document.createElement("style"); a.textContent = s, this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(n) { return n === this.hostEl ? this.shadowRoot : n } appendChild(n, t) { return super.appendChild(this.nodeOrShadowRoot(n), t) } insertBefore(n, t, o) { return super.insertBefore(this.nodeOrShadowRoot(n), t, o) } removeChild(n, t) { return super.removeChild(this.nodeOrShadowRoot(n), t) } parentNode(n) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class jc extends Bc { constructor(n, t, o, i, r = o.id) { super(n), this.sharedStylesHost = t, this.removeStylesOnCompDestory = i, this.rendererUsageCount = 0, this.styles = fy(r, o.styles) } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class my extends jc { constructor(n, t, o, i, r) { const s = i + "-" + o.id; super(n, t, o, r, s), this.contentAttr = function Nx(e) { return "_ngcontent-%COMP%".replace(Rc, e) }(s), this.hostAttr = function Px(e) { return "_nghost-%COMP%".replace(Rc, e) }(s) } applyToHost(n) { this.applyStyles(), this.setAttribute(n, this.hostAttr, "") } createElement(n, t) { const o = super.createElement(n, t); return super.setAttribute(o, this.contentAttr, ""), o } } let Rx = (() => { class e extends ay { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, o, i) { return t.addEventListener(o, i, !1), () => this.removeEventListener(t, o, i) } removeEventListener(t, o, i) { return t.removeEventListener(o, i) } } return e.\u0275fac = function (t) { return new (t || e)(q(Lt)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const _y = ["alt", "control", "meta", "shift"], Vx = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Bx = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let jx = (() => { class e extends ay { constructor(t) { super(t) } supports(t) { return null != e.parseEventName(t) } addEventListener(t, o, i) { const r = e.parseEventName(o), s = e.eventCallback(r.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => ni().onAndCancel(t, r.domEventName, s)) } static parseEventName(t) { const o = t.toLowerCase().split("."), i = o.shift(); if (0 === o.length || "keydown" !== i && "keyup" !== i) return null; const r = e._normalizeKey(o.pop()); let s = "", a = o.indexOf("code"); if (a > -1 && (o.splice(a, 1), s = "code."), _y.forEach(u => { const c = o.indexOf(u); c > -1 && (o.splice(c, 1), s += u + ".") }), s += r, 0 != o.length || 0 === r.length) return null; const l = {}; return l.domEventName = i, l.fullKey = s, l } static matchEventFullKeyCode(t, o) { let i = Vx[t.key] || t.key, r = ""; return o.indexOf("code.") > -1 && (i = t.code, r = "code."), !(null == i || !i) && (i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), _y.forEach(s => { s !== i && (0, Bx[s])(t) && (r += s + ".") }), r += i, r === o) } static eventCallback(t, o, i) { return r => { e.matchEventFullKeyCode(r, t) && i.runGuarded(() => o(r)) } } static _normalizeKey(t) { return "esc" === t ? "escape" : t } } return e.\u0275fac = function (t) { return new (t || e)(q(Lt)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const qx = v_(xA, "browser", [{ provide: oc, useValue: "browser" }, { provide: d_, useValue: function Hx() { kc.makeCurrent() }, multi: !0 }, { provide: Lt, useFactory: function $x() { return function I1(e) { Yl = e }(document), document }, deps: [] }]), Cy = new B(""), wy = [{ provide: qs, useClass: class Sx { addToWindow(n) { Ce.getAngularTestability = (o, i = !0) => { const r = n.findTestabilityInTree(o, i); if (null == r) throw new Error("Could not find testability for element."); return r }, Ce.getAllAngularTestabilities = () => n.getAllTestabilities(), Ce.getAllAngularRootElements = () => n.getAllRootElements(), Ce.frameworkStabilizers || (Ce.frameworkStabilizers = []), Ce.frameworkStabilizers.push(o => { const i = Ce.getAllAngularTestabilities(); let r = i.length, s = !1; const a = function (l) { s = s || l, r--, 0 == r && o(s) }; i.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(n, t, o) { return null == t ? null : n.getTestability(t) ?? (o ? ni().isShadowRoot(t) ? this.findTestabilityInTree(n, t.host, !0) : this.findTestabilityInTree(n, t.parentElement, !0) : null) } }, deps: [] }, { provide: m_, useClass: ac, deps: [Ye, lc, qs] }, { provide: ac, useClass: ac, deps: [Ye, lc, qs] }], Dy = [{ provide: ru, useValue: "root" }, { provide: Lo, useFactory: function Ux() { return new Lo }, deps: [] }, { provide: la, useClass: Rx, multi: !0, deps: [Lt, Ye, oc] }, { provide: la, useClass: jx, multi: !0, deps: [Lt] }, { provide: Vc, useClass: Vc, deps: [ua, cr, or, dy] }, { provide: up, useExisting: Vc }, { provide: ly, useExisting: cr }, { provide: cr, useClass: cr, deps: [Lt] }, { provide: ua, useClass: ua, deps: [la, Ye] }, { provide: ty, useClass: xx, deps: [] }, []]; let Gx = (() => { class e { constructor(t) { } static withServerTransition(t) { return { ngModule: e, providers: [{ provide: or, useValue: t.appId }, { provide: sy, useExisting: or }, Ax] } } } return e.\u0275fac = function (t) { return new (t || e)(q(Cy, 12)) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({ providers: [...Dy, ...wy], imports: [oi, MA] }), e })(); typeof window < "u" && window; let Iy = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: function (t) { let o = null; return o = t ? new (t || e) : q(Ty), o }, providedIn: "root" }), e })(), Ty = (() => { class e extends Iy { constructor(t) { super(), this._doc = t } sanitize(t, o) { if (null == o) return null; switch (t) { case _e.NONE: return o; case _e.HTML: return on(o, "HTML") ? It(o) : Kh(this._doc, String(o)).toString(); case _e.STYLE: return on(o, "Style") ? It(o) : o; case _e.SCRIPT: if (on(o, "Script")) return It(o); throw new Error("unsafe value used in a script context"); case _e.URL: return on(o, "URL") ? It(o) : gs(String(o)); case _e.RESOURCE_URL: if (on(o, "ResourceURL")) return It(o); throw new Error(`unsafe value used in a resource URL context (see ${Nr})`); default: throw new Error(`Unexpected SecurityContext ${t} (see ${Nr})`) } } bypassSecurityTrustHtml(t) { return function O1(e) { return new T1(e) }(t) } bypassSecurityTrustStyle(t) { return function N1(e) { return new A1(e) }(t) } bypassSecurityTrustScript(t) { return function P1(e) { return new S1(e) }(t) } bypassSecurityTrustUrl(t) { return function k1(e) { return new x1(e) }(t) } bypassSecurityTrustResourceUrl(t) { return function L1(e) { return new M1(e) }(t) } } return e.\u0275fac = function (t) { return new (t || e)(q(Lt)) }, e.\u0275prov = J({ token: e, factory: function (t) { let o = null; return o = t ? new t : function Zx(e) { return new Ty(e.get(Lt)) }(q($e)), o }, providedIn: "root" }), e })(); const { isArray: Xx } = Array, { getPrototypeOf: eM, prototype: tM, keys: nM } = Object; const { isArray: rM } = Array; function Ay(e) { return Sn(n => function sM(e, n) { return rM(n) ? e(...n) : e(n) }(e, n)) } function aM(e, n) { return e.reduce((t, o, i) => (t[o] = n[i], t), {}) } function $c(...e) { const n = Zd(e), { args: t, keys: o } = function oM(e) { if (1 === e.length) { const n = e[0]; if (Xx(n)) return { args: n, keys: null }; if (function iM(e) { return e && "object" == typeof e && eM(e) === tM }(n)) { const t = nM(n); return { args: t.map(o => n[o]), keys: t } } } return { args: e, keys: null } }(e), i = new Qe(r => { const { length: s } = t; if (!s) return void r.complete(); const a = new Array(s); let l = s, u = s; for (let c = 0; c < s; c++) { let d = !1; St(t[c]).subscribe(At(r, p => { d || (d = !0, u--), a[c] = p }, () => l--, void 0, () => { (!l || !d) && (u || r.next(o ? aM(o, a) : a), r.complete()) })) } }); return n ? i.pipe(Ay(n)) : i } let Sy = (() => { class e { constructor(t, o) { this._renderer = t, this._elementRef = o, this.onChange = i => { }, this.onTouched = () => { } } setProperty(t, o) { this._renderer.setProperty(this._elementRef.nativeElement, t, o) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return e.\u0275fac = function (t) { return new (t || e)(b(eo), b(Nt)) }, e.\u0275dir = W({ type: e }), e })(), uo = (() => { class e extends Sy { } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275dir = W({ type: e, features: [oe] }), e })(); const cn = new B("NgValueAccessor"), lM = { provide: cn, useExisting: me(() => Tn), multi: !0 }; let Tn = (() => { class e extends uo { writeValue(t) { this.setProperty("checked", t) } } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275dir = W({ type: e, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function (t, o) { 1 & t && M("change", function (r) { return o.onChange(r.target.checked) })("blur", function () { return o.onTouched() }) }, features: [de([lM]), oe] }), e })(); const uM = { provide: cn, useExisting: me(() => co), multi: !0 }, dM = new B("CompositionEventMode"); let co = (() => { class e extends Sy { constructor(t, o, i) { super(t, o), this._compositionMode = i, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function cM() { const e = ni() ? ni().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", t ?? "") } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return e.\u0275fac = function (t) { return new (t || e)(b(eo), b(Nt), b(dM, 8)) }, e.\u0275dir = W({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, o) { 1 & t && M("input", function (r) { return o._handleInput(r.target.value) })("blur", function () { return o.onTouched() })("compositionstart", function () { return o._compositionStart() })("compositionend", function (r) { return o._compositionEnd(r.target.value) }) }, features: [de([uM]), oe] }), e })(); const fM = !1; const ot = new B("NgValidators"), Rn = new B("NgAsyncValidators"); function Ry(e) { if (!e) return ca; let n, t; return "string" == typeof e ? (t = "", "^" !== e.charAt(0) && (t += "^"), t += e, "$" !== e.charAt(e.length - 1) && (t += "$"), n = new RegExp(t)) : (t = e.toString(), n = e), o => { if (function Ln(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length }(o.value)) return null; const i = o.value; return n.test(i) ? null : { pattern: { requiredPattern: t, actualValue: i } } } } function ca(e) { return null } function Vy(e) { return null != e } function By(e) { const n = xs(e) ? za(e) : e; if (fM && !ig(n)) { let t = "Expected async validator to return Promise or Observable."; throw "object" == typeof e && (t += " Are you using a synchronous validator where an async validator is expected?"), new O(-1101, t) } return n } function jy(e) { let n = {}; return e.forEach(t => { n = null != t ? { ...n, ...t } : n }), 0 === Object.keys(n).length ? null : n } function Hy(e, n) { return n.map(t => t(e)) } function Uy(e) { return e.map(n => function pM(e) { return !e.validate }(n) ? n : t => n.validate(t)) } function qc(e) { return null != e ? function $y(e) { if (!e) return null; const n = e.filter(Vy); return 0 == n.length ? null : function (t) { return jy(Hy(t, n)) } }(Uy(e)) : null } function Gc(e) { return null != e ? function qy(e) { if (!e) return null; const n = e.filter(Vy); return 0 == n.length ? null : function (t) { return $c(Hy(t, n).map(By)).pipe(Sn(jy)) } }(Uy(e)) : null } function Gy(e, n) { return null === e ? [n] : Array.isArray(e) ? [...e, n] : [e, n] } function Qy(e) { return e._rawValidators } function zy(e) { return e._rawAsyncValidators } function Qc(e) { return e ? Array.isArray(e) ? e : [e] : [] } function da(e, n) { return Array.isArray(e) ? e.includes(n) : e === n } function Wy(e, n) { const t = Qc(n); return Qc(e).forEach(i => { da(t, i) || t.push(i) }), t } function Ky(e, n) { return Qc(n).filter(t => !da(e, t)) } class Yy { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(n) { this._rawValidators = n || [], this._composedValidatorFn = qc(this._rawValidators) } _setAsyncValidators(n) { this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = Gc(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(n) { this._onDestroyCallbacks.push(n) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = [] } reset(n) { this.control && this.control.reset(n) } hasError(n, t) { return !!this.control && this.control.hasError(n, t) } getError(n, t) { return this.control ? this.control.getError(n, t) : null } } class dt extends Yy { get formDirective() { return null } get path() { return null } } class Vn extends Yy { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Jy { constructor(n) { this._cd = n } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Bn = (() => { class e extends Jy { constructor(t) { super(t) } } return e.\u0275fac = function (t) { return new (t || e)(b(Vn, 2)) }, e.\u0275dir = W({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, o) { 2 & t && Os("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending) }, features: [oe] }), e })(), jn = (() => { class e extends Jy { constructor(t) { super(t) } } return e.\u0275fac = function (t) { return new (t || e)(b(dt, 10)) }, e.\u0275dir = W({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (t, o) { 2 & t && Os("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending)("ng-submitted", o.isSubmitted) }, features: [oe] }), e })(); function Zy(e, n) { return e ? `with name: '${n}'` : `at index: ${n}` } const Kc = !1, dr = "VALID", ha = "INVALID", ii = "PENDING", fr = "DISABLED"; function Yc(e) { return (pa(e) ? e.validators : e) || null } function Jc(e, n) { return (pa(n) ? n.asyncValidators : e) || null } function pa(e) { return null != e && !Array.isArray(e) && "object" == typeof e } function Xy(e, n, t) { const o = e.controls; if (!(n ? Object.keys(o) : o).length) throw new O(1e3, Kc ? function yM(e) { return `\n    There are no form controls registered with this ${e ? "group" : "array"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  ` }(n) : ""); if (!o[t]) throw new O(1001, Kc ? function vM(e, n) { return `Cannot find form control ${Zy(e, n)}` }(n, t) : "") } function ev(e, n, t) { e._forEachChild((o, i) => { if (void 0 === t[i]) throw new O(1002, Kc ? function CM(e, n) { return `Must supply a value for form control ${Zy(e, n)}` }(n, i) : "") }) } class ga { constructor(n, t) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(t) } get validator() { return this._composedValidatorFn } set validator(n) { this._rawValidators = this._composedValidatorFn = n } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(n) { this._rawAsyncValidators = this._composedAsyncValidatorFn = n } get parent() { return this._parent } get valid() { return this.status === dr } get invalid() { return this.status === ha } get pending() { return this.status == ii } get disabled() { return this.status === fr } get enabled() { return this.status !== fr } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(n) { this._assignValidators(n) } setAsyncValidators(n) { this._assignAsyncValidators(n) } addValidators(n) { this.setValidators(Wy(n, this._rawValidators)) } addAsyncValidators(n) { this.setAsyncValidators(Wy(n, this._rawAsyncValidators)) } removeValidators(n) { this.setValidators(Ky(n, this._rawValidators)) } removeAsyncValidators(n) { this.setAsyncValidators(Ky(n, this._rawAsyncValidators)) } hasValidator(n) { return da(this._rawValidators, n) } hasAsyncValidator(n) { return da(this._rawAsyncValidators, n) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(n = {}) { this.touched = !0, this._parent && !n.onlySelf && this._parent.markAsTouched(n) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(n => n.markAllAsTouched()) } markAsUntouched(n = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updateTouched(n) } markAsDirty(n = {}) { this.pristine = !1, this._parent && !n.onlySelf && this._parent.markAsDirty(n) } markAsPristine(n = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updatePristine(n) } markAsPending(n = {}) { this.status = ii, !1 !== n.emitEvent && this.statusChanges.emit(this.status), this._parent && !n.onlySelf && this._parent.markAsPending(n) } disable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = fr, this.errors = null, this._forEachChild(o => { o.disable({ ...n, onlySelf: !0 }) }), this._updateValue(), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(o => o(!0)) } enable(n = {}) { const t = this._parentMarkedDirty(n.onlySelf); this.status = dr, this._forEachChild(o => { o.enable({ ...n, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }), this._updateAncestors({ ...n, skipPristineCheck: t }), this._onDisabledChange.forEach(o => o(!1)) } _updateAncestors(n) { this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(n) { this._parent = n } getRawValue() { return this.value } updateValueAndValidity(n = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === dr || this.status === ii) && this._runAsyncValidator(n.emitEvent)), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n) } _updateTreeValidity(n = { emitEvent: !0 }) { this._forEachChild(t => t._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? fr : dr } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(n) { if (this.asyncValidator) { this.status = ii, this._hasOwnPendingAsyncValidator = !0; const t = By(this.asyncValidator(this)); this._asyncValidationSubscription = t.subscribe(o => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(o, { emitEvent: n }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(n, t = {}) { this.errors = n, this._updateControlsErrors(!1 !== t.emitEvent) } get(n) { let t = n; return null == t || (Array.isArray(t) || (t = t.split(".")), 0 === t.length) ? null : t.reduce((o, i) => o && o._find(i), this) } getError(n, t) { const o = t ? this.get(t) : this; return o && o.errors ? o.errors[n] : null } hasError(n, t) { return !!this.getError(n, t) } get root() { let n = this; for (; n._parent;)n = n._parent; return n } _updateControlsErrors(n) { this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(n) } _initObservables() { this.valueChanges = new Q, this.statusChanges = new Q } _calculateStatus() { return this._allControlsDisabled() ? fr : this.errors ? ha : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(ii) ? ii : this._anyControlsHaveStatus(ha) ? ha : dr } _anyControlsHaveStatus(n) { return this._anyControls(t => t.status === n) } _anyControlsDirty() { return this._anyControls(n => n.dirty) } _anyControlsTouched() { return this._anyControls(n => n.touched) } _updatePristine(n = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !n.onlySelf && this._parent._updatePristine(n) } _updateTouched(n = {}) { this.touched = this._anyControlsTouched(), this._parent && !n.onlySelf && this._parent._updateTouched(n) } _registerOnCollectionChange(n) { this._onCollectionChange = n } _setUpdateStrategy(n) { pa(n) && null != n.updateOn && (this._updateOn = n.updateOn) } _parentMarkedDirty(n) { return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(n) { return null } _assignValidators(n) { this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function wM(e) { return Array.isArray(e) ? qc(e) : e || null }(this._rawValidators) } _assignAsyncValidators(n) { this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function DM(e) { return Array.isArray(e) ? Gc(e) : e || null }(this._rawAsyncValidators) } } class hr extends ga { constructor(n, t, o) { super(Yc(t), Jc(o, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(n, t) { return this.controls[n] ? this.controls[n] : (this.controls[n] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t) } addControl(n, t, o = {}) { this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: o.emitEvent }), this._onCollectionChange() } removeControl(n, t = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } setControl(n, t, o = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], t && this.registerControl(n, t), this.updateValueAndValidity({ emitEvent: o.emitEvent }), this._onCollectionChange() } contains(n) { return this.controls.hasOwnProperty(n) && this.controls[n].enabled } setValue(n, t = {}) { ev(this, !0, n), Object.keys(n).forEach(o => { Xy(this, !0, o), this.controls[o].setValue(n[o], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (Object.keys(n).forEach(o => { const i = this.controls[o]; i && i.patchValue(n[o], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = {}, t = {}) { this._forEachChild((o, i) => { o.reset(n[i], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this._reduceChildren({}, (n, t, o) => (n[o] = t.getRawValue(), n)) } _syncPendingControls() { let n = this._reduceChildren(!1, (t, o) => !!o._syncPendingControls() || t); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { Object.keys(this.controls).forEach(t => { const o = this.controls[t]; o && n(o, t) }) } _setUpControls() { this._forEachChild(n => { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(n) { for (const [t, o] of Object.entries(this.controls)) if (this.contains(t) && n(o)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (t, o, i) => ((o.enabled || this.disabled) && (t[i] = o.value), t)) } _reduceChildren(n, t) { let o = n; return this._forEachChild((i, r) => { o = t(o, i, r) }), o } _allControlsDisabled() { for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(n) { return this.controls.hasOwnProperty(n) ? this.controls[n] : null } } class tv extends hr { } const fo = new B("CallSetDisabledState", { providedIn: "root", factory: () => pr }), pr = "always"; function ma(e, n) { return [...n.path, e] } function gr(e, n, t = pr) { Zc(e, n), n.valueAccessor.writeValue(e.value), (e.disabled || "always" === t) && n.valueAccessor.setDisabledState?.(e.disabled), function EM(e, n) { n.valueAccessor.registerOnChange(t => { e._pendingValue = t, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && nv(e, n) }) }(e, n), function TM(e, n) { const t = (o, i) => { n.valueAccessor.writeValue(o), i && n.viewToModelUpdate(o) }; e.registerOnChange(t), n._registerOnDestroy(() => { e._unregisterOnChange(t) }) }(e, n), function IM(e, n) { n.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && nv(e, n), "submit" !== e.updateOn && e.markAsTouched() }) }(e, n), function bM(e, n) { if (n.valueAccessor.setDisabledState) { const t = o => { n.valueAccessor.setDisabledState(o) }; e.registerOnDisabledChange(t), n._registerOnDestroy(() => { e._unregisterOnDisabledChange(t) }) } }(e, n) } function _a(e, n, t = !0) { const o = () => { }; n.valueAccessor && (n.valueAccessor.registerOnChange(o), n.valueAccessor.registerOnTouched(o)), va(e, n), e && (n._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => { })) } function ya(e, n) { e.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(n) }) } function Zc(e, n) { const t = Qy(e); null !== n.validator ? e.setValidators(Gy(t, n.validator)) : "function" == typeof t && e.setValidators([t]); const o = zy(e); null !== n.asyncValidator ? e.setAsyncValidators(Gy(o, n.asyncValidator)) : "function" == typeof o && e.setAsyncValidators([o]); const i = () => e.updateValueAndValidity(); ya(n._rawValidators, i), ya(n._rawAsyncValidators, i) } function va(e, n) { let t = !1; if (null !== e) { if (null !== n.validator) { const i = Qy(e); if (Array.isArray(i) && i.length > 0) { const r = i.filter(s => s !== n.validator); r.length !== i.length && (t = !0, e.setValidators(r)) } } if (null !== n.asyncValidator) { const i = zy(e); if (Array.isArray(i) && i.length > 0) { const r = i.filter(s => s !== n.asyncValidator); r.length !== i.length && (t = !0, e.setAsyncValidators(r)) } } } const o = () => { }; return ya(n._rawValidators, o), ya(n._rawAsyncValidators, o), t } function nv(e, n) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), n.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function ov(e, n) { Zc(e, n) } function ed(e, n) { if (!e.hasOwnProperty("model")) return !1; const t = e.model; return !!t.isFirstChange() || !Object.is(n, t.currentValue) } function iv(e, n) { e._syncPendingControls(), n.forEach(t => { const o = t.control; "submit" === o.updateOn && o._pendingChange && (t.viewToModelUpdate(o._pendingValue), o._pendingChange = !1) }) } function td(e, n) { if (!n) return null; let t, o, i; return Array.isArray(n), n.forEach(r => { r.constructor === co ? t = r : function xM(e) { return Object.getPrototypeOf(e.constructor) === uo }(r) ? o = r : i = r }), i || o || t || null } const FM = { provide: dt, useExisting: me(() => ri) }, mr = (() => Promise.resolve())(); let ri = (() => { class e extends dt { constructor(t, o, i) { super(), this.callSetDisabledState = i, this.submitted = !1, this._directives = new Set, this.ngSubmit = new Q, this.form = new hr({}, qc(t), Gc(o)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { mr.then(() => { const o = this._findContainer(t.path); t.control = o.registerControl(t.name, t.control), gr(t.control, t, this.callSetDisabledState), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { mr.then(() => { const o = this._findContainer(t.path); o && o.removeControl(t.name), this._directives.delete(t) }) } addFormGroup(t) { mr.then(() => { const o = this._findContainer(t.path), i = new hr({}); ov(i, t), o.registerControl(t.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { mr.then(() => { const o = this._findContainer(t.path); o && o.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, o) { mr.then(() => { this.form.get(t.path).setValue(o) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, iv(this.form, this._directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return e.\u0275fac = function (t) { return new (t || e)(b(ot, 10), b(Rn, 10), b(fo, 8)) }, e.\u0275dir = W({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, o) { 1 & t && M("submit", function (r) { return o.onSubmit(r) })("reset", function () { return o.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [de([FM]), oe] }), e })(); function rv(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) } function sv(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const si = class extends ga { constructor(n = null, t, o) { super(Yc(t), Jc(o, t)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), pa(t) && (t.nonNullable || t.initialValueIsDefault) && (this.defaultValue = sv(n) ? n.value : n) } setValue(n, t = {}) { this.value = this._pendingValue = n, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(o => o(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t) } patchValue(n, t = {}) { this.setValue(n, t) } reset(n = this.defaultValue, t = {}) { this._applyFormState(n), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1 } _updateValue() { } _anyControls(n) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(n) { this._onChange.push(n) } _unregisterOnChange(n) { rv(this._onChange, n) } registerOnDisabledChange(n) { this._onDisabledChange.push(n) } _unregisterOnDisabledChange(n) { rv(this._onDisabledChange, n) } _forEachChild(n) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(n) { sv(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = n } }, av = si, PM = { provide: Vn, useExisting: me(() => ai) }, cv = (() => Promise.resolve())(); let ai = (() => { class e extends Vn { constructor(t, o, i, r, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new si, this._registered = !1, this.update = new Q, this._parent = t, this._setValidators(o), this._setAsyncValidators(i), this.valueAccessor = td(0, r) } ngOnChanges(t) { if (this._checkForErrors(), !this._registered || "name" in t) { if (this._registered && (this._checkName(), this.formDirective)) { const o = t.name.previousValue; this.formDirective.removeControl({ name: o, path: this._getPath(o) }) } this._setUpControl() } "isDisabled" in t && this._updateDisabled(t), ed(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { gr(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { cv.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(t) { const o = t.isDisabled.currentValue, i = 0 !== o && function mc(e) { return "boolean" == typeof e ? e : null != e && "false" !== e }(o); cv.then(() => { i && !this.control.disabled ? this.control.disable() : !i && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(t) { return this._parent ? ma(t, this._parent) : [t] } } return e.\u0275fac = function (t) { return new (t || e)(b(dt, 9), b(ot, 10), b(Rn, 10), b(cn, 10), b(ti, 8), b(fo, 8)) }, e.\u0275dir = W({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [de([PM]), oe, Te] }), e })(), Ca = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = W({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), e })(); const LM = { provide: cn, useExisting: me(() => li), multi: !0 }; let fv = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({}), e })(), RM = (() => { class e { constructor() { this._accessors = [] } add(t, o) { this._accessors.push([t, o]) } remove(t) { for (let o = this._accessors.length - 1; o >= 0; --o)if (this._accessors[o][1] === t) return void this._accessors.splice(o, 1) } select(t) { this._accessors.forEach(o => { this._isSameGroup(o, t) && o[1] !== t && o[1].fireUncheck(t.value) }) } _isSameGroup(t, o) { return !!t[0].control && t[0]._parent === o._control._parent && t[1].name === o.name } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: fv }), e })(), li = (() => { class e extends uo { constructor(t, o, i, r) { super(t, o), this._registry = i, this._injector = r, this.setDisabledStateFired = !1, this.onChange = () => { }, this.callSetDisabledState = mo(fo, { optional: !0 }) ?? pr } ngOnInit() { this._control = this._injector.get(Vn), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(t) { this._state = t === this.value, this.setProperty("checked", this._state) } registerOnChange(t) { this._fn = t, this.onChange = () => { t(this.value), this._registry.select(this) } } setDisabledState(t) { (this.setDisabledStateFired || t || "whenDisabledForLegacyCode" === this.callSetDisabledState) && this.setProperty("disabled", t), this.setDisabledStateFired = !0 } fireUncheck(t) { this.writeValue(t) } _checkName() { !this.name && this.formControlName && (this.name = this.formControlName) } } return e.\u0275fac = function (t) { return new (t || e)(b(eo), b(Nt), b(RM), b($e)) }, e.\u0275dir = W({ type: e, selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]], hostBindings: function (t, o) { 1 & t && M("change", function () { return o.onChange() })("blur", function () { return o.onTouched() }) }, inputs: { name: "name", formControlName: "formControlName", value: "value" }, features: [de([LM]), oe] }), e })(); const nd = new B("NgModelWithFormControlWarning"), BM = { provide: Vn, useExisting: me(() => _r) }; let _r = (() => { class e extends Vn { set isDisabled(t) { } constructor(t, o, i, r, s) { super(), this._ngModelWarningConfig = r, this.callSetDisabledState = s, this.update = new Q, this._ngModelWarningSent = !1, this._setValidators(t), this._setAsyncValidators(o), this.valueAccessor = td(0, i) } ngOnChanges(t) { if (this._isControlChanged(t)) { const o = t.form.previousValue; o && _a(o, this, !1), gr(this.form, this, this.callSetDisabledState), this.form.updateValueAndValidity({ emitEvent: !1 }) } ed(t, this.viewModel) && (this.form.setValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.form && _a(this.form, this, !1) } get path() { return [] } get control() { return this.form } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _isControlChanged(t) { return t.hasOwnProperty("form") } } return e._ngModelWarningSentOnce = !1, e.\u0275fac = function (t) { return new (t || e)(b(ot, 10), b(Rn, 10), b(cn, 10), b(nd, 8), b(fo, 8)) }, e.\u0275dir = W({ type: e, selectors: [["", "formControl", ""]], inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], features: [de([BM]), oe, Te] }), e })(); const jM = { provide: dt, useExisting: me(() => Hn) }; let Hn = (() => { class e extends dt { constructor(t, o, i) { super(), this.callSetDisabledState = i, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new Q, this._setValidators(t), this._setAsyncValidators(o) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (va(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const o = this.form.get(t.path); return gr(o, t, this.callSetDisabledState), o.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), o } getControl(t) { return this.form.get(t.path) } removeControl(t) { _a(t.control || null, t, !1), function MM(e, n) { const t = e.indexOf(n); t > -1 && e.splice(t, 1) }(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, o) { this.form.get(t.path).setValue(o) } onSubmit(t) { return this.submitted = !0, iv(this.form, this.directives), this.ngSubmit.emit(t), "dialog" === t?.target?.method } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const o = t.control, i = this.form.get(t.path); o !== i && (_a(o || null, t), (e => e instanceof si)(i) && (gr(i, t, this.callSetDisabledState), t.control = i)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const o = this.form.get(t.path); ov(o, t), o.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const o = this.form.get(t.path); o && function AM(e, n) { return va(e, n) }(o, t) && o.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { Zc(this.form, this), this._oldForm && va(this._oldForm, this) } _checkFormPresent() { } } return e.\u0275fac = function (t) { return new (t || e)(b(ot, 10), b(Rn, 10), b(fo, 8)) }, e.\u0275dir = W({ type: e, selectors: [["", "formGroup", ""]], hostBindings: function (t, o) { 1 & t && M("submit", function (r) { return o.onSubmit(r) })("reset", function () { return o.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [de([jM]), oe, Te] }), e })(); const $M = { provide: Vn, useExisting: me(() => wa) }; let wa = (() => { class e extends Vn { set isDisabled(t) { } constructor(t, o, i, r, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.update = new Q, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(o), this._setAsyncValidators(i), this.valueAccessor = td(0, r) } ngOnChanges(t) { this._added || this._setUpControl(), ed(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return ma(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } } return e._ngModelWarningSentOnce = !1, e.\u0275fac = function (t) { return new (t || e)(b(dt, 13), b(ot, 10), b(Rn, 10), b(cn, 10), b(nd, 8)) }, e.\u0275dir = W({ type: e, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [de([$M]), oe, Te] }), e })(); const qM = { provide: cn, useExisting: me(() => ui), multi: !0 }; function gv(e, n) { return null == e ? `${n}` : (n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let ui = (() => { class e extends uo { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const i = gv(this._getOptionId(t), t); this.setProperty("value", i) } registerOnChange(t) { this.onChange = o => { this.value = this._getOptionValue(o), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const o of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(o), t)) return o; return null } _getOptionValue(t) { const o = function GM(e) { return e.split(":")[0] }(t); return this._optionMap.has(o) ? this._optionMap.get(o) : t } } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275dir = W({ type: e, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, o) { 1 & t && M("change", function (r) { return o.onChange(r.target.value) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [de([qM]), oe] }), e })(), Da = (() => { class e { constructor(t, o, i) { this._element = t, this._renderer = o, this._select = i, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(gv(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return e.\u0275fac = function (t) { return new (t || e)(b(Nt), b(eo), b(ui, 9)) }, e.\u0275dir = W({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), e })(); const QM = { provide: cn, useExisting: me(() => rd), multi: !0 }; function mv(e, n) { return null == e ? `${n}` : ("string" == typeof n && (n = `'${n}'`), n && "object" == typeof n && (n = "Object"), `${e}: ${n}`.slice(0, 50)) } let rd = (() => { class e extends uo { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let o; if (this.value = t, Array.isArray(t)) { const i = t.map(r => this._getOptionId(r)); o = (r, s) => { r._setSelected(i.indexOf(s.toString()) > -1) } } else o = (i, r) => { i._setSelected(!1) }; this._optionMap.forEach(o) } registerOnChange(t) { this.onChange = o => { const i = [], r = o.selectedOptions; if (void 0 !== r) { const s = r; for (let a = 0; a < s.length; a++) { const u = this._getOptionValue(s[a].value); i.push(u) } } else { const s = o.options; for (let a = 0; a < s.length; a++) { const l = s[a]; if (l.selected) { const u = this._getOptionValue(l.value); i.push(u) } } } this.value = i, t(i) } } _registerOption(t) { const o = (this._idCounter++).toString(); return this._optionMap.set(o, t), o } _getOptionId(t) { for (const o of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(o)._value, t)) return o; return null } _getOptionValue(t) { const o = function zM(e) { return e.split(":")[0] }(t); return this._optionMap.has(o) ? this._optionMap.get(o)._value : t } } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275dir = W({ type: e, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, o) { 1 & t && M("change", function (r) { return o.onChange(r.target) })("blur", function () { return o.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [de([QM]), oe] }), e })(), ba = (() => { class e { constructor(t, o, i) { this._element = t, this._renderer = o, this._select = i, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(mv(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(mv(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return e.\u0275fac = function (t) { return new (t || e)(b(Nt), b(eo), b(rd, 9)) }, e.\u0275dir = W({ type: e, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), e })(), ho = (() => { class e { constructor() { this._validator = ca } ngOnChanges(t) { if (this.inputName in t) { const o = this.normalizeInput(t[this.inputName].currentValue); this._enabled = this.enabled(o), this._validator = this._enabled ? this.createValidator(o) : ca, this._onChange && this._onChange() } } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } enabled(t) { return null != t } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = W({ type: e, features: [Te] }), e })(); const tF = { provide: ot, useExisting: me(() => Ea), multi: !0 }; let Ea = (() => { class e extends ho { constructor() { super(...arguments), this.inputName = "pattern", this.normalizeInput = t => t, this.createValidator = t => Ry(t) } } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275dir = W({ type: e, selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]], hostVars: 1, hostBindings: function (t, o) { 2 & t && De("pattern", o._enabled ? o.pattern : null) }, inputs: { pattern: "pattern" }, features: [de([tF]), oe] }), e })(), Iv = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({ imports: [fv] }), e })(); class Tv extends ga { constructor(n, t, o) { super(Yc(t), Jc(o, t)), this.controls = n, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(n) { return this.controls[this._adjustIndex(n)] } push(n, t = {}) { this.controls.push(n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } insert(n, t, o = {}) { this.controls.splice(n, 0, t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: o.emitEvent }) } removeAt(n, t = {}) { let o = this._adjustIndex(n); o < 0 && (o = 0), this.controls[o] && this.controls[o]._registerOnCollectionChange(() => { }), this.controls.splice(o, 1), this.updateValueAndValidity({ emitEvent: t.emitEvent }) } setControl(n, t, o = {}) { let i = this._adjustIndex(n); i < 0 && (i = 0), this.controls[i] && this.controls[i]._registerOnCollectionChange(() => { }), this.controls.splice(i, 1), t && (this.controls.splice(i, 0, t), this._registerControl(t)), this.updateValueAndValidity({ emitEvent: o.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(n, t = {}) { ev(this, !1, n), n.forEach((o, i) => { Xy(this, !1, i), this.at(i).setValue(o, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(n, t = {}) { null != n && (n.forEach((o, i) => { this.at(i) && this.at(i).patchValue(o, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(n = [], t = {}) { this._forEachChild((o, i) => { o.reset(n[i], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this.controls.map(n => n.getRawValue()) } clear(n = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: n.emitEvent })) } _adjustIndex(n) { return n < 0 ? n + this.length : n } _syncPendingControls() { let n = this.controls.reduce((t, o) => !!o._syncPendingControls() || t, !1); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { this.controls.forEach((t, o) => { n(t, o) }) } _updateValue() { this.value = this.controls.filter(n => n.enabled || this.disabled).map(n => n.value) } _anyControls(n) { return this.controls.some(t => t.enabled && n(t)) } _setUpControls() { this._forEachChild(n => this._registerControl(n)) } _allControlsDisabled() { for (const n of this.controls) if (n.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(n) { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) } _find(n) { return this.at(n) ?? null } } function Av(e) { return !!e && (void 0 !== e.asyncValidators || void 0 !== e.validators || void 0 !== e.updateOn) } let nF = (() => { class e { constructor() { this.useNonNullable = !1 } get nonNullable() { const t = new e; return t.useNonNullable = !0, t } group(t, o = null) { const i = this._reduceControls(t); let r = {}; return Av(o) ? r = o : null !== o && (r.validators = o.validator, r.asyncValidators = o.asyncValidator), new hr(i, r) } record(t, o = null) { const i = this._reduceControls(t); return new tv(i, o) } control(t, o, i) { let r = {}; return this.useNonNullable ? (Av(o) ? r = o : (r.validators = o, r.asyncValidators = i), new si(t, { ...r, nonNullable: !0 })) : new si(t, o, i) } array(t, o, i) { const r = t.map(s => this._createControl(s)); return new Tv(r, o, i) } _reduceControls(t) { const o = {}; return Object.keys(t).forEach(i => { o[i] = this._createControl(t[i]) }), o } _createControl(t) { return t instanceof si || t instanceof ga ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), oF = (() => { class e extends nF { group(t, o = null) { return super.group(t, o) } control(t, o, i) { return super.control(t, o, i) } array(t, o, i) { return super.array(t, o, i) } } return e.\u0275fac = function () { let n; return function (o) { return (n || (n = Ke(e)))(o || e) } }(), e.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), ad = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: fo, useValue: t.callSetDisabledState ?? pr }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({ imports: [Iv] }), e })(), ld = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: nd, useValue: t.warnOnNgModelWithFormControl ?? "always" }, { provide: fo, useValue: t.callSetDisabledState ?? pr }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({ imports: [Iv] }), e })(), Ia = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [oi, ld] }) } return e })(), ud = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [oi, ad, Ia] }) } return e })(); const Sv = { now: () => (Sv.delegate || Date).now(), delegate: void 0 }; class iF extends qn { constructor(n = 1 / 0, t = 1 / 0, o = Sv) { super(), this._bufferSize = n, this._windowTime = t, this._timestampProvider = o, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = t === 1 / 0, this._bufferSize = Math.max(1, n), this._windowTime = Math.max(1, t) } next(n) { const { isStopped: t, _buffer: o, _infiniteTimeWindow: i, _timestampProvider: r, _windowTime: s } = this; t || (o.push(n), !i && o.push(r.now() + s)), this._trimBuffer(), super.next(n) } _subscribe(n) { this._throwIfClosed(), this._trimBuffer(); const t = this._innerSubscribe(n), { _infiniteTimeWindow: o, _buffer: i } = this, r = i.slice(); for (let s = 0; s < r.length && !n.closed; s += o ? 1 : 2)n.next(r[s]); return this._checkFinalizedStatuses(n), t } _trimBuffer() { const { _bufferSize: n, _timestampProvider: t, _buffer: o, _infiniteTimeWindow: i } = this, r = (i ? 1 : 2) * n; if (n < 1 / 0 && r < o.length && o.splice(0, o.length - r), !i) { const s = t.now(); let a = 0; for (let l = 1; l < o.length && o[l] <= s; l += 2)a = l; a && o.splice(0, a + 1) } } } const Ta = { schedule(e, n) { const t = setTimeout(e, n); return () => clearTimeout(t) }, scheduleBeforeRender(e) { if (typeof window > "u") return Ta.schedule(e, 0); if (typeof window.requestAnimationFrame > "u") return Ta.schedule(e, 16); const n = window.requestAnimationFrame(e); return () => window.cancelAnimationFrame(n) } }; let cd; function pF(e, n, t) { let o = t; return function aF(e) { return !!e && e.nodeType === Node.ELEMENT_NODE }(e) && n.some((i, r) => !("*" === i || !function uF(e, n) { if (!cd) { const t = Element.prototype; cd = t.matches || t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector } return e.nodeType === Node.ELEMENT_NODE && cd.call(e, n) }(e, i) || (o = r, 0))), o } class mF { constructor(n, t) { this.componentFactory = t.get(Po).resolveComponentFactory(n) } create(n) { return new _F(this.componentFactory, n) } } class _F { constructor(n, t) { this.componentFactory = n, this.injector = t, this.eventEmitters = new iF(1), this.events = this.eventEmitters.pipe(function rF(e, n) { return Jt((t, o) => { let i = null, r = 0, s = !1; const a = () => s && !i && o.complete(); t.subscribe(At(o, l => { i?.unsubscribe(); let u = 0; const c = r++; St(e(l, c)).subscribe(i = At(o, d => o.next(n ? n(l, d, c, u++) : d), () => { i = null, a() })) }, () => { s = !0, a() })) }) }(o => of(...o))), this.componentRef = null, this.viewChangeDetectorRef = null, this.inputChanges = null, this.hasInputChanges = !1, this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, this.initialInputValues = new Map, this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName: o }) => o)), this.ngZone = this.injector.get(Ye), this.elementZone = typeof Zone > "u" ? null : this.ngZone.run(() => Zone.current) } connect(n) { this.runInZone(() => { if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null); null === this.componentRef && this.initializeComponent(n) }) } disconnect() { this.runInZone(() => { null === this.componentRef || null !== this.scheduledDestroyFn || (this.scheduledDestroyFn = Ta.schedule(() => { null !== this.componentRef && (this.componentRef.destroy(), this.componentRef = null, this.viewChangeDetectorRef = null) }, 10)) }) } getInputValue(n) { return this.runInZone(() => null === this.componentRef ? this.initialInputValues.get(n) : this.componentRef.instance[n]) } setInputValue(n, t) { this.runInZone(() => { null !== this.componentRef ? function cF(e, n) { return e === n || e != e && n != n }(t, this.getInputValue(n)) && (void 0 !== t || !this.unchangedInputs.has(n)) || (this.recordInputChange(n, t), this.unchangedInputs.delete(n), this.hasInputChanges = !0, this.componentRef.instance[n] = t, this.scheduleDetectChanges()) : this.initialInputValues.set(n, t) }) } initializeComponent(n) { const t = $e.create({ providers: [], parent: this.injector }), o = function hF(e, n) { const t = e.childNodes, o = n.map(() => []); let i = -1; n.some((r, s) => "*" === r && (i = s, !0)); for (let r = 0, s = t.length; r < s; ++r) { const a = t[r], l = pF(a, n, i); -1 !== l && o[l].push(a) } return o }(n, this.componentFactory.ngContentSelectors); this.componentRef = this.componentFactory.create(t, o, n), this.viewChangeDetectorRef = this.componentRef.injector.get(ti), this.implementsOnChanges = function lF(e) { return "function" == typeof e }(this.componentRef.instance.ngOnChanges), this.initializeInputs(), this.initializeOutputs(this.componentRef), this.detectChanges(), this.injector.get(Gs).attachView(this.componentRef.hostView) } initializeInputs() { this.componentFactory.inputs.forEach(({ propName: n }) => { this.initialInputValues.has(n) && this.setInputValue(n, this.initialInputValues.get(n)) }), this.initialInputValues.clear() } initializeOutputs(n) { const t = this.componentFactory.outputs.map(({ propName: o, templateName: i }) => n.instance[o].pipe(Sn(s => ({ name: i, value: s })))); this.eventEmitters.next(t) } callNgOnChanges(n) { if (!this.implementsOnChanges || null === this.inputChanges) return; const t = this.inputChanges; this.inputChanges = null, n.instance.ngOnChanges(t) } markViewForCheck(n) { this.hasInputChanges && (this.hasInputChanges = !1, n.markForCheck()) } scheduleDetectChanges() { this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = Ta.scheduleBeforeRender(() => { this.scheduledChangeDetectionFn = null, this.detectChanges() })) } recordInputChange(n, t) { if (!this.implementsOnChanges) return; null === this.inputChanges && (this.inputChanges = {}); const o = this.inputChanges[n]; if (o) return void (o.currentValue = t); const i = this.unchangedInputs.has(n), r = i ? void 0 : this.getInputValue(n); this.inputChanges[n] = new Cf(r, t, i) } detectChanges() { null !== this.componentRef && (this.callNgOnChanges(this.componentRef), this.markViewForCheck(this.viewChangeDetectorRef), this.componentRef.changeDetectorRef.detectChanges()) } runInZone(n) { return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(n) : n() } } class yF extends HTMLElement { constructor() { super(...arguments), this.ngElementEventsSubscription = null } } function po(e, n) { const t = function fF(e, n) { return n.get(Po).resolveComponentFactory(e).inputs }(e, n.injector), o = n.strategyFactory || new mF(e, n.injector), i = function dF(e) { const n = {}; return e.forEach(({ propName: t, templateName: o }) => { n[function sF(e) { return e.replace(/[A-Z]/g, n => `-${n.toLowerCase()}`) }(o)] = t }), n }(t); class r extends yF { get ngElementStrategy() { if (!this._ngElementStrategy) { const a = this._ngElementStrategy = o.create(this.injector || n.injector); t.forEach(({ propName: l }) => { if (!this.hasOwnProperty(l)) return; const u = this[l]; delete this[l], a.setInputValue(l, u) }) } return this._ngElementStrategy } constructor(a) { super(), this.injector = a } attributeChangedCallback(a, l, u, c) { this.ngElementStrategy.setInputValue(i[a], u) } connectedCallback() { let a = !1; this.ngElementStrategy.events && (this.subscribeToEvents(), a = !0), this.ngElementStrategy.connect(this), a || this.subscribeToEvents() } disconnectedCallback() { this._ngElementStrategy && this._ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), this.ngElementEventsSubscription = null) } subscribeToEvents() { this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(a => { const l = new CustomEvent(a.name, { detail: a.value }); this.dispatchEvent(l) }) } } return r.observedAttributes = Object.keys(i), t.forEach(({ propName: s }) => { Object.defineProperty(r.prototype, s, { get() { return this.ngElementStrategy.getInputValue(s) }, set(a) { this.ngElementStrategy.setInputValue(s, a) }, configurable: !0, enumerable: !0 }) }), r } function Aa(...e) { return za(e, Xd(e)) } class Sa { } class dd { } class vt { constructor(n) { this.normalizedNames = new Map, this.lazyUpdate = null, n ? this.lazyInit = "string" == typeof n ? () => { this.headers = new Map, n.split("\n").forEach(t => { const o = t.indexOf(":"); if (o > 0) { const i = t.slice(0, o), r = i.toLowerCase(), s = t.slice(o + 1).trim(); this.maybeSetNormalizedName(i, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.entries(n).forEach(([t, o]) => { let i; if (i = "string" == typeof o ? [o] : "number" == typeof o ? [o.toString()] : o.map(r => r.toString()), i.length > 0) { const r = t.toLowerCase(); this.headers.set(r, i), this.maybeSetNormalizedName(t, r) } }) } : this.headers = new Map } has(n) { return this.init(), this.headers.has(n.toLowerCase()) } get(n) { this.init(); const t = this.headers.get(n.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(n) { return this.init(), this.headers.get(n.toLowerCase()) || null } append(n, t) { return this.clone({ name: n, value: t, op: "a" }) } set(n, t) { return this.clone({ name: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ name: n, value: t, op: "d" }) } maybeSetNormalizedName(n, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, n) } init() { this.lazyInit && (this.lazyInit instanceof vt ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null)) } copyFrom(n) { n.init(), Array.from(n.headers.keys()).forEach(t => { this.headers.set(t, n.headers.get(t)), this.normalizedNames.set(t, n.normalizedNames.get(t)) }) } clone(n) { const t = new vt; return t.lazyInit = this.lazyInit && this.lazyInit instanceof vt ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([n]), t } applyUpdate(n) { const t = n.name.toLowerCase(); switch (n.op) { case "a": case "s": let o = n.value; if ("string" == typeof o && (o = [o]), 0 === o.length) return; this.maybeSetNormalizedName(n.name, t); const i = ("a" === n.op ? this.headers.get(t) : void 0) || []; i.push(...o), this.headers.set(t, i); break; case "d": const r = n.value; if (r) { let s = this.headers.get(t); if (!s) return; s = s.filter(a => -1 === r.indexOf(a)), 0 === s.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, s) } else this.headers.delete(t), this.normalizedNames.delete(t) } } forEach(n) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => n(this.normalizedNames.get(t), this.headers.get(t))) } } class wF { encodeKey(n) { return xv(n) } encodeValue(n) { return xv(n) } decodeKey(n) { return decodeURIComponent(n) } decodeValue(n) { return decodeURIComponent(n) } } const bF = /%(\d[a-f0-9])/gi, EF = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function xv(e) { return encodeURIComponent(e).replace(bF, (n, t) => EF[t] ?? n) } function xa(e) { return `${e}` } class An { constructor(n = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new wF, n.fromString) { if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function DF(e, n) { const t = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(i => { const r = i.indexOf("="), [s, a] = -1 == r ? [n.decodeKey(i), ""] : [n.decodeKey(i.slice(0, r)), n.decodeValue(i.slice(r + 1))], l = t.get(s) || []; l.push(a), t.set(s, l) }), t }(n.fromString, this.encoder) } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(t => { const o = n.fromObject[t], i = Array.isArray(o) ? o.map(xa) : [xa(o)]; this.map.set(t, i) })) : this.map = null } has(n) { return this.init(), this.map.has(n) } get(n) { this.init(); const t = this.map.get(n); return t ? t[0] : null } getAll(n) { return this.init(), this.map.get(n) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(n, t) { return this.clone({ param: n, value: t, op: "a" }) } appendAll(n) { const t = []; return Object.keys(n).forEach(o => { const i = n[o]; Array.isArray(i) ? i.forEach(r => { t.push({ param: o, value: r, op: "a" }) }) : t.push({ param: o, value: i, op: "a" }) }), this.clone(t) } set(n, t) { return this.clone({ param: n, value: t, op: "s" }) } delete(n, t) { return this.clone({ param: n, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(n => { const t = this.encoder.encodeKey(n); return this.map.get(n).map(o => t + "=" + this.encoder.encodeValue(o)).join("&") }).filter(n => "" !== n).join("&") } clone(n) { const t = new An({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat(n), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => { switch (n.op) { case "a": case "s": const t = ("a" === n.op ? this.map.get(n.param) : void 0) || []; t.push(xa(n.value)), this.map.set(n.param, t); break; case "d": if (void 0 === n.value) { this.map.delete(n.param); break } { let o = this.map.get(n.param) || []; const i = o.indexOf(xa(n.value)); -1 !== i && o.splice(i, 1), o.length > 0 ? this.map.set(n.param, o) : this.map.delete(n.param) } } }), this.cloneFrom = this.updates = null) } } class IF { constructor() { this.map = new Map } set(n, t) { return this.map.set(n, t), this } get(n) { return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n) } delete(n) { return this.map.delete(n), this } has(n) { return this.map.has(n) } keys() { return this.map.keys() } } function Mv(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function Fv(e) { return typeof Blob < "u" && e instanceof Blob } function Ov(e) { return typeof FormData < "u" && e instanceof FormData } class yr { constructor(n, t, o, i) { let r; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function TF(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== o ? o : null, r = i) : r = o, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.context && (this.context = r.context), r.params && (this.params = r.params)), this.headers || (this.headers = new vt), this.context || (this.context = new IF), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = t; else { const a = t.indexOf("?"); this.urlWithParams = t + (-1 === a ? "?" : a < t.length - 1 ? "&" : "") + s } } else this.params = new An, this.urlWithParams = t } serializeBody() { return null === this.body ? null : Mv(this.body) || Fv(this.body) || Ov(this.body) || function AF(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof An ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Ov(this.body) ? null : Fv(this.body) ? this.body.type || null : Mv(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof An ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(n = {}) { const t = n.method || this.method, o = n.url || this.url, i = n.responseType || this.responseType, r = void 0 !== n.body ? n.body : this.body, s = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials, a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress; let l = n.headers || this.headers, u = n.params || this.params; const c = n.context ?? this.context; return void 0 !== n.setHeaders && (l = Object.keys(n.setHeaders).reduce((d, p) => d.set(p, n.setHeaders[p]), l)), n.setParams && (u = Object.keys(n.setParams).reduce((d, p) => d.set(p, n.setParams[p]), u)), new yr(t, o, r, { params: u, headers: l, context: c, reportProgress: a, responseType: i, withCredentials: s }) } } var Ve = (() => ((Ve = Ve || {})[Ve.Sent = 0] = "Sent", Ve[Ve.UploadProgress = 1] = "UploadProgress", Ve[Ve.ResponseHeader = 2] = "ResponseHeader", Ve[Ve.DownloadProgress = 3] = "DownloadProgress", Ve[Ve.Response = 4] = "Response", Ve[Ve.User = 5] = "User", Ve))(); class fd { constructor(n, t = 200, o = "OK") { this.headers = n.headers || new vt, this.status = void 0 !== n.status ? n.status : t, this.statusText = n.statusText || o, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300 } } class hd extends fd { constructor(n = {}) { super(n), this.type = Ve.ResponseHeader } clone(n = {}) { return new hd({ headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class Ma extends fd { constructor(n = {}) { super(n), this.type = Ve.Response, this.body = void 0 !== n.body ? n.body : null } clone(n = {}) { return new Ma({ body: void 0 !== n.body ? n.body : this.body, headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class Nv extends fd { constructor(n) { super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url || "(unknown url)"}` : `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null } } function pd(e, n) { return { body: n, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let vr = (() => { class e { constructor(t) { this.handler = t } request(t, o, i = {}) { let r; if (t instanceof yr) r = t; else { let l, u; l = i.headers instanceof vt ? i.headers : new vt(i.headers), i.params && (u = i.params instanceof An ? i.params : new An({ fromObject: i.params })), r = new yr(t, o, void 0 !== i.body ? i.body : null, { headers: l, context: i.context, params: u, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials }) } const s = Aa(r).pipe(function vF(e, n) { return se(n) ? _i(e, n, 1) : _i(e, 1) }(l => this.handler.handle(l))); if (t instanceof yr || "events" === i.observe) return s; const a = s.pipe(function CF(e, n) { return Jt((t, o) => { let i = 0; t.subscribe(At(o, r => e.call(n, r, i++) && o.next(r))) }) }(l => l instanceof Ma)); switch (i.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return a.pipe(Sn(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(Sn(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(Sn(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(Sn(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(t, o = {}) { return this.request("DELETE", t, o) } get(t, o = {}) { return this.request("GET", t, o) } head(t, o = {}) { return this.request("HEAD", t, o) } jsonp(t, o) { return this.request("JSONP", t, { params: (new An).append(o, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, o = {}) { return this.request("OPTIONS", t, o) } patch(t, o, i = {}) { return this.request("PATCH", t, pd(i, o)) } post(t, o, i = {}) { return this.request("POST", t, pd(i, o)) } put(t, o, i = {}) { return this.request("PUT", t, pd(i, o)) } } return e.\u0275fac = function (t) { return new (t || e)(q(Sa)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); function Pv(e, n) { return n(e) } function SF(e, n) { return (t, o) => n.intercept(t, { handle: i => e(i, o) }) } const MF = new B("HTTP_INTERCEPTORS"), Cr = new B("HTTP_INTERCEPTOR_FNS"); function FF() { let e = null; return (n, t) => (null === e && (e = (mo(MF, { optional: !0 }) ?? []).reduceRight(SF, Pv)), e(n, t)) } let kv = (() => { class e extends Sa { constructor(t, o) { super(), this.backend = t, this.injector = o, this.chain = null } handle(t) { if (null === this.chain) { const o = Array.from(new Set(this.injector.get(Cr))); this.chain = o.reduceRight((i, r) => function xF(e, n, t) { return (o, i) => t.runInContext(() => n(o, r => e(r, i))) }(i, r, this.injector), Pv) } return this.chain(t, o => this.backend.handle(o)) } } return e.\u0275fac = function (t) { return new (t || e)(q(dd), q(Xn)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const kF = /^\)\]\}',?\n/; let Rv = (() => { class e { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new Qe(o => { const i = this.xhrFactory.build(); if (i.open(t.method, t.urlWithParams), t.withCredentials && (i.withCredentials = !0), t.headers.forEach((g, C) => i.setRequestHeader(g, C.join(","))), t.headers.has("Accept") || i.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const g = t.detectContentTypeHeader(); null !== g && i.setRequestHeader("Content-Type", g) } if (t.responseType) { const g = t.responseType.toLowerCase(); i.responseType = "json" !== g ? g : "text" } const r = t.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const g = i.statusText || "OK", C = new vt(i.getAllResponseHeaders()), w = function LF(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(i) || t.url; return s = new hd({ headers: C, status: i.status, statusText: g, url: w }), s }, l = () => { let { headers: g, status: C, statusText: w, url: D } = a(), I = null; 204 !== C && (I = typeof i.response > "u" ? i.responseText : i.response), 0 === C && (C = I ? 200 : 0); let F = C >= 200 && C < 300; if ("json" === t.responseType && "string" == typeof I) { const E = I; I = I.replace(kF, ""); try { I = "" !== I ? JSON.parse(I) : null } catch (L) { I = E, F && (F = !1, I = { error: L, text: I }) } } F ? (o.next(new Ma({ body: I, headers: g, status: C, statusText: w, url: D || void 0 })), o.complete()) : o.error(new Nv({ error: I, headers: g, status: C, statusText: w, url: D || void 0 })) }, u = g => { const { url: C } = a(), w = new Nv({ error: g, status: i.status || 0, statusText: i.statusText || "Unknown Error", url: C || void 0 }); o.error(w) }; let c = !1; const d = g => { c || (o.next(a()), c = !0); let C = { type: Ve.DownloadProgress, loaded: g.loaded }; g.lengthComputable && (C.total = g.total), "text" === t.responseType && i.responseText && (C.partialText = i.responseText), o.next(C) }, p = g => { let C = { type: Ve.UploadProgress, loaded: g.loaded }; g.lengthComputable && (C.total = g.total), o.next(C) }; return i.addEventListener("load", l), i.addEventListener("error", u), i.addEventListener("timeout", u), i.addEventListener("abort", u), t.reportProgress && (i.addEventListener("progress", d), null !== r && i.upload && i.upload.addEventListener("progress", p)), i.send(r), o.next({ type: Ve.Sent }), () => { i.removeEventListener("error", u), i.removeEventListener("abort", u), i.removeEventListener("load", l), i.removeEventListener("timeout", u), t.reportProgress && (i.removeEventListener("progress", d), null !== r && i.upload && i.upload.removeEventListener("progress", p)), i.readyState !== i.DONE && i.abort() } }) } } return e.\u0275fac = function (t) { return new (t || e)(q(ty)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); const gd = new B("XSRF_ENABLED"), Vv = new B("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), Bv = new B("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class jv { } let BF = (() => { class e { constructor(t, o, i) { this.doc = t, this.platform = o, this.cookieName = i, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = G_(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return e.\u0275fac = function (t) { return new (t || e)(q(Lt), q(oc), q(Vv)) }, e.\u0275prov = J({ token: e, factory: e.\u0275fac }), e })(); function jF(e, n) { const t = e.url.toLowerCase(); if (!mo(gd) || "GET" === e.method || "HEAD" === e.method || t.startsWith("http://") || t.startsWith("https://")) return n(e); const o = mo(jv).getToken(), i = mo(Bv); return null != o && !e.headers.has(i) && (e = e.clone({ headers: e.headers.set(i, o) })), n(e) } var ke = (() => ((ke = ke || {})[ke.Interceptors = 0] = "Interceptors", ke[ke.LegacyInterceptors = 1] = "LegacyInterceptors", ke[ke.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", ke[ke.NoXsrfProtection = 3] = "NoXsrfProtection", ke[ke.JsonpSupport = 4] = "JsonpSupport", ke[ke.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", ke))(); function ci(e, n) { return { \u0275kind: e, \u0275providers: n } } function HF(...e) { const n = [vr, Rv, kv, { provide: Sa, useExisting: kv }, { provide: dd, useExisting: Rv }, { provide: Cr, useValue: jF, multi: !0 }, { provide: gd, useValue: !0 }, { provide: jv, useClass: BF }]; for (const t of e) n.push(...t.\u0275providers); return function Z1(e) { return { \u0275providers: e } }(n) } const Hv = new B("LEGACY_INTERCEPTOR_FN"); let Uv = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = it({ type: e }), e.\u0275inj = Je({ providers: [HF(ci(ke.LegacyInterceptors, [{ provide: Hv, useFactory: FF }, { provide: Cr, useExisting: Hv, multi: !0 }]))] }), e })(), md = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [oi, ad, ld, Uv, Ia, ud] }) } return e })(); const wr = { production: !0, locales: { nl: { showExplanationLabel: "Toon uitleg bij deze vraag", showOptionExplanationButtonLabel: "Toon uitleg bij dit antwoord", hideExplanationLabel: "Verberg uitleg", previousButtonText: "Vorige", nextButtonText: "Volgende", defaultUnansweredAlertMessage: "Geef antwoord op deze vraag." }, en: { showExplanationLabel: "Show explanation for this question", showOptionExplanationButtonLabel: "Show explanation for this answer", hideExplanationLabel: "Hide explanation", previousButtonText: "Previous", nextButtonText: "Next", defaultUnansweredAlertMessage: "Answer this question." }, fr: { showExplanationLabel: "Montrer l'explication pour cette question", showOptionExplanationButtonLabel: "Montrer l'explication pour cette r\xe9ponse", hideExplanationLabel: "Cacher l'explication", previousButtonText: "Pr\xe9c\xe9dent", nextButtonText: "Suivant", defaultUnansweredAlertMessage: "R\xe9pondez \xe0 cette question." } }, publicApiBaseUrl: "/public-service-api/", apiBaseUrl: "/service-api/" }; function $v(e, n = !1) { const t = { useThousandsSeparator: !0, allowDecimalSeparator: !0, thousandsSeparator: ",", decimalSeparator: "." }; let o = "^(0|"; return "en" === e ? (o += di(t) + "|", t.thousandsSeparator = " ", o += di(t) + "|", t.useThousandsSeparator = !1, o += di(t) + "|") : (t.useThousandsSeparator = !0, t.thousandsSeparator = ".", t.decimalSeparator = ",", o += di(t) + "|", t.thousandsSeparator = " ", o += di(t) + "|", t.useThousandsSeparator = !1, o += di(t) + "|"), new RegExp(o + ")$") } function di(e) { let n = ""; if (e.useThousandsSeparator) switch (e.thousandsSeparator) { case ",": n = "[1-9]\\d{0,2}(,\\d{3})+"; break; case ".": n = "[1-9]\\d{0,2}(\\.\\d{3})+"; break; case " ": n = "[1-9]\\d{0,2}(\\s\\d{3})+" } else n = "[1-9]\\d*"; if (e.allowDecimalSeparator) switch (e.decimalSeparator) { case ",": n += "(,\\d+)?"; break; case ".": n += "(\\.\\d+)?" }return n } let Kt = (() => { class e { constructor() { this.currentLanguage = "nl" } setLanguage(t) { wr.locales.hasOwnProperty(t) && (this.currentLanguage = t) } get locale() { return wr.locales[this.currentLanguage] } getLanguage() { return this.currentLanguage } getNumberRegex() { return $v(this.currentLanguage) } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var V = (() => { return (e = V || (V = {})).BOOLEAN = "BOOLEAN", e.LIST_SINGLE = "LIST_SINGLE", e.LIST_MULTIPLE = "LIST_MULTIPLE", e.TEXT_LINE = "TEXT_LINE", e.TEXT_FIELD = "TEXT_FIELD", e.UPLOAD = "UPLOAD", e.DATE = "DATE", e.DATE_TIME = "DATE_TIME", e.TIME = "TIME", e.NUMBER = "NUMBER", e.DECISIONTABLE = "DECISIONTABLE", V; var e })(); class $F { } var re = (() => { return (e = re || (re = {})).VALID = "VALID", e.PENDING = "PENDING", e.INVALID = "INVALID", re; var e })(); function qv(e, n, t, o) { if (!e.conditionQuestionId) { if (!(e.groupId && o.length > 0)) return !0; { const s = o.find(a => a.dependentGroupId === e.groupId); if (!s) return !0; e = s } } let i = e.conditionAnswerId, r = e.conditionQuestionId; for (; null !== i;) { const s = n.find(a => a.id === r); if (t.hasOwnProperty(r) && null !== t[r]) { const a = t[r]; if ("object" == typeof a) { if (s.type === V.DECISIONTABLE) { if (Object.keys(a).filter(u => a[u] === re.VALID).length > 0 && a[i] === re.INVALID) return !1 } else if (Object.keys(a).filter(u => !0 === a[u]).length > 0 && !1 === a[i]) return !1 } else if (s.type === V.BOOLEAN && (i = "ja" === i), a !== i) return !1 } if (i = null, !s.conditionQuestionId) return !0; i = s.conditionAnswerId, r = s.conditionQuestionId } return !0 } function Gv(e, n) { if (n.type === V.LIST_MULTIPLE) { const t = e[n.id]; if (null === t) return !1; const o = Object.keys(t); for (const i of o) if (!0 === t[i]) return !0; return !1 } return null !== e[n.id] } class qF { constructor(n, t = !1) { this.data = n, this.showDependentQuestions = t } getFormState(n, t) { const o = new $F, i = this.getRelevantQuestions(n); if (o.relevantQuestions = i, o.relevantGroups = this.getRelevantGroups(n), o.completedGroups = this.getCompletedGroups(n, o.relevantQuestions), o.answers = this.resetNotRelevantQuestionAnswers(n, i), o.answeredQuestionsCnt = this.getQuestionsWithAnswersCnt(n, i), 0 === this.data.groups.length) o.formIsComplete = i.length === o.answeredQuestionsCnt; else { let s = !0; for (const a of o.relevantGroups) if (-1 === o.completedGroups.indexOf(a)) { s = !1; break } o.formIsComplete = s } return this.checkAnswerValues(n, t) || (o.formIsComplete = !1), o } getQuestionsWithAnswersCnt(n, t) { let o = 0; if (0 === Object.keys(n).length) return 0; for (const i of t) { const r = this.data.questions.find(s => s.id === i); if (r.type === V.LIST_MULTIPLE) { const s = n[r.id]; if (s) { const a = Object.keys(s); for (const l of a) if (!0 === s[l]) { o++; break } } } else null === n[r.id] || "" === n[r.id] || o++ } return o } getCompletedGroups(n, t) { const o = []; for (const i of this.data.groups) { const r = t.filter(a => this.data.questions.find(l => l.id === a).groupId === i.id); this.getQuestionsWithAnswersCnt(n, r) === r.length && o.push(i.id) } return o } getRelevantQuestions(n) { const t = this.data.questions; if (0 === Object.keys(n).length) return this.showDependentQuestions ? t.map(r => r.id) : t.filter(r => !r.conditionQuestionId).map(r => r.id); const o = []; t.forEach(r => { qv(r, t, n, this.data.groupPlaceholders) && o.push(r) }); let i = []; if (this.showDependentQuestions) i = o.map(r => r.id); else for (const r of o) if (r.conditionQuestionId) { const s = this.data.questions.find(a => a.id === r.conditionQuestionId); s ? Gv(n, s) && i.push(r.id) : i.push(r.id) } else i.push(r.id); return i } getRelevantGroups(n) { const t = this.data.groups; if (0 === Object.keys(n).length) return this.showDependentQuestions ? t.map(r => r.id) : t.filter(r => !this.data.groupPlaceholders.find(s => s.dependentGroupId === r.id)).map(r => r.id); const o = [], i = []; for (const r of t) { const s = this.data.groupPlaceholders.filter(l => l.dependentGroupId === r.id); let a = !1; if (0 === s.length) a = !0; else for (const l of s) { if (-1 !== i.indexOf(l.groupId)) break; if (qv(l, this.data.questions, n, this.data.groupPlaceholders)) { (this.showDependentQuestions || Gv(n, this.data.questions.find(c => c.id === l.conditionQuestionId))) && (a = !0); break } } a ? o.push(r.id) : i.push(r.id) } return o } resetNotRelevantQuestionAnswers(n, t) { const o = JSON.parse(JSON.stringify(n)), i = Object.keys(o); for (const r of this.data.questions) -1 !== i.indexOf(r.id) && -1 === t.indexOf(r.id) && (o[r.id] = null); return o } checkAnswerValues(n, t) { const o = Object.keys(n); for (const i of o) if (this.data.questions.find(s => s.id === i).type === V.NUMBER) { let s = n[i]; if (s = s.trim(), !1 === $v(t).test(s)) return !1 } return !0 } } class Qv { } let _d = (() => { class e { constructor(t) { this.formBuilder = t } buildFormData(t, o, i = !1) { const r = this.formBuilder.group({}); return t.forEach(s => { if (s.type === V.LIST_MULTIPLE) { const a = this.formBuilder.group({}); s.options.forEach(l => { let u = { disabled: i }, c = null; o && o.hasOwnProperty(s.id) && (c = o[s.id]), u.value = !(!c || !c.hasOwnProperty(l.id)) && o[s.id][l.id], a.addControl(l.id, new av(u)) }), r.addControl(s.id, a) } else if (s.type === V.DECISIONTABLE) { const a = this.formBuilder.group({}); s.checkData.outcomes.forEach(l => { a.addControl(l.id, this.formBuilder.control(re.PENDING)) }), r.addControl(s.id, a) } else { let a = { disabled: i }; a.value = o && o.hasOwnProperty(s.id) ? o[s.id] : null, r.addControl(s.id, new av(a)) } }), r } static #e = this.\u0275fac = function (o) { return new (o || e)(q(oF)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function zv(e) { return e <= 0 ? () => Ga : Jt((n, t) => { let o = 0; n.subscribe(At(t, i => { ++o <= e && (t.next(i), e <= o && t.complete()) })) }) } let Wv = (() => { class e { constructor(t) { this.initialAnswers = {}, this.showDependentQuestions = !1, this.initialDecisionAnswers = {}, this.disabled = !1, this.useAccordion = !0, this.allGroupsAvailable = !1, this.cacheAnswers = !0, this.formChange = new Q, this.answerChange = new Q, this.focusedQuestionChange = new Q, this.decisionChange = new Q, this.switchToNextGroup = new Q, this.FormQuestionType = V, this.decisionResults = null, this.decisionAnswers = {}, this.relevantQuestions = [], this.relevantGroups = [], this.completedGroups = [], this.formIsCompleted = !1, this.answersCache = {}, this.decisionAnswersCache = {}, this.formService = t.get(_d), this.localeService = t.get(Kt) } ngOnInit() { } ngOnChanges() { this.formData && this.init() } ngOnDestroy() { this.formValueChangeSubscription && this.formValueChangeSubscription.unsubscribe() } init() { this.formData.groups.length > 0 ? this.setGroup(this.formData.groups[0].id) : this.currentQuestions = this.formData.questions, this.initialAnswers = this.checkAndConvertListAnswers(this.initialAnswers), this.initialAnswers = this.checkAndConvertNoneListAnswers(this.initialAnswers), this.decisionResults = {}, this.decisionAnswers = {}, this.answersCache = {}, this.decisionAnswersCache = {}, this.formData.questions.filter(t => t.type === V.DECISIONTABLE).forEach(t => { this.decisionResults[t.id] = null, this.decisionAnswers[t.id] = this.initialDecisionAnswers && this.initialDecisionAnswers[t.id] ? this.initialDecisionAnswers[t.id] : {} }), this.formGroup = this.formService.buildFormData(this.formData.questions, this.initialAnswers, this.disabled), this.formManager = new qF(this.formData, this.showDependentQuestions), this.updateFormResult(this.initialAnswers), this.formGroup.valueChanges.pipe(zv(1)).subscribe(t => { this.updateFormResult(t) }) } onFocusedQuestionChange(t) { this.focusedQuestionChange.emit(t) } nextGroupExists() { const t = this.relevantGroups.findIndex(o => o === this.currentGroupId); return t > -1 && this.relevantGroups.length > t + 1 } nextGroupIsAvailable() { return !!this.nextGroupExists() && -1 !== this.completedGroups.indexOf(this.currentGroupId) } groupIsAvailable(t) { if (this.allGroupsAvailable) return !0; const o = this.relevantGroups.findIndex(i => i === t); return 0 === o || -1 !== this.completedGroups.indexOf(this.relevantGroups[o - 1]) } setNextGroup() { const t = this.relevantGroups.findIndex(o => o === this.currentGroupId); this.setGroup(this.relevantGroups[t + 1]), this.switchToNextGroup.emit() } setGroup(t) { this.currentGroupId = t, this.currentQuestions = this.formData.questions.filter(o => o.groupId === this.currentGroupId) } toggleGroup(t) { this.currentGroupId === t ? (this.currentGroupId = null, this.currentQuestions = []) : this.currentGroupId = t, this.switchToNextGroup.emit(), this.currentQuestions = this.formData.questions.filter(o => o.groupId === this.currentGroupId) } onAnswerGiven(t) { const o = new Qv; o.questionId = t.questionId; const i = this.formData.questions.find(r => r.id === o.questionId); i.type === V.BOOLEAN ? !0 === t.answer[0] ? (o.optionId = !0, o.optionValue = this.formData.trueLabel) : (o.optionId = !1, o.optionValue = this.formData.falseLabel) : i.type === V.LIST_MULTIPLE ? (o.optionId = t.answer, o.optionValue = t.answer.map(r => i.options.find(s => s.id === r).value)) : i.type === V.LIST_SINGLE ? (o.optionId = t.answer[0], o.optionValue = i.options.find(r => r.id === o.optionId).value) : (o.optionId = null, o.optionValue = t.answer[0]), this.answerChange.emit(o) } onDecisionChange(t) { this.decisionChange.emit(t); const o = t.checkResult; this.decisionResults = {}, this.decisionResults[t.formItemId] = o; const i = {}; o.outcomes.forEach(r => { i[r.id] = r.state }), this.formGroup.get(t.formItemId).setValue(i) } updateFormResult(t) { let o = this.formManager.getFormState(t, this.localeService.getLanguage()); if (this.cacheAnswers) { const i = this.useCachedAnswers(o.answers, o.relevantQuestions); o = this.formManager.getFormState(i, this.localeService.getLanguage()) } this.cacheAnswers && 0 !== Object.keys(t).length && this.updateAnswersCache(t), this.decisionResults && (o.decisionAnswers = {}, Object.keys(this.decisionResults).forEach(i => { this.decisionResults[i] && (o.decisionAnswers[i] = this.decisionResults[i].answers) })), this.relevantQuestions = o.relevantQuestions, this.initEmptyListMultipleAnswers(o.answers), this.formGroup.patchValue(o.answers), this.formIsCompleted = o.formIsComplete, this.relevantGroups = o.relevantGroups, this.completedGroups = o.completedGroups, this.formChange.emit(o), this.formGroup.valueChanges.pipe(zv(1)).subscribe(i => { this.updateFormResult(i) }) } updateAnswersCache(t) { for (const o of this.relevantQuestions) { const i = t[o]; null !== i && (this.answersCache[o] = i) } } useCachedAnswers(t, o) { for (const i of o) null === t[i] && this.answersCache.hasOwnProperty(i) && (t[i] = this.answersCache[i]); return t } initEmptyListMultipleAnswers(t) { for (const o of this.relevantQuestions) if (null === t[o]) { const i = this.formData.questions.find(r => r.id === o); if (i.type === V.LIST_MULTIPLE) { const r = {}; i.options.forEach(s => { r[s.id] = !1 }), t[o] = r } } } checkAndConvertListAnswers(t) { const o = JSON.parse(JSON.stringify(t)), i = this.formData.questions.filter(s => s.type === V.LIST_SINGLE); for (const s of i) if (t.hasOwnProperty(s.id)) { const a = t[s.id]; if (null === a || "string" == typeof a) continue; let l = 0, u = null; a && "object" == typeof a ? (Object.keys(a).forEach(c => { a[c] && (u = c, l++) }), 1 === l ? o[s.id] = u : delete o[s.id]) : console.error(`value ${a} is unexpected as answer for LIST_SINGLE question`) } const r = this.formData.questions.filter(s => s.type === V.LIST_MULTIPLE); for (const s of r) if (t.hasOwnProperty(s.id)) { const a = t[s.id]; if (null === a || "object" == typeof a) continue; if ("string" == typeof a) { let l = {}; s.options.forEach(u => { l[u.id] = !1 }), l[a] = !0, o[s.id] = l } else console.error(`value ${a} is unexpected as answer for LIST_SINGLE question`) } return o } checkAndConvertNoneListAnswers(t) { const o = JSON.parse(JSON.stringify(t)), i = this.formData.questions.filter(r => r.type === V.TEXT_LINE); for (const r of i) t.hasOwnProperty(r.id) && t[r.id] && (o[r.id] = t[r.id].replace(/\n/g, " ")); return o } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["ng-component"]], inputs: { formData: "formData", initialAnswers: "initialAnswers", showDependentQuestions: "showDependentQuestions", initialDecisionAnswers: "initialDecisionAnswers", disabled: "disabled", useAccordion: "useAccordion", allGroupsAvailable: "allGroupsAvailable", cacheAnswers: "cacheAnswers" }, outputs: { formChange: "formChange", answerChange: "answerChange", focusedQuestionChange: "focusedQuestionChange", decisionChange: "decisionChange", switchToNextGroup: "switchToNextGroup" }, features: [Te], decls: 0, vars: 0, template: function (o, i) { }, encapsulation: 2 }) } return e })(); function GF(e, n) { if (1 & e) { const t = R(); y(0, "button", 5), M("click", function () { return S(t), x(m().hide()) }), _() } 2 & e && De("aria-label", m().hideExplanationLabel) } function QF(e, n) { 1 & e && k(0, "div", 6), 2 & e && h("innerHTML", m().content, vn) } function zF(e, n) { if (1 & e && (k(0, "div", 6), Zi(1, "async")), 2 & e) { let o; h("innerHTML", null == (o = Xi(1, 1, m().content$)) ? null : o.toelichting, vn) } } function WF(e, n) { if (1 & e) { const t = R(); y(0, "button", 8), M("click", function () { return S(t), x(m(2).extraContentVisible = !0) }), A(1, " Lees meer "), _() } } function KF(e, n) { 1 & e && k(0, "div", 6), 2 & e && h("innerHTML", m(2).extraContent, vn) } function YF(e, n) { if (1 & e && (k(0, "div", 6), Zi(1, "async")), 2 & e) { let o; h("innerHTML", null == (o = Xi(1, 1, m(2).extraContent$)) ? null : o.toelichting, vn) } } function JF(e, n) { if (1 & e) { const t = R(); y(0, "button", 8), M("click", function () { return S(t), x(m(2).extraContentVisible = !1) }), A(1, " Lees minder "), _() } } function ZF(e, n) { if (1 & e && (Ee(0), v(1, WF, 2, 0, "button", 7), v(2, KF, 1, 1, "div", 3), v(3, YF, 2, 3, "div", 3), v(4, JF, 2, 0, "button", 7), Ie()), 2 & e) { const t = m(); f(1), h("ngIf", !t.extraContentVisible), f(1), h("ngIf", t.extraContentVisible && t.extraContent), f(1), h("ngIf", t.extraContentVisible && t.extraContent$), f(1), h("ngIf", t.extraContentVisible) } } let fi = (() => { class e { constructor(t) { this.localeService = t, this.showHideButton = !0, this.hideMe = new Q, this.extraContentVisible = !1, this.hideExplanationLabel = "" } ngOnInit() { this.hideExplanationLabel = this.localeService.locale.hideExplanationLabel } hide() { this.hideMe.emit() } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-explanation"]], inputs: { content: "content", content$: "content$", extraContent: "extraContent", extraContent$: "extraContent$", showHideButton: "showHideButton" }, outputs: { hideMe: "hideMe" }, decls: 7, vars: 4, consts: [[1, "flo-explanation-i"], ["class", "flo-explanation-hide flo-explanation-button", 3, "click", 4, "ngIf"], [1, "flo-explanation-content"], [3, "innerHTML", 4, "ngIf"], [4, "ngIf"], [1, "flo-explanation-hide", "flo-explanation-button", 3, "click"], [3, "innerHTML"], ["class", "flo-explanation-readmore-toggle-button", "type", "button", 3, "click", 4, "ngIf"], ["type", "button", 1, "flo-explanation-readmore-toggle-button", 3, "click"]], template: function (o, i) { 1 & o && (y(0, "div", 0), A(1, "i"), _(), v(2, GF, 1, 1, "button", 1), y(3, "section", 2), v(4, QF, 1, 1, "div", 3), v(5, zF, 2, 3, "div", 3), v(6, ZF, 5, 4, "ng-container", 4), _()), 2 & o && (f(2), h("ngIf", i.showHideButton), f(2), h("ngIf", i.content), f(1), h("ngIf", i.content$), f(1), h("ngIf", i.extraContent || i.extraContent$)) }, dependencies: [Ue, Mc], encapsulation: 2 }) } return e })(); const XF = ["addListener", "removeListener"], eO = ["addEventListener", "removeEventListener"], tO = ["on", "off"]; function Fa(e, n, t, o) { if (se(t) && (o = t, t = void 0), o) return Fa(e, n, t).pipe(Ay(o)); const [i, r] = function iO(e) { return se(e.addEventListener) && se(e.removeEventListener) }(e) ? eO.map(s => a => e[s](n, a, t)) : function nO(e) { return se(e.addListener) && se(e.removeListener) }(e) ? XF.map(Kv(e, n)) : function oO(e) { return se(e.on) && se(e.off) }(e) ? tO.map(Kv(e, n)) : []; if (!i && qa(e)) return _i(s => Fa(s, n, t))(St(e)); if (!i) throw new TypeError("Invalid event target"); return new Qe(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return i(a), () => r(a) }) } function Kv(e, n) { return t => o => e[t](n, o) } function sO(e, n) { if (1 & e && k(0, "input", 7), 2 & e) { const t = m(2); h("name", t.questionId)("value", t.option.id)("formControl", t.control) } } function aO(e, n) { if (1 & e && k(0, "input", 8), 2 & e) { const t = m(2); h("formControl", t.control)("name", t.questionId)("value", t.option.id) } } const lO = function (e) { return { "flo-explanation-button-active": e } }; function uO(e, n) { if (1 & e) { const t = R(); y(0, "button", 9), M("click", function () { return S(t), x(m(2).explanationIsVisible = !0) }), _() } if (2 & e) { const t = m(2); h("ngClass", Se(2, lO, t.explanationIsVisible)), De("aria-label", t.showOptionExplanationButtonLabel) } } function cO(e, n) { if (1 & e) { const t = R(); y(0, "div", 10)(1, "app-explanation", 11), M("hideMe", function () { return S(t), x(m(2).explanationIsVisible = !1) }), _()() } if (2 & e) { const t = m(2); f(1), h("content", t.option.explanation.content)("content$", t.option.explanation.content$ || null)("extraContent", t.option.explanation.extraContent || "")("extraContent$", t.option.explanation.extraContent$ || null)("showHideButton", !t.option.explanation.showImmediately) } } function dO(e, n) { if (1 & e && (y(0, "div", 1)(1, "div", 2)(2, "label"), v(3, sO, 1, 3, "input", 3), v(4, aO, 1, 3, "input", 4), A(5), _(), v(6, uO, 1, 4, "button", 5), _(), v(7, cO, 2, 5, "div", 6), _()), 2 & e) { const t = m(); h("formGroup", t.group), f(3), h("ngIf", "checkbox" === t.inputType), f(1), h("ngIf", "radio" === t.inputType), f(1), _t(" ", t.option.value, " "), f(1), h("ngIf", t.showExplanations && t.option.explanation && t.option.explanation.content && !t.option.explanation.showImmediately), f(1), h("ngIf", t.showExplanations && t.option.explanation && t.explanationIsVisible) } } let Yv = (() => { class e { constructor(t) { this.localeService = t, this.showExplanations = !0, this.showOptionExplanationButtonLabel = "", this.explanationIsVisible = !1, this.extraExplanationIsVisible = !1 } ngOnInit() { } ngOnChanges() { this.explanation = this.option.explanation || null, this.showOptionExplanationButtonLabel = this.localeService.locale.showOptionExplanationButtonLabel, this.explanation && (this.explanationIsVisible = this.explanation.showImmediately) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-preview-option"]], inputs: { group: "group", control: "control", questionId: "questionId", inputType: "inputType", option: "option", showExplanations: "showExplanations" }, features: [Te], decls: 1, vars: 1, consts: [[3, "formGroup", 4, "ngIf"], [3, "formGroup"], [1, "flo-question-answers-option"], ["type", "checkbox", 3, "name", "value", "formControl", 4, "ngIf"], ["type", "radio", 3, "formControl", "name", "value", 4, "ngIf"], ["class", "flo-option-explanation-show flo-explanation-button", "type", "button", 3, "ngClass", "click", 4, "ngIf"], ["class", "flo-explanation-container flo-option-explanation", 4, "ngIf"], ["type", "checkbox", 3, "name", "value", "formControl"], ["type", "radio", 3, "formControl", "name", "value"], ["type", "button", 1, "flo-option-explanation-show", "flo-explanation-button", 3, "ngClass", "click"], [1, "flo-explanation-container", "flo-option-explanation"], [3, "content", "content$", "extraContent", "extraContent$", "showHideButton", "hideMe"]], template: function (o, i) { 1 & o && v(0, dO, 8, 6, "div", 0), 2 & o && h("ngIf", i.option) }, dependencies: [zt, Ue, co, Tn, li, Bn, jn, _r, Hn, fi], encapsulation: 2 }) } return e })(); const fO = ["questionContainer"]; function hO(e, n) { if (1 & e) { const t = R(); y(0, "div", 9)(1, "app-explanation", 10), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } const pO = function (e) { return { "flo-explanation-button-active": e } }; function gO(e, n) { if (1 & e) { const t = R(); y(0, "button", 11), M("click", function () { return S(t), x(m().toggleExplanation()) }), _() } if (2 & e) { const t = m(); h("ngClass", Se(2, pO, t.question.explanation && !0 === t.explanationIsVisible)), De("aria-label", t.showExplanationButtonLabel) } } function mO(e, n) { if (1 & e) { const t = R(); y(0, "div", 12)(1, "app-explanation", 10), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } function _O(e, n) { if (1 & e && (y(0, "div", 13)(1, "label", 14), k(2, "input", 15), A(3), _(), y(4, "label", 16), k(5, "input", 15), A(6), _()()), 2 & e) { const t = m(); f(1), qe("id", t.questionIdAttr + "yes"), f(1), qe("name", t.question.id), h("value", !0)("formControlName", t.question.id), De("name", t.question.id), f(1), j(t.trueLabel), f(2), qe("name", t.question.id), h("value", !1)("formControlName", t.question.id), De("name", t.question.id), f(1), j(t.falseLabel) } } function yO(e, n) { if (1 & e && (y(0, "option", 20), A(1), _()), 2 & e) { const t = n.$implicit; h("ngValue", t.id), f(1), _t("", t.value, " ") } } function vO(e, n) { if (1 & e && (y(0, "div", 13)(1, "select", 17), A(2), k(3, "option", 18), v(4, yO, 2, 2, "option", 19), _()()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id), f(1), _t(' attr.aria-labelledby="', t.questionIdAttr, '" '), f(1), h("ngValue", null), f(1), h("ngForOf", t.question.options) } } function CO(e, n) { if (1 & e && (Ee(0), k(1, "app-preview-option", 22), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("questionId", o.question.id)("group", o.formGroup)("control", o.getControl(o.formGroup, o.question.id))("option", t) } } function wO(e, n) { if (1 & e && (y(0, "div", 13), v(1, CO, 2, 4, "ng-container", 21), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function DO(e, n) { if (1 & e && k(0, "input", 24), 2 & e) { const t = m().$implicit, o = m(2); h("value", t.id)("formControl", o.getCheckBoxControl(t.id)) } } function bO(e, n) { if (1 & e && k(0, "input", 24), 2 & e) { const t = m().$implicit, o = m(2); h("value", t.id)("formControl", o.getCheckBoxControl(t.id)) } } function EO(e, n) { if (1 & e && (y(0, "div")(1, "label", 14), v(2, DO, 1, 2, "input", 23), v(3, bO, 1, 2, "input", 23), A(4), _()()), 2 & e) { const t = n.$implicit, o = n.index, i = m(2); f(1), qe("id", i.questionIdAttr + "firstcheckbox"), f(1), h("ngIf", 0 === o), f(1), h("ngIf", o > 0), f(1), j(t.value) } } function IO(e, n) { if (1 & e && (y(0, "div", 13), v(1, EO, 5, 4, "div", 21), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function TO(e, n) { if (1 & e && (Ee(0), k(1, "app-preview-option", 25), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("questionId", o.question.id)("group", o.formGroup)("control", o.getControl(o.getGroup(o.formGroup, o.question.id), t.id))("option", t) } } function AO(e, n) { if (1 & e && (y(0, "div", 13), v(1, TO, 2, 4, "ng-container", 21), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function SO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "input", 26), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function xO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "textarea", 27), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function MO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "input", 28), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id)("pattern", t.numberRegex) } } function FO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "input", 29), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function OO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "input", 29), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function NO(e, n) { if (1 & e && (y(0, "div", 13), k(1, "input", 30), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function PO(e, n) { if (1 & e) { const t = R(); y(0, "div", 12)(1, "app-explanation", 10), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } const kO = function (e) { return { pristine: e } }; let yd = (() => { class e { constructor(t) { this.localeService = t, this.trueLabel = "ja", this.falseLabel = "nee", this.listOptionsWithExplanation = !1, this.QuestionType = V, this.explanationIsVisible = !1, this.answerGiven = new Q, this.focus = new Q, this.showExplanationButtonLabel = "" } ngOnInit() { this.questionIdAttr = "_" + this.question.id, this.showExplanationButtonLabel = this.localeService.locale.showExplanationLabel, this.question.explanation && (this.explanationIsVisible = this.question.explanation.showImmediately), this.numberRegex = this.localeService.getNumberRegex() } ngAfterViewInit() { this.changeSubscription = Fa(this.questionContainer.nativeElement, "focusout").pipe(function rO(...e) { const n = Zd(e); return Jt((t, o) => { const i = e.length, r = new Array(i); let s = e.map(() => !1), a = !1; for (let l = 0; l < i; l++)St(e[l]).subscribe(At(o, u => { r[l] = u, !a && !s[l] && (s[l] = !0, (a = s.every(Ba)) && (s = null)) }, Na)); t.subscribe(At(o, l => { if (a) { const u = [l, ...r]; o.next(n ? n(...u) : u) } })) }) }(this.formGroup.controls[this.question.id].valueChanges)).subscribe(([t, o]) => { if (null === o) return; let i; i = this.question.type === V.LIST_MULTIPLE ? Object.keys(o).filter(r => !0 === o[r]) : [o], this.answerGiven.emit({ questionId: this.question.id, answer: i }) }), this.focusInSubscription = Fa(this.questionContainer.nativeElement, "focusin").subscribe(t => { const o = { questionId: this.question.id, optionId: null }; "checkbox" === t.target.type && !1 === t.target.checked && (o.optionId = t.target.value), this.focus.emit(o) }) } hasAnswer() { const t = this.formGroup.getRawValue(); return this.question.type === V.LIST_MULTIPLE ? 0 !== Object.keys(t[this.question.id]).filter(o => !1 !== t[this.question.id][o]).length : null !== t[this.question.id] } getControl(t, o) { return t.controls[o] } getGroup(t, o) { return t.controls[o] } getCheckBoxControl(t) { return this.formGroup.controls[this.question.id].controls[t] } toggleExplanation() { this.explanationIsVisible = !this.explanationIsVisible } ngOnDestroy() { this.changeSubscription && this.changeSubscription.unsubscribe(), this.focusInSubscription && this.focusInSubscription.unsubscribe() } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-form-question"]], viewQuery: function (o, i) { if (1 & o && so(fO, 5), 2 & o) { let r; ro(r = ao()) && (i.questionContainer = r.first) } }, inputs: { question: "question", formGroup: "formGroup", trueLabel: "trueLabel", falseLabel: "falseLabel", listOptionsWithExplanation: "listOptionsWithExplanation" }, outputs: { answerGiven: "answerGiven", focus: "focus" }, decls: 22, vars: 21, consts: [[1, "flo-question-section", 3, "ngClass"], ["class", "flo-explanation-container explanation-at-top", 4, "ngIf"], ["tabindex", "0", 1, "flo-question-container", 3, "formGroup"], ["questionContainer", ""], [1, "flo-question-description-container"], [1, "flo-question-description", 3, "id"], ["class", "flo-explanation-show flo-explanation-button", "type", "button", 3, "ngClass", "click", 4, "ngIf"], ["class", "flo-explanation-container", 4, "ngIf"], ["class", "flo-question-answers", 4, "ngIf"], [1, "flo-explanation-container", "explanation-at-top"], [3, "content", "extraContent", "showHideButton", "hideMe"], ["type", "button", 1, "flo-explanation-show", "flo-explanation-button", 3, "ngClass", "click"], [1, "flo-explanation-container"], [1, "flo-question-answers"], [3, "id"], ["type", "radio", 3, "name", "value", "formControlName"], [1, "flo-boolean-false"], [3, "formControlName"], ["disabled", "", "hidden", "", 3, "ngValue"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"], [4, "ngFor", "ngForOf"], ["inputType", "radio", 3, "questionId", "group", "control", "option"], ["type", "checkbox", 3, "value", "formControl", 4, "ngIf"], ["type", "checkbox", 3, "value", "formControl"], ["inputType", "checkbox", 3, "questionId", "group", "control", "option"], ["type", "text", 3, "formControlName"], ["rows", "4", 3, "formControlName"], ["type", "text", "inputmode", "numeric", 3, "formControlName", "pattern"], ["type", "date", 3, "formControlName"], ["type", "time", 3, "formControlName"]], template: function (o, i) { 1 & o && (y(0, "div", 0), v(1, hO, 2, 3, "div", 1), y(2, "fieldset", 2, 3)(4, "div", 4)(5, "legend", 5)(6, "span"), A(7), _(), v(8, gO, 1, 4, "button", 6), _()(), v(9, mO, 2, 3, "div", 7), v(10, _O, 7, 11, "div", 8), v(11, vO, 5, 4, "div", 8), v(12, wO, 2, 1, "div", 8), v(13, IO, 2, 1, "div", 8), v(14, AO, 2, 1, "div", 8), v(15, SO, 2, 1, "div", 8), v(16, xO, 2, 1, "div", 8), v(17, MO, 2, 2, "div", 8), v(18, FO, 2, 1, "div", 8), v(19, OO, 2, 1, "div", 8), v(20, NO, 2, 1, "div", 8), _(), v(21, PO, 2, 3, "div", 7), _()), 2 & o && (h("ngClass", Se(19, kO, !i.hasAnswer())), f(1), h("ngIf", i.question.explanation && "top" === i.question.explanation.position && i.explanationIsVisible), f(1), h("formGroup", i.formGroup), f(3), qe("id", i.questionIdAttr), f(2), j(i.question.questionText), f(1), h("ngIf", i.question.explanation && !i.question.explanation.showImmediately && !i.explanationIsVisible), f(1), h("ngIf", i.question.explanation && "middle" === i.question.explanation.position && i.explanationIsVisible), f(1), h("ngIf", i.question.type === i.QuestionType.BOOLEAN), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_SINGLE && !i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_SINGLE && i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_MULTIPLE && !i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_MULTIPLE && i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.TEXT_LINE), f(1), h("ngIf", i.question.type === i.QuestionType.TEXT_FIELD), f(1), h("ngIf", i.question.type === i.QuestionType.NUMBER), f(1), h("ngIf", i.question.type === i.QuestionType.DATE), f(1), h("ngIf", i.question.type === i.QuestionType.DATE_TIME), f(1), h("ngIf", i.question.type === i.QuestionType.TIME), f(1), h("ngIf", i.question.explanation && "bottom" === i.question.explanation.position && i.explanationIsVisible)) }, dependencies: [zt, ct, Ue, Da, ba, co, Tn, ui, li, Bn, jn, Ea, _r, Hn, wa, fi, Yv] }) } return e })(); class LO { constructor() { this.outcomes = [], this.relevantQuestions = [] } } var hi = (() => { return (e = hi || (hi = {})).DECISION = "DECISION", e.CHECK = "CHECK", e.ASSESSMENT = "ASSESSMENT", hi; var e })(), be = (() => { return (e = be || (be = {})).BOOLEAN = "BOOLEAN", e.LIST_SINGLE = "LIST_SINGLE", e.LIST_MULTIPLE = "LIST_MULTIPLE", be; var e })(); class UO { constructor(n) { this.currentOutcomesPerQuestion = {}, this.maximumScore = 0, this.type = n.type, this.questions = n.questions, this.outcomes = n.outcomes, this.questionIds = this.questions.map(t => t.id), this.answerCombinationsPerOutcome = new Map, this.outcomes.forEach(t => { this.answerCombinationsPerOutcome.set(t.id, t.answercombinations) }), n.type === hi.ASSESSMENT && (this.maximumScore = this.computeMaximumScore()) } execute(n, t = new Map) { n = this.filterAnswers(n); const o = new LO; this.type === hi.ASSESSMENT && (o.score = function RO(e, n) { let t = 0; for (const o of e) if (o.answerScores) { const i = n[o.id]; if (i) for (const r of i) t += o.answerScores.find(s => s.id === r).value } return t }(this.questions, n), o.scoreAsPercentage = 0 === this.maximumScore ? 0 : Math.round(o.score / this.maximumScore * 100)); const i = new Set; this.outcomes.forEach(s => { let a, l = null; if ("check" === s.type) { const c = function jO(e, n) { const t = []; for (const o of e) { let i = re.VALID; const r = o.answers; for (const s of Object.keys(r)) if (n[s] && 0 !== n[s].length) { if (-1 === n[s].indexOf(r[s])) { i = re.INVALID; break } } else i = re.PENDING; if (i === re.VALID) return [re.VALID, o.id]; t.push(i) } for (const o of t) if (o === re.PENDING) return [re.PENDING, null]; return [re.INVALID, null] }(s.answercombinations, n); a = c[0], l = c[1], a === re.VALID && i.add(s.id) } else a = re.PENDING; const u = { id: s.id, type: s.type, state: a }; s.isDynamic && t.has(s.id) && (u.formResult = t.get(s.id)), null !== l && (u.answercombinationId = l), o.outcomes.push(u) }); const r = function HO(e, n, t, o) { const i = new Set; for (const r of Array.from(n.keys())) { const s = n.get(r); for (const a of s) { const l = a.answers; let u = !0; const c = [], d = []; for (const p of t) l.hasOwnProperty(p) && d.push(p); for (const p of d) if (c.push(p), e[p] && -1 === e[p].indexOf(l[p])) { u = !1; for (const g of c) i.add(g); break } u && Object.keys(l).forEach(p => { o.has(r) && !e[p] || i.add(p) }) } } return i }(n, this.answerCombinationsPerOutcome, this.questionIds, i); if (this.type === hi.ASSESSMENT) for (const s of this.questions) s.answerScores && r.add(s.id); if (o.relevantQuestions = Array.from(r), o.checkIsComplete = this.checkIsComplete(n, o), o.checkIsComplete) { this.outcomes.filter(a => "score" === a.type).forEach(a => { o.outcomes.find(l => l.id === a.id).state = function BO(e, n, t) { let o = re.PENDING; return "percentage" === e.scoreType && (n = 0 === t ? 0 : Math.round(n / t * 100)), n >= e.scoreMinimum && n <= e.scoreMaximum && (o = re.VALID), o }(a, o.score, this.maximumScore) }); const s = this.outcomes.find(a => "rest" === a.type); s && (o.outcomes.find(a => a.id === s.id).state = function VO(e, n) { for (const t of e) if (t.state === re.VALID) return re.INVALID; if (n) { let t = !0; for (const o of e) o.state !== re.INVALID && (t = !1); if (t) return re.VALID } return re.PENDING }(o.outcomes.filter(a => "check" === a.type), o.checkIsComplete)) } return o.answers = n, o } getOutcomesForQuestion(n, t) { const o = []; return n.outcomes.forEach(i => { if (i.state === re.VALID && "check" === i.type) { const r = this.outcomes.find(l => l.id === i.id), s = r.answercombinations.find(l => l.id === i.answercombinationId), a = []; for (const l of this.questions) s.answers.hasOwnProperty(l.id) && a.push(l.id); a.length > 0 && a[a.length - 1] === t && o.push(r) } }), o } filterAnswers(n) { return n } checkIsComplete(n, t) { for (const i of t.outcomes) if (i.state === re.VALID && (i.formResult && !1 === i.formResult.formIsComplete || null === i.formResult)) return !1; const o = Object.keys(n).filter(i => n[i].length > 0); for (const i of Array.from(t.relevantQuestions)) if (-1 === o.indexOf(i)) return !1; return !0 } computeMaximumScore() { let n = 0; for (const t of this.questions) if (t.answerScores) { if (t.type === be.BOOLEAN && (n += t.answerScores.find(o => !0 === o.id).value), t.type === be.LIST_MULTIPLE) for (const o of t.answerScores) n += o.value; if (t.type === be.LIST_SINGLE) { let o = 0; for (const i of t.answerScores) i.value > o && (o = i.value); n += o } } return n } } var ve = (() => { return (e = ve || (ve = {})).LIST = "list", e.LIST_CUMULATIVE = "list-cumulative", e.ONE_BY_ONE = "one-by-one", e.ONE_BY_ONE_MANUALLY = "one-by-one-manually", ve; var e })(); const $O = [ve.LIST.toString(), ve.LIST_CUMULATIVE.toString(), ve.ONE_BY_ONE.toString(), ve.ONE_BY_ONE_MANUALLY.toString()]; var Dr = (() => { return (e = Dr || (Dr = {})).PREVIOUS = "previous", e.NEXT = "next", Dr; var e })(); let Oa = (() => { class e { constructor() { this.previousButtonVisible = !1, this.nextButtonVisible = !1, this.nextButtonEnabled = !1, this.showOutcomesPerQuestion = !1, this.previousButtonText = "", this.nextButtonText = "", this.nextClicked$ = new qn, this.previousClicked$ = new qn } next() { this.nextClicked$.next() } previous() { console.log("BUTTON CLICKED"), this.previousClicked$.next() } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac }) } return e })(); function Jv(e) { return Jt((n, t) => { let r, o = null, i = !1; o = n.subscribe(At(t, void 0, void 0, s => { r = St(e(s, Jv(e)(n))), o ? (o.unsubscribe(), o = null, r.subscribe(t)) : i = !0 })), i && (o.unsubscribe(), o = null, r.subscribe(t)) }) } let qO = (() => { class e { constructor(t) { this.httpClient = t, this.forms = [], this.customContentBaseUrl = "" } setCustomContentBaseUrl(t) { this.customContentBaseUrl = t } getDynamicOutcomeContent(t, o) { const i = {}; return t.outcomes.filter(r => r.isDynamic).forEach(r => { const s = this.forms.find(a => a.outcomeId === r.id); s.isNeeded && s.formResult && s.formResult.formIsComplete && (i[r.id] = this.getCustomOutcomeContent(r, t, o).pipe(Jv(a => (console.error(a), Aa({ html: "ER GING IETS FOUT: dynamiche content kon niet opgehaald worden" }))))) }), $c(i) } getFormResults() { const t = new Map; return this.forms.forEach(o => { t.set(o.outcomeId, o.formResult) }), t } setFormResult(t, o) { this.forms.find(r => r.outcomeId === t).formResult = o } initFormsForDynamicOutcomes(t, o) { this.forms = []; for (const i of t.outcomes) i.isDynamic && i.formData && this.forms.push({ formData: i.formData, formResult: null, initialAnswers: o[i.id] || {}, isNeeded: !1, outcomeId: i.id }) } setVisibilityOfDynamicForms(t, o) { t.outcomes.forEach(i => { i.isDynamic && i.formData && (o.outcomes.find(s => s.id === i.id).state === re.VALID ? this.forms.find(a => a.outcomeId === i.id).isNeeded = !0 : this.forms.find(s => s.outcomeId === i.id).isNeeded = !1) }) } getCustomOutcomeContent(t, o, i) { if (!t.endpoint) return console.error("Cannot fetch custom outcome: property endpoint is missing on outcome" + t.name), Aa(""); const r = this.forms.find(a => a.outcomeId === t.id); return r ? this.httpClient.post(this.customContentBaseUrl + t.endpoint, this.getPropertiesForEndpoint(r.formData, r.formResult, o, i)) : (console.error("Cannot fetch custom outcome: no form found for outcome " + t.name), Aa("")) } getPropertiesForEndpoint(t, o, i, r) { const s = {}; for (const a of t.questions) a.identifierForDynamicEndpoint && (o.answers[a.id] ? s[a.identifierForDynamicEndpoint] = o.answers[a.id] : console.error(`value for form question ${a.identifierForDynamicEndpoint} missing for endpoint`)); for (const a of i.questions) a.identifierForDynamicEndpoint && (r.answers[a.id] ? s[a.identifierForDynamicEndpoint] = this.getCheckAnswerValue(a, r.answers[a.id]) : console.error(`value for check question ${a.identifierForDynamicEndpoint} missing for endpoint`)); return s } getCheckAnswerValue(t, o) { if (t.type === be.BOOLEAN) return o[0]; { const i = t.options; return t.type === be.LIST_SINGLE ? i.find(s => s.id === o[0]).value : t.type === be.LIST_MULTIPLE ? o.map(r => i.find(a => a.id === r).value) : "" } } static #e = this.\u0275fac = function (o) { return new (o || e)(q(vr)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function GO(e, n) { return { type: 7, name: e, definitions: n, options: {} } } function Zv(e, n = null) { return { type: 4, styles: n, timings: e } } function vd(e) { return { type: 6, styles: e, offset: null } } function Xv(e, n, t = null) { return { type: 1, expr: e, animation: n, options: t } } const tC = function (e) { return { "flo-inner-visibility-hidden": e } }; function QO(e, n) { if (1 & e) { const t = R(); y(0, "button", 3), M("click", function () { return S(t), x(m().dns.next()) }), A(1), _() } if (2 & e) { const t = m(); h("ngClass", Se(3, tC, !t.dns.nextButtonVisible))("disabled", !t.dns.nextButtonEnabled), f(1), _t("", t.dns.nextButtonText, " ") } } let nC = (() => { class e { constructor(t) { this.dns = t } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Oa)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-decision-nav"]], decls: 4, vars: 5, consts: [[1, "flo-nav"], ["type", "button", 1, "flo-form-button", "flo-form-button-previous", 3, "ngClass", "click"], ["type", "button", "class", "flo-form-button flo-form-button-next", 3, "ngClass", "disabled", "click", 4, "ngIf"], ["type", "button", 1, "flo-form-button", "flo-form-button-next", 3, "ngClass", "disabled", "click"]], template: function (o, i) { 1 & o && (y(0, "nav", 0)(1, "button", 1), M("click", function () { return i.dns.previous() }), A(2), _(), v(3, QO, 2, 5, "button", 2), _()), 2 & o && (f(1), h("ngClass", Se(3, tC, !i.dns.previousButtonVisible)), f(1), _t("", i.dns.previousButtonText, " "), f(1), h("ngIf", i.dns.nextButtonEnabled && !0 === i.dns.showOutcomesPerQuestion || !1 === i.dns.showOutcomesPerQuestion)) }, dependencies: [zt, Ue] }) } return e })(); function zO(e, n) { if (1 & e && (y(0, "h3", 11), A(1), _()), 2 & e) { const t = m(); f(1), j(t.question.header) } } function WO(e, n) { if (1 & e) { const t = R(); y(0, "div", 12)(1, "app-explanation", 13), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } const Cd = function (e) { return { "flo-explanation-button-active": e } }; function KO(e, n) { if (1 & e) { const t = R(); y(0, "button", 14), M("click", function () { return S(t), x(m().toggleExplanation()) }), _() } if (2 & e) { const t = m(); h("ngClass", Se(2, Cd, t.question.explanation && !0 === t.explanationIsVisible)), De("aria-label", t.showExplanationButtonLabel) } } function YO(e, n) { if (1 & e) { const t = R(); y(0, "div", 12)(1, "app-explanation", 13), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } function JO(e, n) { if (1 & e && (y(0, "div", 15), k(1, "span", 16), y(2, "span", 17), A(3), _()()), 2 & e) { const t = m(); f(3), j(t.alertMessage) } } function ZO(e, n) { if (1 & e) { const t = R(); y(0, "div", 18)(1, "label", 19)(2, "input", 20), M("ngModelChange", function (i) { return S(t), x(m().booleanAnswer = i) })("keydown", function (i) { S(t); const r = m(), s = kt(2); return x(r.onRadioInputKeyDown(i, s)) })("ngModelChange", function () { return S(t), x(m().answerChanged()) }), _(), A(3), _(), y(4, "label", 21)(5, "input", 20), M("ngModelChange", function (i) { return S(t), x(m().booleanAnswer = i) })("keydown", function (i) { S(t); const r = m(), s = kt(2); return x(r.onRadioInputKeyDown(i, s)) })("ngModelChange", function () { return S(t), x(m().answerChanged()) }), _(), A(6), _()() } if (2 & e) { const t = m(); f(1), qe("id", t.questionIdAttr + "yes"), f(1), qe("name", t.question.id), h("value", !0)("ngModel", t.booleanAnswer)("disabled", t.disabled), De("name", t.question.id), f(1), j(t.trueLabel), f(2), qe("name", t.question.id), h("value", !1)("ngModel", t.booleanAnswer)("disabled", t.disabled), De("name", t.question.id), f(1), j(t.falseLabel) } } function XO(e, n) { if (1 & e && (y(0, "option", 26), A(1), _()), 2 & e) { const t = n.$implicit; h("ngValue", t.id), f(1), j(t.value) } } function eN(e, n) { if (1 & e) { const t = R(); y(0, "select", 23), M("ngModelChange", function (i) { return S(t), x(m(2).listSingleAnswer = i) })("ngModelChange", function () { return S(t), x(m(2).answerChanged()) }), k(1, "option", 24), v(2, XO, 2, 2, "option", 25), _() } if (2 & e) { const t = m(2); qe("name", t.question.id), h("ngModel", t.listSingleAnswer)("disabled", t.disabled), De("aria-labelledby", t.questionIdAttr)("name", t.question.id), f(2), h("ngForOf", t.question.options) } } function tN(e, n) { if (1 & e) { const t = R(); y(0, "button", 32), M("click", function () { S(t); const i = m().$implicit; return x(m(3).toggleOptionExplanation(i.id)) }), _() } if (2 & e) { const t = m().$implicit, o = m(3); h("ngClass", Se(2, Cd, t.explanation && !0 === o.visibilityOptionExplanations.get(t.id))), De("aria-label", o.showOptionExplanationButtonLabel) } } function nN(e, n) { if (1 & e) { const t = R(); y(0, "div", 33)(1, "app-explanation", 13), M("hideMe", function () { S(t); const i = m().$implicit; return x(m(3).visibilityOptionExplanations.set(i.id, !1)) }), _()() } if (2 & e) { const t = m().$implicit; f(1), h("content", t.explanation.content)("extraContent", t.explanation.extraContent || "")("showHideButton", !t.explanation.showImmediately) } } function oN(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "div", 28)(2, "label")(3, "input", 29), M("ngModelChange", function (i) { return S(t), x(m(3).listSingleAnswer = i) })("keydown", function (i) { S(t); const r = m(3), s = kt(2); return x(r.onRadioInputKeyDown(i, s)) })("ngModelChange", function () { return S(t), x(m(3).answerChanged()) }), _(), A(4), _(), v(5, tN, 1, 4, "button", 30), _(), v(6, nN, 2, 3, "div", 31), _() } if (2 & e) { const t = n.$implicit, o = m(3); f(3), qe("name", o.question.id), h("value", t.id)("ngModel", o.listSingleAnswer)("disabled", o.disabled), De("name", o.question.id), f(1), j(t.value), f(1), h("ngIf", t.explanation && t.explanation.content && !t.explanation.showImmediately), f(1), h("ngIf", t.explanation && !0 === o.visibilityOptionExplanations.get(t.id)) } } function iN(e, n) { if (1 & e && (Ee(0), v(1, oN, 7, 8, "div", 27), Ie()), 2 & e) { const t = m(2); f(1), h("ngForOf", t.question.options) } } function rN(e, n) { if (1 & e && (y(0, "div", 18), v(1, eN, 3, 6, "select", 22), v(2, iN, 2, 1, "ng-container", 10), _()), 2 & e) { const t = m(); f(1), h("ngIf", !t.question.displayType || "Dropdown" === t.question.displayType), f(1), h("ngIf", t.question.displayType && "List" === t.question.displayType) } } function sN(e, n) { if (1 & e) { const t = R(); y(0, "button", 32), M("click", function () { S(t); const i = m().$implicit; return x(m(2).toggleOptionExplanation(i.id)) }), _() } if (2 & e) { const t = m().$implicit, o = m(2); h("ngClass", Se(2, Cd, t.explanation && !0 === o.visibilityOptionExplanations.get(t.id))), De("aria-label", o.showOptionExplanationButtonLabel) } } function aN(e, n) { if (1 & e) { const t = R(); y(0, "div", 33)(1, "app-explanation", 13), M("hideMe", function () { S(t); const i = m().$implicit; return x(m(2).visibilityOptionExplanations.set(i.id, !1)) }), _()() } if (2 & e) { const t = m().$implicit; f(1), h("content", t.explanation.content)("extraContent", t.explanation.extraContent || "")("showHideButton", !t.explanation.showImmediately) } } function lN(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "div", 28)(2, "label")(3, "input", 34), M("ngModelChange", function (i) { const s = S(t).$implicit; return x(m(2).answerToggled(i, s.id)) }), _(), A(4), _(), v(5, sN, 1, 4, "button", 30), _(), v(6, aN, 2, 3, "div", 31), _() } if (2 & e) { const t = n.$implicit, o = m(2); f(3), Ms("name", "group-", o.question.id, ""), h("value", t.id)("ngModel", o.listAnswers.get(t.id))("disabled", !!o.disabledListAnswers.get(t.id) || o.disabled), De("name", o.question.id), f(1), j(t.value), f(1), h("ngIf", t.explanation && t.explanation.content && !t.explanation.showImmediately), f(1), h("ngIf", t.explanation && !0 === o.visibilityOptionExplanations.get(t.id)) } } function uN(e, n) { if (1 & e && (y(0, "div", 18), v(1, lN, 7, 8, "div", 27), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function cN(e, n) { 1 & e && k(0, "app-decision-nav") } function dN(e, n) { if (1 & e) { const t = R(); y(0, "div", 12)(1, "app-explanation", 13), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("showHideButton", !t.question.explanation.showImmediately) } } const fN = function (e) { return { pristine: e } }, hN = function (e) { return { "flo-has-alert": e } }; let oC = (() => { class e { constructor(t, o, i) { this.cd = t, this.localeService = o, this.decisionNavService = i, this.disabled = !1, this.trueLabel = "ja", this.falseLabel = "true", this.listMultipleExcludeAnswer = "", this.transitionClassName = "flo-form-transition-in", this.navWithinQuestionContainer = !1, this.questionDisplayType = ve.LIST, this.alertMessage = "", this.answerGiven = new Q, this.QuestionType = be, this.explanationIsVisible = !1, this.showExplanationButtonLabel = "", this.showOptionExplanationButtonLabel = "", this.booleanAnswer = null, this.listSingleAnswer = null, this.listAnswers = new Map, this.disabledListAnswers = new Map, this.visibilityOptionExplanations = new Map } ngOnInit() { this.questionIdAttr = "_" + this.question.id, this.showExplanationButtonLabel = this.localeService.locale.showExplanationLabel, this.showOptionExplanationButtonLabel = this.localeService.locale.showOptionExplanationButtonLabel, this.question.explanation && (this.explanationIsVisible = this.question.explanation.showImmediately), this.currentAnswer && this.question.type === be.LIST_MULTIPLE && this.disableWhenExcludedAnswer() } ngOnChanges() { this.initListOptionExplanationVisibility(), this.question.type === be.LIST_MULTIPLE && 0 === this.listAnswers.size && this.initListAnswers(), this.setAnswer(this.currentAnswer ? this.currentAnswer : null) } hasAnswer() { switch (this.question.type) { case be.BOOLEAN: return null !== this.booleanAnswer; case be.LIST_SINGLE: return this.listSingleAnswer; case be.LIST_MULTIPLE: return Array.from(this.listAnswers.values()).filter(t => !0 === t).length > 0 } } toggleExplanation() { this.explanationIsVisible = !this.explanationIsVisible } toggleOptionExplanation(t) { const o = this.visibilityOptionExplanations.get(t); this.visibilityOptionExplanations.set(t, !o) } setListSingleAnswer(t) { this.listSingleAnswer = t, this.answerChanged() } answerChanged() { let t; t = this.question.type === be.BOOLEAN ? this.booleanAnswer : this.listSingleAnswer, this.answerGiven.emit({ questionId: this.question.id, answers: [t] }) } answerToggled(t, o) { this.listAnswers.set(o, t), this.disableWhenExcludedAnswer(); const i = Array.from(this.listAnswers.keys()).filter(r => !0 === this.listAnswers.get(r)); this.answerGiven.emit({ questionId: this.question.id, answers: i }) } onRadioInputKeyDown(t, o) { if (this.questionDisplayType !== ve.ONE_BY_ONE) return; const i = Array.from(o.querySelectorAll('input[type="radio"]')); if ("ArrowUp" === t.key || "ArrowDown" === t.key || "ArrowLeft" === t.key || "ArrowRight" === t.key) { t.preventDefault(); const r = i.findIndex(a => document.activeElement === a); let s; s = "ArrowDown" === t.key || "ArrowRight" === t.key ? (r + 1) % i.length : (r - 1 + i.length) % i.length, i[s].focus() } if ("Enter" === t.key) { const r = i.findIndex(a => document.activeElement === a); "BOOLEAN" === this.question.type ? this.booleanAnswer = 0 === r : this.listSingleAnswer = this.question.options[r].id, this.answerChanged() } } initListAnswers() { this.listAnswers = new Map, this.disabledListAnswers = new Map, this.question.options.forEach(t => { this.listAnswers.set(t.id, !1), this.disabledListAnswers.set(t.id, !1), this.visibilityOptionExplanations.set(t.id, t.explanation && t.explanation.showImmediately) }) } initListOptionExplanationVisibility() { this.question.options && this.question.options.forEach(t => { let o = !1; t.explanation && t.explanation.showImmediately && (o = !0), this.visibilityOptionExplanations.set(t.id, o) }) } setAnswer(t = null) { this.question.type === be.LIST_MULTIPLE ? t ? this.currentAnswer.forEach(o => { this.listAnswers.set(o, !0) }) : this.listAnswers.forEach((o, i) => { this.listAnswers.set(i, !1) }) : this.question.type === be.BOOLEAN ? this.booleanAnswer = t ? this.currentAnswer[0] : null : this.listSingleAnswer = t ? this.currentAnswer[0] : null } disableWhenExcludedAnswer() { if (!this.listMultipleExcludeAnswer) return; const t = this.question.options.find(o => o.value.toLowerCase() === this.listMultipleExcludeAnswer.toLowerCase()); t && this.listAnswers.has(t.id) && (!0 === this.listAnswers.get(t.id) ? this.question.options.filter(o => o.id !== t.id).forEach(o => { this.listAnswers.set(o.id, !1), this.disabledListAnswers.set(o.id, !0) }) : this.question.options.forEach(o => { this.disabledListAnswers.set(o.id, !1) })) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(ti), b(Kt), b(Oa)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-question"]], inputs: { question: "question", currentAnswer: "currentAnswer", disabled: "disabled", trueLabel: "trueLabel", falseLabel: "falseLabel", listMultipleExcludeAnswer: "listMultipleExcludeAnswer", transitionClassName: "transitionClassName", navWithinQuestionContainer: "navWithinQuestionContainer", questionDisplayType: "questionDisplayType", alertMessage: "alertMessage" }, outputs: { answerGiven: "answerGiven" }, features: [Te], decls: 17, vars: 18, consts: [["class", "flo-question-subheader", 4, "ngIf"], [1, "flo-question-section", 3, "ngClass"], ["myQuestion", ""], ["class", "flo-explanation-container", 4, "ngIf"], ["tabindex", "0", 1, "flo-question-container", 3, "ngClass"], [1, "flo-question-description-container"], [1, "flo-question-description", 3, "id"], ["class", "flo-explanation-show flo-explanation-button", "type", "button", 3, "ngClass", "click", 4, "ngIf"], ["class", "flo-question-alert flo-alert", 4, "ngIf"], ["class", "flo-question-answers", 4, "ngIf"], [4, "ngIf"], [1, "flo-question-subheader"], [1, "flo-explanation-container"], [3, "content", "extraContent", "showHideButton", "hideMe"], ["type", "button", 1, "flo-explanation-show", "flo-explanation-button", 3, "ngClass", "click"], [1, "flo-question-alert", "flo-alert"], [1, "flo-alert-icon"], [1, "flo-alert-message"], [1, "flo-question-answers"], [3, "id"], ["type", "radio", 3, "name", "value", "ngModel", "disabled", "ngModelChange", "keydown"], [1, "flo-boolean-false"], [3, "ngModel", "name", "disabled", "ngModelChange", 4, "ngIf"], [3, "ngModel", "name", "disabled", "ngModelChange"], ["disabled", "", "hidden", "", "value", ""], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"], [4, "ngFor", "ngForOf"], [1, "flo-question-answers-option"], ["type", "radio", 3, "value", "name", "ngModel", "disabled", "ngModelChange", "keydown"], ["class", "flo-option-explanation-show flo-explanation-button", "type", "button", 3, "ngClass", "click", 4, "ngIf"], ["class", "flo-explanation-container flo-option-explanation", 4, "ngIf"], ["type", "button", 1, "flo-option-explanation-show", "flo-explanation-button", 3, "ngClass", "click"], [1, "flo-explanation-container", "flo-option-explanation"], ["type", "checkbox", 3, "value", "name", "ngModel", "disabled", "ngModelChange"]], template: function (o, i) { 1 & o && (v(0, zO, 2, 1, "h3", 0), y(1, "div", 1, 2), v(3, WO, 2, 3, "div", 3), y(4, "fieldset", 4)(5, "div", 5)(6, "legend", 6)(7, "span"), A(8), _(), v(9, KO, 1, 4, "button", 7), _(), v(10, YO, 2, 3, "div", 3), _(), v(11, JO, 4, 1, "div", 8), v(12, ZO, 7, 13, "div", 9), v(13, rN, 3, 2, "div", 9), v(14, uN, 2, 1, "div", 9), _(), v(15, cN, 1, 0, "app-decision-nav", 10), v(16, dN, 2, 3, "div", 3), _()), 2 & o && (h("ngIf", i.question.header), f(1), h("ngClass", Se(14, fN, !i.hasAnswer())), f(2), h("ngIf", i.question.explanation && "top" === i.question.explanation.position && i.explanationIsVisible), f(1), h("ngClass", Se(16, hN, !!i.alertMessage)), f(2), qe("id", i.questionIdAttr), f(2), j(i.question.questionText), f(1), h("ngIf", i.question.explanation && !i.question.explanation.showImmediately), f(1), h("ngIf", i.question.explanation && "middle" === i.question.explanation.position && i.explanationIsVisible), f(1), h("ngIf", i.alertMessage), f(1), h("ngIf", i.question.type === i.QuestionType.BOOLEAN), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_SINGLE), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_MULTIPLE), f(1), h("ngIf", !0 === i.navWithinQuestionContainer), f(1), h("ngIf", i.question.explanation && "bottom" === i.question.explanation.position && i.explanationIsVisible)) }, dependencies: [zt, ct, Ue, Da, ba, co, Tn, ui, li, Bn, ai, fi, nC], encapsulation: 2, data: { animation: [GO("fadeAnimation", [Xv("false=>true", [vd({ opacity: 0 }), Zv("2500ms", vd({ opacity: 1 }))]), Xv("true=>false", [Zv("2500ms 2000ms", vd({ opacity: 0 }))])])] } }) } return e })(); const pN = function (e) { return { "flo-inner-hidden": e } }; function gN(e, n) { if (1 & e) { const t = R(); y(0, "app-form-question", 4), M("focus", function (i) { return S(t), x(m(3).onFocusedQuestionChange(i)) })("answerGiven", function (i) { return S(t), x(m(3).onAnswerGiven(i)) }), _() } if (2 & e) { const t = m().$implicit, o = m(2); h("ngClass", Se(4, pN, -1 === o.relevantQuestions.indexOf(t.id)))("question", t)("formGroup", o.formGroup)("listOptionsWithExplanation", !0) } } function mN(e, n) { if (1 & e && (Ee(0), v(1, gN, 1, 6, "app-form-question", 3), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("ngIf", t.type !== o.FormQuestionType.DECISIONTABLE) } } function _N(e, n) { 1 & e && v(0, mN, 2, 1, "ng-container", 2), 2 & e && h("ngForOf", m().currentQuestions) } function yN(e, n) { 1 & e && no(0) } function vN(e, n) { if (1 & e && (y(0, "form", 5), v(1, yN, 1, 0, "ng-container", 6), _()), 2 & e) { m(); const t = kt(1); f(1), h("ngTemplateOutlet", t) } } let CN = (() => { class e extends Wv { constructor(t) { super(t), this.groupsNotAllowedMesssage = "", this.decisionTablesNotNotAllowedMesssage = "" } init() { if (this.formData && this.formData.groups.length > 0) return this.formData = null, void (this.groupsNotAllowedMesssage = "Er is een formulieren met groepen gekoppeld. Gebruik van groepen is niet toegestaan in formulieren die gekoppeld zijn aan een dynamische uitkomst van een check"); if (this.formData) for (const t of this.formData.questions) if (t.type === V.DECISIONTABLE) return this.formData = null, void (this.decisionTablesNotNotAllowedMesssage = "Er is een formulieren met daarin een beslissingstabel gekoppeld. Gebruik van beslissingstabellen is niet toegestaan in formulieren die gekoppeld zijn aan een dynamische uitkomst van een check"); super.init() } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-dynamic-form"]], features: [oe], decls: 3, vars: 1, consts: [["questionsTemplate", ""], ["class", "flo-form", 4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "ngClass", "question", "formGroup", "listOptionsWithExplanation", "focus", "answerGiven", 4, "ngIf"], [3, "ngClass", "question", "formGroup", "listOptionsWithExplanation", "focus", "answerGiven"], [1, "flo-form"], [4, "ngTemplateOutlet"]], template: function (o, i) { 1 & o && (v(0, _N, 1, 1, "ng-template", null, 0, tr), v(2, vN, 2, 1, "form", 1)), 2 & o && (f(2), h("ngIf", i.formData && i.formGroup && 0 === i.formData.groups.length)) }, dependencies: [zt, ct, Ue, ar, Ca, jn, ri, yd] }) } return e })(); const wN = ["oneByOne"], DN = ["singleQuestion"], bN = function (e) { return { "flo-inner-hidden": e } }; function EN(e, n) { if (1 & e) { const t = R(); y(0, "app-question", 8), M("answerGiven", function (i) { return S(t), x(m(3).onAnswerGiven(i)) }), _() } if (2 & e) { const t = n.$implicit, o = m(3); h("ngClass", Se(9, bN, -1 === o.questionsToShow.indexOf(t.id)))("question", t)("currentAnswer", o.answers[t.id])("disabled", o.disabled || o.reUseAnswers.hasOwnProperty(t.id))("trueLabel", o.checkData.trueLabel)("listMultipleExcludeAnswer", o.checkData.listMultipleExcludeAnswer)("falseLabel", o.checkData.falseLabel)("navWithinQuestionContainer", o.navWithinQuestionContainer)("questionDisplayType", o.questionDisplayType) } } function IN(e, n) { if (1 & e) { const t = R(); y(0, "app-dynamic-form", 10), M("formChange", function (i) { S(t); const r = m().$implicit; return x(m(3).onFormChange(i, r.outcomeId)) }), _() } if (2 & e) { const t = m().$implicit; h("formData", t.formData)("initialAnswers", t.initialAnswers) } } function TN(e, n) { if (1 & e && (Ee(0), v(1, IN, 1, 2, "app-dynamic-form", 9), Ie()), 2 & e) { const t = n.$implicit; f(1), h("ngIf", t.isNeeded) } } function AN(e, n) { } function SN(e, n) { 1 & e && v(0, AN, 0, 0, "ng-template") } const wd = function (e, n) { return { outcomes: e, header: n } }; function xN(e, n) { if (1 & e && (Ee(0), v(1, SN, 1, 0, null, 11), Ie()), 2 & e) { m(2); const t = kt(6), o = m(); f(1), h("ngTemplateOutlet", t)("ngTemplateOutletContext", Bs(2, wd, o.currentOutcomes, o.outcomesHeader)) } } function MN(e, n) { if (1 & e && (Ee(0), y(1, "div", 5), v(2, EN, 1, 11, "app-question", 6), v(3, TN, 2, 1, "ng-container", 7), _(), v(4, xN, 2, 5, "ng-container", 0), Ie()), 2 & e) { const t = m(2); f(2), h("ngForOf", null == t.checkData ? null : t.checkData.questions), f(1), h("ngForOf", t.dynamicOutcomesService.forms), f(1), h("ngIf", t.showOutcomes && t.checkIsComplete) } } function FN(e, n) { if (1 & e) { const t = R(); y(0, "app-question", 15, 16), M("answerGiven", function (i) { return S(t), x(m(3).onAnswerGiven(i)) }), _() } if (2 & e) { const t = m(3); Pu(t.transitionClassName), h("question", t.currentQuestion)("currentAnswer", t.answers[t.currentQuestion.id])("alertMessage", t.currentQuestionAlertMessage)("disabled", t.disabled || t.reUseAnswers.hasOwnProperty(t.currentQuestion.id))("trueLabel", t.checkData.trueLabel)("listMultipleExcludeAnswer", t.checkData.listMultipleExcludeAnswer)("falseLabel", t.checkData.falseLabel)("navWithinQuestionContainer", t.navWithinQuestionContainer)("questionDisplayType", t.questionDisplayType) } } function ON(e, n) { if (1 & e) { const t = R(); y(0, "app-dynamic-form", 10), M("formChange", function (i) { S(t); const r = m().$implicit; return x(m(3).onFormChange(i, r.outcomeId)) }), _() } if (2 & e) { const t = m().$implicit; h("formData", t.formData)("initialAnswers", t.initialAnswers) } } function NN(e, n) { if (1 & e && (Ee(0), v(1, ON, 1, 2, "app-dynamic-form", 9), Ie()), 2 & e) { const t = n.$implicit; f(1), h("ngIf", t.isNeeded) } } function PN(e, n) { } function kN(e, n) { 1 & e && v(0, PN, 0, 0, "ng-template") } function LN(e, n) { if (1 & e && (Ee(0), v(1, kN, 1, 0, null, 11), Ie()), 2 & e) { m(2); const t = kt(6), o = m(); f(1), h("ngTemplateOutlet", t)("ngTemplateOutletContext", Bs(2, wd, o.currentOutcomes, o.outcomesHeader)) } } function RN(e, n) { } function VN(e, n) { 1 & e && v(0, RN, 0, 0, "ng-template") } function BN(e, n) { if (1 & e && (Ee(0), v(1, VN, 1, 0, null, 11), Ie()), 2 & e) { m(2); const t = kt(6), o = m(); f(1), h("ngTemplateOutlet", t)("ngTemplateOutletContext", Bs(2, wd, o.currentQuestionOutcomes, o.outcomesPerQuestionHeader)) } } function jN(e, n) { 1 & e && k(0, "app-decision-nav") } function HN(e, n) { if (1 & e && (y(0, "div", 12, 13), v(2, FN, 2, 11, "app-question", 14), v(3, NN, 2, 1, "ng-container", 7), v(4, LN, 2, 5, "ng-container", 0), v(5, BN, 2, 5, "ng-container", 0), v(6, jN, 1, 0, "app-decision-nav", 0), _()), 2 & e) { const t = m(2); Pu(t.transitionClassName), f(2), h("ngIf", t.currentQuestion), f(1), h("ngForOf", t.dynamicOutcomesService.forms), f(1), h("ngIf", t.showOutcomes && t.checkIsComplete && !t.currentQuestion), f(1), h("ngIf", t.showOutcomesPerQuestion && t.currentQuestion && t.questionDisplayType === t.QuestionDisplayType.ONE_BY_ONE_MANUALLY), f(1), h("ngIf", !1 === t.navWithinQuestionContainer) } } function UN(e, n) { if (1 & e && (y(0, "p"), A(1), _()), 2 & e) { const t = m(2).header; f(1), j(t) } } function $N(e, n) { if (1 & e && (y(0, "h2"), A(1), _()), 2 & e) { const t = m(2).header; f(1), j(t) } } function qN(e, n) { if (1 & e && (y(0, "h3"), A(1), _()), 2 & e) { const t = m(2).header; f(1), j(t) } } function GN(e, n) { if (1 & e && (y(0, "h4"), A(1), _()), 2 & e) { const t = m(2).header; f(1), j(t) } } function QN(e, n) { if (1 & e && (y(0, "h5"), A(1), _()), 2 & e) { const t = m(2).header; f(1), j(t) } } function zN(e, n) { if (1 & e && (Ee(0), v(1, UN, 2, 1, "p", 0), v(2, $N, 2, 1, "h2", 0), v(3, qN, 2, 1, "h3", 0), v(4, GN, 2, 1, "h4", 0), v(5, QN, 2, 1, "h5", 0), Ie()), 2 & e) { const t = m(3); f(1), h("ngIf", 0 === t.outcomesHeaderLevel), f(1), h("ngIf", 2 === t.outcomesHeaderLevel), f(1), h("ngIf", 3 === t.outcomesHeaderLevel), f(1), h("ngIf", 4 === t.outcomesHeaderLevel), f(1), h("ngIf", 5 === t.outcomesHeaderLevel) } } function WN(e, n) { if (1 & e && (y(0, "p"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function KN(e, n) { if (1 & e && (y(0, "h3"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function YN(e, n) { if (1 & e && (y(0, "h4"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function JN(e, n) { if (1 & e && (y(0, "h5"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function ZN(e, n) { if (1 & e && (y(0, "h6"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function XN(e, n) { if (1 & e && (Ee(0), v(1, WN, 2, 1, "p", 0), v(2, KN, 2, 1, "h3", 0), v(3, YN, 2, 1, "h4", 0), v(4, JN, 2, 1, "h5", 0), v(5, ZN, 2, 1, "h6", 0), Ie()), 2 & e) { const t = m(4); f(1), h("ngIf", 0 === t.outcomesHeaderLevel), f(1), h("ngIf", 2 === t.outcomesHeaderLevel), f(1), h("ngIf", 3 === t.outcomesHeaderLevel), f(1), h("ngIf", 4 === t.outcomesHeaderLevel), f(1), h("ngIf", 5 === t.outcomesHeaderLevel) } } function e2(e, n) { if (1 & e && (y(0, "p"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function t2(e, n) { if (1 & e && (y(0, "h2"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function n2(e, n) { if (1 & e && (y(0, "h3"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function o2(e, n) { if (1 & e && (y(0, "h4"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function i2(e, n) { if (1 & e && (y(0, "h5"), A(1), _()), 2 & e) { const t = m(2).$implicit; f(1), j(t.title) } } function r2(e, n) { if (1 & e && (Ee(0), v(1, e2, 2, 1, "p", 0), v(2, t2, 2, 1, "h2", 0), v(3, n2, 2, 1, "h3", 0), v(4, o2, 2, 1, "h4", 0), v(5, i2, 2, 1, "h5", 0), Ie()), 2 & e) { const t = m(4); f(1), h("ngIf", 0 === t.outcomesHeaderLevel), f(1), h("ngIf", 2 === t.outcomesHeaderLevel), f(1), h("ngIf", 3 === t.outcomesHeaderLevel), f(1), h("ngIf", 4 === t.outcomesHeaderLevel), f(1), h("ngIf", 5 === t.outcomesHeaderLevel) } } function s2(e, n) { if (1 & e && (Ee(0), v(1, XN, 6, 5, "ng-container", 0), v(2, r2, 6, 5, "ng-container", 0), k(3, "div", 18), Ie()), 2 & e) { const t = n.$implicit, o = m().header; f(1), h("ngIf", t.title && o), f(1), h("ngIf", t.title && !o), f(1), h("innerHTML", t.content, vn) } } function a2(e, n) { if (1 & e && (y(0, "div", 17), v(1, zN, 6, 5, "ng-container", 0), v(2, s2, 4, 3, "ng-container", 7), _()), 2 & e) { const t = n.outcomes, o = n.header; f(1), h("ngIf", o && t.length > 0), f(1), h("ngForOf", t) } } function l2(e, n) { if (1 & e && (Ee(0), y(1, "div", 1)(2, "form", 2), v(3, MN, 5, 3, "ng-container", 0), v(4, HN, 7, 7, "div", 3), _(), v(5, a2, 3, 2, "ng-template", null, 4, tr), _(), Ie()), 2 & e) { const t = m(); f(3), h("ngIf", t.isListTypeDisplay), f(1), h("ngIf", !t.isListTypeDisplay) } } let Dd = (() => { class e { constructor(t, o, i, r, s) { this.cd = t, this.elem = o, this.dns = i, this.dynamicOutcomesService = r, this.localeService = s, this.questionDisplayType = ve.LIST, this.showOutcomes = !1, this.showOutcomesPerQuestion = !1, this.outcomesHeader = "", this.outcomesPerQuestionHeader = "", this.outcomesHeaderLevel = 0, this.previousButtonText = "", this.nextButtonText = "", this.disabledNextButton = !0, this.customUnansweredAlertMessage = "", this.showPreviousButtonAtStart = !1, this.showNextButtonAtEnd = !1, this.startAtLastQuestion = !1, this.customApiUrl = "/custom-api/", this.answers = {}, this.reUsableAnswers = [], this.formAnswers = {}, this.disabled = !1, this.useTransitions = !1, this.transitionTime = 800, this.scrollOffset = 0, this.navWithinQuestionContainer = !1, this.decisionChange = new Q, this.answerChange = new Q, this.command = new Q, this.nextClicked = new Q, this.previousClicked = new Q, this.reUseAnswers = {}, this.isListTypeDisplay = !0, this.questionsToShow = [], this.currentQuestion = null, this.currentQuestionAlertMessage = "", this.unansweredAlertMessage = "", this.currentCheckResult = null, this.checkIsComplete = !1, this.currentOutcomes = [], this.currentQuestionOutcomes = [], this.transitionClassName = "flo-form-transition-in", this.QuestionDisplayType = ve, i.nextClicked$.subscribe(() => { this.handleNext() }), i.previousClicked$.subscribe(() => { this.handlePrevious() }) } ngOnChanges() { this.dynamicOutcomesService.setCustomContentBaseUrl(this.customApiUrl), this.isListTypeDisplay = -1 !== [ve.LIST, ve.LIST_CUMULATIVE].indexOf(this.questionDisplayType), this.checkData && (this.decisionManager = new UO(this.checkData), this.dynamicOutcomesService.initFormsForDynamicOutcomes(this.checkData, this.formAnswers), this.setReUseAnswers(), this.check(!0)), this.dns.previousButtonText = this.previousButtonText || this.localeService.locale.previousButtonText, this.dns.nextButtonText = this.nextButtonText || this.localeService.locale.nextButtonText, this.dns.showOutcomesPerQuestion = this.showOutcomesPerQuestion, this.unansweredAlertMessage = this.customUnansweredAlertMessage ? this.customUnansweredAlertMessage : this.localeService.locale.defaultUnansweredAlertMessage } onAnswerGiven(t) { this.answers[t.questionId] = t.answers, this.check(), this.emitAnswerChanged(t.questionId), this.currentQuestionHasAnswer() && this.currentQuestionAlertMessage === this.unansweredAlertMessage && (this.currentQuestionAlertMessage = "") } onFormChange(t, o) { this.dynamicOutcomesService.setFormResult(o, t), this.check() } next() { this.handleNext() } previous() { this.handlePrevious() } setReUseAnswers() { this.reUseAnswers = {}, this.checkData.questions.forEach(t => { if (t.reUseReference) { const o = this.reUsableAnswers.find(i => i.checkId === t.reUseReference.referencedCheckId && i.questionId === t.reUseReference.referencedQuestionId); o && (this.reUseAnswers[t.id] = { answer: o.answer, showQuestionInCheck: t.reUseReference.showQuestionInCheck }, this.answers[t.id] = o.answer) } }) } emitAnswerChanged(t) { const o = this.answers[t], i = new Qv; i.questionId = t; const r = this.checkData.questions.find(s => s.id === t); r.type === be.BOOLEAN ? (i.optionId = o[0], i.optionValue = !0 === i.optionId ? this.checkData.trueLabel : this.checkData.falseLabel) : r.type === be.LIST_MULTIPLE ? (i.optionId = o, i.optionValue = o.map(s => r.options.find(a => a.id === s).value)) : (i.optionId = o[0], i.optionValue = r.options.find(s => s.id === i.optionId).value), this.answerChange.emit(i) } check(t = !1) { const o = this.decisionManager.execute(this.answers, this.dynamicOutcomesService.getFormResults()); this.updateQuestionsToShow(o.relevantQuestions), this.isListTypeDisplay || (t ? (this.setCurrentQuestion(this.startAtLastQuestion ? this.questionsToShow.length - 1 : 0), this.setButtonsVisibility()) : this.questionDisplayType === ve.ONE_BY_ONE && this.currentQuestion.type !== be.LIST_MULTIPLE ? this.handleNext() : this.setButtonsVisibility()), this.currentCheckResult = o, this.checkIsComplete = o.checkIsComplete, this.dynamicOutcomesService.setVisibilityOfDynamicForms(this.checkData, this.currentCheckResult), this.dynamicOutcomesService.getDynamicOutcomeContent(this.checkData, this.currentCheckResult).subscribe({ next: i => { Object.keys(i).forEach(r => { i[r].html && (this.currentCheckResult.outcomes.find(s => s.id === r).dynamicContent = i[r].html) }) }, error: i => { console.log("this should not be reached"), console.log(i) }, complete: () => { this.setCurrentOutcomes(), this.setCurrentQuestionOutcomes(), this.decisionChange.emit(o) } }) } handleNext() { const t = this.questionsToShow.findIndex(o => o === this.currentQuestion.id); t === this.questionsToShow.length - 1 && this.currentQuestionHasAnswer() ? (this.showOutcomes ? (this.currentQuestion = null, this.scrollIntoViewWithOffset()) : this.command.emit(Dr.NEXT), this.setCurrentQuestionOutcomes(), this.setButtonsVisibility()) : this.currentQuestionHasAnswer() ? this.useTransitions ? this.proceedOneByOneFlowAnimated(t + 1) : this.proceedOneByOneFlow(t + 1) : this.currentQuestionAlertMessage = this.unansweredAlertMessage } scrollIntoViewWithOffset() { const t = this.oneByOneContainer.nativeElement; console.log(this.scrollOffset), window.scrollTo({ top: t.getBoundingClientRect().top - document.body.getBoundingClientRect().top - this.scrollOffset }) } handlePrevious() { let t; this.currentQuestionAlertMessage = "", t = this.currentQuestion ? this.questionsToShow.findIndex(o => o === this.currentQuestion.id) : this.questionsToShow.length, -1 === t || 0 === t ? (this.command.emit(Dr.PREVIOUS), this.setCurrentQuestionOutcomes(), this.setButtonsVisibility()) : this.useTransitions ? this.proceedOneByOneFlowAnimated(t - 1) : this.proceedOneByOneFlow(t - 1) } proceedOneByOneFlow(t) { this.currentQuestion = null, this.cd.detectChanges(), this.setCurrentQuestion(t), this.cd.detectChanges(), this.scrollIntoViewWithOffset(), this.focusOnQuestion(), this.setCurrentQuestionOutcomes(), this.setButtonsVisibility(), this.cd.detectChanges() } proceedOneByOneFlowAnimated(t) { this.transitionClassName = "flo-form-transition-out", setTimeout(() => { this.cd.detectChanges(), this.currentQuestion = null, this.cd.detectChanges(), this.setCurrentQuestion(t), this.setButtonsVisibility(), this.cd.detectChanges(), this.scrollIntoViewWithOffset(), this.transitionClassName = "flo-form-transition-in", setTimeout(() => { this.cd.detectChanges(), this.focusOnQuestion(), this.setCurrentQuestionOutcomes() }, this.transitionTime / 2) }, this.transitionTime / 2) } focusOnQuestion() { const t = this.elem.nativeElement.querySelector(".flo-question-container"); t && t.focus() } setCurrentQuestion(t) { const o = this.questionsToShow[t]; this.currentQuestion = this.checkData.questions.find(i => i.id === o) } setButtonsVisibility() { if (this.dns.previousButtonVisible = !1, this.dns.nextButtonVisible = !0, !this.currentQuestion) return this.dns.previousButtonVisible = !0, this.dns.nextButtonVisible = this.showNextButtonAtEnd, void this.cd.detectChanges(); const t = this.questionsToShow.findIndex(i => i === this.currentQuestion.id); -1 === t && console.error("current question is expected to be in the list  of visible questions"), (t > 0 || this.showPreviousButtonAtStart) && (this.dns.previousButtonVisible = !0), t === this.questionsToShow.length - 1 && !this.showOutcomes && !1 === this.showNextButtonAtEnd && (this.dns.nextButtonVisible = !1); const o = this.currentQuestionHasAnswer(); this.dns.nextButtonEnabled = !this.disabledNextButton || o, o && "one-by-one" === this.questionDisplayType && this.currentQuestion.type !== be.LIST_MULTIPLE && (this.dns.nextButtonVisible = !1), this.cd.detectChanges() } currentQuestionHasAnswer() { return !!this.answers.hasOwnProperty(this.currentQuestion.id) && (this.currentQuestion.type !== be.LIST_MULTIPLE || 0 !== this.answers[this.currentQuestion.id].length) } updateQuestionsToShow(t) { let o = this.checkData.questions.filter(i => { const r = this.reUseAnswers.hasOwnProperty(i.id) && !1 === this.reUseAnswers[i.id].showQuestionInCheck; return -1 !== t.indexOf(i.id) && !r }); this.questionDisplayType === ve.LIST_CUMULATIVE && (o = o.slice(0, this.getIndexOfLastAnswer(o) + 2)), this.questionsToShow = o.map(i => i.id) } getIndexOfLastAnswer(t) { let o = -1; return Object.keys(this.answers).forEach(i => { const r = t.findIndex(s => s.id === i); r > o && (o = r) }), o } setCurrentOutcomes() { this.currentOutcomes = []; const t = this.currentCheckResult.outcomes.filter(o => o.state === re.VALID).map(o => o.id); this.checkData.outcomes.filter(o => -1 !== t.indexOf(o.id)).forEach(o => { this.currentOutcomes.push(this.generateOutcomeToDisplay(o)) }), this.cd.detectChanges() } setCurrentQuestionOutcomes() { this.currentQuestionOutcomes = [], this.questionDisplayType === ve.ONE_BY_ONE_MANUALLY && this.currentQuestion && this.decisionManager.getOutcomesForQuestion(this.currentCheckResult, this.currentQuestion.id).forEach(t => { this.currentQuestionOutcomes.push(this.generateOutcomeToDisplay(t)) }), this.cd.detectChanges() } generateOutcomeToDisplay(t) { const o = { title: t.title, content: t.content }, i = this.currentCheckResult.outcomes.find(r => r.id === t.id); return i.dynamicContent && (o.content = o.content + i.dynamicContent), o } static #e = this.\u0275fac = function (o) { return new (o || e)(b(ti), b(Nt), b(Oa), b(qO), b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-decision"]], viewQuery: function (o, i) { if (1 & o && (so(wN, 5), so(DN, 5)), 2 & o) { let r; ro(r = ao()) && (i.oneByOneContainer = r.first), ro(r = ao()) && (i.singleQuestion = r.first) } }, inputs: { checkData: "checkData", questionDisplayType: "questionDisplayType", showOutcomes: "showOutcomes", showOutcomesPerQuestion: "showOutcomesPerQuestion", outcomesHeader: "outcomesHeader", outcomesPerQuestionHeader: "outcomesPerQuestionHeader", outcomesHeaderLevel: "outcomesHeaderLevel", previousButtonText: "previousButtonText", nextButtonText: "nextButtonText", disabledNextButton: "disabledNextButton", customUnansweredAlertMessage: "customUnansweredAlertMessage", showPreviousButtonAtStart: "showPreviousButtonAtStart", showNextButtonAtEnd: "showNextButtonAtEnd", startAtLastQuestion: "startAtLastQuestion", customApiUrl: "customApiUrl", answers: "answers", reUsableAnswers: "reUsableAnswers", formAnswers: "formAnswers", disabled: "disabled", useTransitions: "useTransitions", transitionTime: "transitionTime", scrollOffset: "scrollOffset", navWithinQuestionContainer: "navWithinQuestionContainer" }, outputs: { decisionChange: "decisionChange", answerChange: "answerChange", command: "command", nextClicked: "nextClicked", previousClicked: "previousClicked" }, features: [de([Oa]), Te], decls: 1, vars: 1, consts: [[4, "ngIf"], [1, "flo-embed-container"], [1, "flo-decision"], ["class", "flo-decision-one-by-one", 3, "class", 4, "ngIf"], ["outcomesRef", ""], [1, "flo-decision-list"], [3, "ngClass", "question", "currentAnswer", "disabled", "trueLabel", "listMultipleExcludeAnswer", "falseLabel", "navWithinQuestionContainer", "questionDisplayType", "answerGiven", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [3, "ngClass", "question", "currentAnswer", "disabled", "trueLabel", "listMultipleExcludeAnswer", "falseLabel", "navWithinQuestionContainer", "questionDisplayType", "answerGiven"], [3, "formData", "initialAnswers", "formChange", 4, "ngIf"], [3, "formData", "initialAnswers", "formChange"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "flo-decision-one-by-one"], ["oneByOne", ""], [3, "class", "question", "currentAnswer", "alertMessage", "disabled", "trueLabel", "listMultipleExcludeAnswer", "falseLabel", "navWithinQuestionContainer", "questionDisplayType", "answerGiven", 4, "ngIf"], [3, "question", "currentAnswer", "alertMessage", "disabled", "trueLabel", "listMultipleExcludeAnswer", "falseLabel", "navWithinQuestionContainer", "questionDisplayType", "answerGiven"], ["singleQuestion", ""], [1, "flo-outcomes-container"], [1, "flo-outcome-content", 3, "innerHTML"]], template: function (o, i) { 1 & o && v(0, l2, 7, 2, "ng-container", 0), 2 & o && h("ngIf", i.decisionManager) }, dependencies: [zt, ct, Ue, ar, Ca, jn, ri, oC, CN, nC], encapsulation: 2, changeDetection: 0 }) } return e })(), u2 = (() => { class e { constructor() { this.answers = {}, this.decisionChange = new Q } onDecisionChange(t) { this.decisionChange.emit({ formItemId: this.formItemId, checkResult: t }) } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-decision-in-form"]], inputs: { formItemId: "formItemId", checkData: "checkData", answers: "answers" }, outputs: { decisionChange: "decisionChange" }, decls: 1, vars: 3, consts: [[3, "checkData", "answers", "disabled", "decisionChange"]], template: function (o, i) { 1 & o && (y(0, "app-decision", 0), M("decisionChange", function (s) { return i.onDecisionChange(s) }), _()), 2 & o && h("checkData", i.checkData)("answers", i.answers)("disabled", !1) }, dependencies: [Dd], encapsulation: 2 }) } return e })(); function c2(e, n) { if (1 & e) { const t = R(); y(0, "app-decision-in-form", 7), M("decisionChange", function (i) { return S(t), x(m(3).onDecisionChange(i)) }), _() } if (2 & e) { const t = m().$implicit, o = m(2); h("formItemId", t.id)("checkData", t.checkData)("answers", o.decisionAnswers[t.id]) } } const bd = function (e) { return { "flo-inner-hidden": e } }; function d2(e, n) { if (1 & e) { const t = R(); y(0, "app-form-question", 8), M("focus", function (i) { return S(t), x(m(3).onFocusedQuestionChange(i)) })("answerGiven", function (i) { return S(t), x(m(3).onAnswerGiven(i)) }), _() } if (2 & e) { const t = m().$implicit, o = m(2); h("ngClass", Se(4, bd, -1 === o.relevantQuestions.indexOf(t.id)))("question", t)("formGroup", o.formGroup)("listOptionsWithExplanation", !0) } } function f2(e, n) { if (1 & e && (Ee(0), v(1, c2, 1, 3, "app-decision-in-form", 5), v(2, d2, 1, 6, "app-form-question", 6), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("ngIf", t.type === o.FormQuestionType.DECISIONTABLE), f(1), h("ngIf", t.type !== o.FormQuestionType.DECISIONTABLE) } } function h2(e, n) { 1 & e && v(0, f2, 3, 2, "ng-container", 4), 2 & e && h("ngForOf", m().currentQuestions) } const iC = function (e) { return { "flo-form-group-button-active": e } }; function p2(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "div", 13)(2, "button", 14), M("click", function () { S(t); const i = m().$implicit; return x(m(3).toggleGroup(i.id)) }), A(3), _()()() } if (2 & e) { const t = m().$implicit, o = m(3); f(2), h("ngClass", Se(3, iC, o.currentGroupId === t.id))("disabled", !o.groupIsAvailable(t.id)), f(1), j(t.name) } } function g2(e, n) { if (1 & e && (y(0, "div", 20), k(1, "app-explanation", 21), _()), 2 & e) { const t = m(2).$implicit; f(1), h("content", t.explanationTop.content)("extraContent", t.explanationTop.extraContent || "")("showHideButton", !t.explanationTop.showImmediately) } } function m2(e, n) { 1 & e && no(0) } function _2(e, n) { if (1 & e && (y(0, "div", 22), k(1, "app-explanation", 21), _()), 2 & e) { const t = m(2).$implicit; f(1), h("content", t.explanationBottom.content)("extraContent", t.explanationBottom.extraContent || "")("showHideButton", !t.explanationBottom.showImmediately) } } function y2(e, n) { 1 & e && (y(0, "div", 23)(1, "em"), A(2, "Nog niet alle vragen in deze groep zijn beantwoord."), _()()) } function v2(e, n) { if (1 & e) { const t = R(); y(0, "div", 24)(1, "button", 25), M("click", function () { return S(t), x(m(5).setNextGroup()) }), A(2, "Volgende "), _()() } if (2 & e) { const t = m(5); f(1), h("disabled", !t.nextGroupIsAvailable()) } } function C2(e, n) { if (1 & e && (y(0, "div", 15), v(1, g2, 2, 3, "div", 16), v(2, m2, 1, 0, "ng-container", 17), v(3, _2, 2, 3, "div", 18), v(4, y2, 3, 0, "div", 3), v(5, v2, 3, 1, "div", 19), _()), 2 & e) { const t = m().$implicit, o = m(3), i = kt(1); f(1), h("ngIf", t.explanationTop && t.explanationTop.content), f(1), h("ngTemplateOutlet", i), f(1), h("ngIf", t.explanationBottom && t.explanationBottom.content), f(1), h("ngIf", -1 === o.completedGroups.indexOf(o.currentGroupId)), f(1), h("ngIf", o.nextGroupExists()) } } function w2(e, n) { if (1 & e && (y(0, "div", 11), v(1, p2, 4, 5, "div", 1), v(2, C2, 6, 5, "div", 12), _()), 2 & e) { const t = n.$implicit, o = m(3); h("ngClass", Se(3, bd, -1 === o.relevantGroups.indexOf(t.id))), f(1), h("ngIf", -1 !== o.relevantGroups.indexOf(t.id)), f(1), h("ngIf", o.currentGroupId === t.id) } } function D2(e, n) { if (1 & e && (y(0, "form", 9), v(1, w2, 3, 5, "div", 10), _()), 2 & e) { const t = m(2); f(1), h("ngForOf", t.formData.groups) } } function b2(e, n) { 1 & e && k(0, "span", 30) } function E2(e, n) { if (1 & e) { const t = R(); Ee(0), y(1, "div", 28)(2, "button", 14), M("click", function () { const r = S(t).$implicit; return x(m(4).setGroup(r.id)) }), A(3), _(), v(4, b2, 1, 0, "span", 29), _(), Ie() } if (2 & e) { const t = n.$implicit, o = m(4); f(1), h("ngClass", Se(5, bd, -1 === o.relevantGroups.indexOf(t.id))), f(1), h("ngClass", Se(7, iC, o.currentGroupId === t.id))("disabled", !o.groupIsAvailable(t.id)), f(1), j(t.name), f(1), h("ngIf", o.relevantGroups[o.relevantGroups.length - 1] !== t.id) } } function I2(e, n) { if (1 & e && (y(0, "div", 27), v(1, E2, 5, 9, "ng-container", 4), _()), 2 & e) { const t = m(3); f(1), h("ngForOf", t.formData.groups) } } function T2(e, n) { 1 & e && no(0) } function A2(e, n) { 1 & e && (y(0, "div", 23)(1, "em"), A(2, "Nog niet alle vragen in deze groep zijn beantwoord."), _()()) } function S2(e, n) { if (1 & e) { const t = R(); y(0, "div", 24)(1, "button", 31), M("click", function () { return S(t), x(m(3).setNextGroup()) }), A(2, "volgende "), _()() } if (2 & e) { const t = m(3); f(1), h("disabled", !t.nextGroupIsAvailable()) } } function x2(e, n) { if (1 & e && (y(0, "form", 9), v(1, I2, 2, 1, "div", 26), v(2, T2, 1, 0, "ng-container", 17), v(3, A2, 3, 0, "div", 3), v(4, S2, 3, 1, "div", 19), _()), 2 & e) { const t = m(2), o = kt(1); f(1), h("ngIf", t.formData.groups.length > 0), f(1), h("ngTemplateOutlet", o), f(1), h("ngIf", -1 === t.completedGroups.indexOf(t.currentGroupId)), f(1), h("ngIf", t.nextGroupExists()) } } function M2(e, n) { if (1 & e && (Ee(0), v(1, D2, 2, 1, "form", 2), v(2, x2, 5, 4, "form", 2), Ie()), 2 & e) { const t = m(); f(1), h("ngIf", t.useAccordion), f(1), h("ngIf", !t.useAccordion) } } function F2(e, n) { 1 & e && no(0) } function O2(e, n) { 1 & e && (y(0, "div", 23)(1, "em"), A(2, "Nog niet alle vragen zijn beantwoord."), _()()) } function N2(e, n) { if (1 & e && (y(0, "form", 9), v(1, F2, 1, 0, "ng-container", 17), v(2, O2, 3, 0, "div", 3), _()), 2 & e) { const t = m(), o = kt(1); f(1), h("ngTemplateOutlet", o), f(1), h("ngIf", !t.formIsCompleted) } } function P2(e, n) { 1 & e && (y(0, "div", 23)(1, "em"), A(2, "Alle vragen zijn beantwoord."), _()()) } let rC = (() => { class e extends Wv { constructor(t) { super(t) } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-form"]], features: [oe], decls: 5, vars: 3, consts: [["questionsTemplate", ""], [4, "ngIf"], ["class", "flo-form", 4, "ngIf"], ["class", "flo-ready-status", 4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "formItemId", "checkData", "answers", "decisionChange", 4, "ngIf"], [3, "ngClass", "question", "formGroup", "listOptionsWithExplanation", "focus", "answerGiven", 4, "ngIf"], [3, "formItemId", "checkData", "answers", "decisionChange"], [3, "ngClass", "question", "formGroup", "listOptionsWithExplanation", "focus", "answerGiven"], [1, "flo-form"], ["class", "flo-group-container", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "flo-group-container", 3, "ngClass"], ["class", "flo-form-questions-container", 4, "ngIf"], [1, "flo-form-group-header"], ["type", "button", 1, "flo-form-button", "flo-form-group-button", 3, "ngClass", "disabled", "click"], [1, "flo-form-questions-container"], ["class", "flo-explanation-container flo-group-explanation-container flo-group-explanation-top-container", 4, "ngIf"], [4, "ngTemplateOutlet"], ["class", "flo-explanation-container flo-group-explanation-container", 4, "ngIf"], ["class", "flo-form-bottom-nav", 4, "ngIf"], [1, "flo-explanation-container", "flo-group-explanation-container", "flo-group-explanation-top-container"], [3, "content", "extraContent", "showHideButton"], [1, "flo-explanation-container", "flo-group-explanation-container"], [1, "flo-ready-status"], [1, "flo-form-bottom-nav"], ["type", "button", 1, "flo-form-button", "flo-form-next", 3, "disabled", "click"], ["class", "flo-form-group-nav", 4, "ngIf"], [1, "flo-form-group-nav"], [1, "flo-form-group-button-container", 3, "ngClass"], ["class", "flo-form-group-nav-divider", 4, "ngIf"], [1, "flo-form-group-nav-divider"], ["type", "button", 1, "flo-form-button", 3, "disabled", "click"]], template: function (o, i) { 1 & o && (v(0, h2, 1, 1, "ng-template", null, 0, tr), v(2, M2, 3, 2, "ng-container", 1), v(3, N2, 3, 2, "form", 2), v(4, P2, 3, 0, "div", 3)), 2 & o && (f(2), h("ngIf", i.formData && i.formGroup && i.formData.groups.length > 0), f(1), h("ngIf", i.formData && i.formGroup && 0 === i.formData.groups.length), f(1), h("ngIf", i.formIsCompleted)) }, dependencies: [zt, ct, Ue, ar, Ca, jn, ri, Hn, fi, yd, u2], encapsulation: 2 }) } return e })(), k2 = (() => { class e { constructor(t) { this.localeService = t, this.useAccordion = !0, this.allGroupsAvailable = !1, this.initialAnswers = {}, this.showDependentQuestions = !1, this.disabled = !1, this.cacheAnswers = !0, this.language = "nl", this.floFormChange = new Q, this.floAnswerChange = new Q } ngOnChanges() { this.dataFormData && (this.formData = JSON.parse(this.dataFormData)), this.dataUseAccordion && (this.useAccordion = "true" === this.dataUseAccordion.toLowerCase()), this.dataAllGroupsAvailable && (this.allGroupsAvailable = "true" === this.dataAllGroupsAvailable.toLowerCase()), this.dataAnswers && (this.initialAnswers = JSON.parse(this.dataAnswers)), this.dataShowDependentQuestions && (this.showDependentQuestions = JSON.parse(this.dataShowDependentQuestions.toLowerCase())), this.dataDisabled && (this.disabled = JSON.parse(this.dataDisabled.toLowerCase())), this.dataCacheAnswers && (this.cacheAnswers = JSON.parse(this.dataCacheAnswers.toLowerCase())), this.language = "nl", this.dataLanguage && (this.language = this.dataLanguage.trim(), this.localeService.setLanguage(this.language)) } onFormChange(t) { this.floFormChange.emit(t) } onAnswerChange(t) { this.floAnswerChange.emit(t) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-form"]], inputs: { dataFormData: "dataFormData", dataUseAccordion: "dataUseAccordion", dataAllGroupsAvailable: "dataAllGroupsAvailable", dataAnswers: "dataAnswers", dataShowDependentQuestions: "dataShowDependentQuestions", dataDisabled: "dataDisabled", dataCacheAnswers: "dataCacheAnswers", dataLanguage: "dataLanguage", language: "language" }, outputs: { floFormChange: "floFormChange", floAnswerChange: "floAnswerChange" }, features: [Te], decls: 1, vars: 7, consts: [[3, "formData", "initialAnswers", "showDependentQuestions", "useAccordion", "allGroupsAvailable", "disabled", "cacheAnswers", "formChange", "answerChange"]], template: function (o, i) { 1 & o && (y(0, "app-form", 0), M("formChange", function (s) { return i.onFormChange(s) })("answerChange", function (s) { return i.onAnswerChange(s) }), _()), 2 & o && h("formData", i.formData)("initialAnswers", i.initialAnswers)("showDependentQuestions", i.showDependentQuestions)("useAccordion", i.useAccordion)("allGroupsAvailable", i.allGroupsAvailable)("disabled", i.disabled)("cacheAnswers", i.cacheAnswers) }, dependencies: [rC], encapsulation: 2 }) } return e })(), Ed = (() => { class e { constructor() { this.errors = [] } parseBooleanDataAttribute(t, o, i) { try { const r = JSON.parse(i[t].toLowerCase()); if ("boolean" == typeof r) return r } catch (r) { console.log(r) } return this.errors.push(`Value for attribute '${o}' is invalid. Value should be 'true' or 'false'`), null } parseIntegerDataAttribute(t, o, i) { try { const r = JSON.parse(i[t]); if (Number.isInteger(r)) return r } catch (r) { console.log(r) } return this.errors.push(`Value for attribute '${o}' is invalid. Value should be an integer (a whole number)`), null } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function L2(e, n) { if (1 & e) { const t = R(); y(0, "app-decision", 2), M("decisionChange", function (i) { return S(t), x(m().onDecisionChange(i)) })("answerChange", function (i) { return S(t), x(m().onAnswerChange(i)) })("command", function (i) { return S(t), x(m().onCommand(i)) }), _() } if (2 & e) { const t = m(); h("checkData", t.checkData)("questionDisplayType", t.questionDisplayType)("showOutcomes", t.showOutcomes)("showOutcomesPerQuestion", t.showOutcomesPerQuestion)("outcomesHeader", t.outcomesHeader)("outcomesPerQuestionHeader", t.outcomesPerQuestionHeader)("outcomesHeaderLevel", t.outcomesHeaderLevel)("previousButtonText", t.previousButtonText)("nextButtonText", t.nextButtonText)("disabledNextButton", t.disabledNextButton)("customUnansweredAlertMessage", t.unansweredAlertMessage)("showPreviousButtonAtStart", t.showPreviousButtonAtStart)("showNextButtonAtEnd", t.showNextButtonAtEnd)("startAtLastQuestion", t.startAtLastQuestion)("customApiUrl", t.customApiUrl)("answers", t.answers)("reUsableAnswers", t.reUsableAnswers)("formAnswers", t.formAnswers)("disabled", t.disabled)("useTransitions", t.useTransitions)("transitionTime", t.transitionTime)("navWithinQuestionContainer", t.navWithinQuestionContainer)("scrollOffset", t.scrollOffset) } } function R2(e, n) { if (1 & e && (y(0, "li"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function V2(e, n) { if (1 & e && (y(0, "div", 3)(1, "p", 4), A(2, "De check kan niet worden weergegeven. De invoer is ongeldig"), _(), y(3, "ul", 5), v(4, R2, 2, 1, "li", 6), _()()), 2 & e) { const t = m(); f(4), h("ngForOf", t.dataAttributeParsingService.errors) } } let B2 = (() => { class e { constructor(t, o) { this.localeService = t, this.dataAttributeParsingService = o, this.dataQuestionDisplayType = "list", this.questionDisplayType = ve.LIST, this.showOutcomes = !1, this.showOutcomesPerQuestion = !1, this.outcomesHeader = "", this.outcomesPerQuestionHeader = "", this.outcomesHeaderLevel = 0, this.previousButtonText = "", this.nextButtonText = "", this.disabledNextButton = !0, this.unansweredAlertMessage = "", this.showPreviousButtonAtStart = !1, this.showNextButtonAtEnd = !1, this.startAtLastQuestion = !1, this.customApiUrl = "/custom-api/", this.answers = {}, this.reUsableAnswers = [], this.formAnswers = {}, this.disabled = !1, this.language = "nl", this.useTransitions = !1, this.transitionTimeDefault = 800, this.transitionTime = this.transitionTimeDefault, this.navWithinQuestionContainer = !1, this.scrollOffsetDefault = 0, this.scrollOffset = this.scrollOffsetDefault, this.floDecisionChange = new Q, this.floAnswerChange = new Q, this.floCommand = new Q } ngOnChanges() { if (this.dataAttributeParsingService.errors = [], this.checkData = null, this.dataCheckData) try { this.checkData = JSON.parse(this.dataCheckData) } catch (t) { console.error(t), this.dataAttributeParsingService.errors.push("Value for attribute 'data-check-data' is invalid") } if (this.questionDisplayType = ve.LIST, this.dataQuestionDisplayType && (-1 === $O.indexOf(this.dataQuestionDisplayType) ? this.dataAttributeParsingService.errors.push("Data-attribute 'data-question-display-type' has an invalid value. Accepted values are:\n                            'list', 'list-cumulative', 'one-by-one' and 'one-by-one-manually'") : this.questionDisplayType = this.dataQuestionDisplayType), this.showOutcomes = !1, this.dataShowOutcomes ? this.showOutcomes = this.dataAttributeParsingService.parseBooleanDataAttribute("dataShowOutcomes", "data-show-outcomes", this) : -1 !== [ve.ONE_BY_ONE, ve.ONE_BY_ONE_MANUALLY].indexOf(this.questionDisplayType) && (this.showOutcomes = !0), this.showOutcomesPerQuestion = !1, this.dataShowOutcomesPerQuestion && (this.questionDisplayType === ve.ONE_BY_ONE_MANUALLY ? this.showOutcomesPerQuestion = this.dataAttributeParsingService.parseBooleanDataAttribute("dataShowOutcomesPerQuestion", "data-show-outcomes-per-question", this) : this.dataAttributeParsingService.errors.push("Attribute 'data-show-outcomes-per-question' should only be used in combination with\n                    value 'one-by-one-manually' for attribute 'data-question-display-type'")), this.outcomesHeader = "", this.dataOutcomesHeader && (this.outcomesHeader = this.dataOutcomesHeader.trim()), this.outcomesPerQuestionHeader = "", this.dataOutcomesPerQuestionHeader && (this.outcomesPerQuestionHeader = this.dataOutcomesPerQuestionHeader.trim()), this.outcomesHeaderLevel = 0, this.dataOutcomesHeaderLevel && (this.outcomesHeaderLevel = this.dataAttributeParsingService.parseIntegerDataAttribute("dataOutcomesHeaderLevel", "data-outcomes-header-level", this), null !== this.outcomesHeaderLevel && (1 === this.outcomesHeaderLevel && this.dataAttributeParsingService.errors.push("Attribute 'data-outcomes-header-level' is not allowed to be set to 1"), this.outcomesHeaderLevel > 5 && this.dataAttributeParsingService.errors.push("Attribute 'data-outcomes-header-level' is not allowed to be set to >5 "), this.outcomesHeaderLevel < -1 && this.dataAttributeParsingService.errors.push("Attribute 'data-outcomes-header-level' is not allowed to be set to <-1 "))), this.previousButtonText = "", this.dataPreviousButtonText && (this.previousButtonText = this.dataPreviousButtonText), this.nextButtonText = "", this.dataNextButtonText && (this.nextButtonText = this.dataNextButtonText), this.disabledNextButton = !0, this.dataDisabledNextButton && (this.disabledNextButton = this.dataAttributeParsingService.parseBooleanDataAttribute("dataDisabledNextButton", "data-disabled-next-button", this)), this.unansweredAlertMessage = "", this.dataUnansweredAlertMessage && (this.unansweredAlertMessage = this.dataUnansweredAlertMessage), this.showPreviousButtonAtStart = !1, this.dataShowPreviousButtonAtStart && (this.showPreviousButtonAtStart = this.dataAttributeParsingService.parseBooleanDataAttribute("dataShowPreviousButtonAtStart", "data-show-previous-button-at-start", this)), this.showNextButtonAtEnd = !1, this.dataShowNextButtonAtEnd && (this.showOutcomes ? this.dataAttributeParsingService.errors.push("showNextButtonAtEnd = true cannot be used in conjunction with showOutcomes = true") : this.showNextButtonAtEnd = this.dataAttributeParsingService.parseBooleanDataAttribute("dataShowNextButtonAtEnd", "data-show-next-button-at-end", this)), this.startAtLastQuestion = !1, this.dataStartAtLastQuestion && (this.startAtLastQuestion = this.dataAttributeParsingService.parseBooleanDataAttribute("dataStartAtLastQuestion", "data-start-at-last-question", this)), this.customApiUrl = "/custom-api/", this.dataCustomApiUrl && (this.customApiUrl = this.dataCustomApiUrl), this.answers = {}, this.dataAnswers) try { this.answers = JSON.parse(this.dataAnswers) } catch (t) { console.error(t), this.dataAttributeParsingService.errors.push("Value for attribute 'data-answers' is invalid") } if (this.reUsableAnswers = [], this.dataReUsableAnswers) try { this.reUsableAnswers = JSON.parse(this.dataReUsableAnswers) } catch (t) { console.error(t), this.dataAttributeParsingService.errors.push("Value for attribute 'data-re-usable-answers' is invalid") } if (this.formAnswers = {}, this.dataFormAnswers) try { this.formAnswers = JSON.parse(this.dataFormAnswers) } catch (t) { console.error(t), this.dataAttributeParsingService.errors.push("Value for attribute 'data-form-answers' is invalid") } if (this.disabled = !1, this.dataDisabled && (this.disabled = this.dataAttributeParsingService.parseBooleanDataAttribute("dataDisabled", "data-disabled", this)), this.language = "nl", this.dataLanguage) { const t = this.dataLanguage.trim(); -1 === ["nl", "en", "fr"].indexOf(t) ? this.dataAttributeParsingService.errors.push("Value for attribute 'data-language' is invalid. Choose one of the values 'nl', 'en' or 'fr'") : this.language = t } this.useTransitions = !1, this.dataUseTransitions && (this.useTransitions = this.dataAttributeParsingService.parseBooleanDataAttribute("dataUseTransitions", "data-use-transitions", this)), this.transitionTime = this.transitionTimeDefault, void 0 !== this.dataTransitionTime && (this.transitionTime = this.dataAttributeParsingService.parseIntegerDataAttribute("dataTransitionTime", "data-transition-time", this)), this.navWithinQuestionContainer = !1, this.dataNavWithinQuestionContainer && (this.navWithinQuestionContainer = this.dataAttributeParsingService.parseBooleanDataAttribute("dataNavWithinQuestionContainer", "data-nav-within-question-container", this), !0 === this.navWithinQuestionContainer && -1 === [ve.ONE_BY_ONE, ve.ONE_BY_ONE_MANUALLY].indexOf(this.questionDisplayType) && this.dataAttributeParsingService.errors.push(`Value for attribute 'data-nav-within-question-container' is invalid.\n            In combination with display type ${this.questionDisplayType} only 'false' is allowed`)), this.scrollOffset = this.scrollOffsetDefault, void 0 !== this.dataScrollOffset && (this.scrollOffset = this.dataAttributeParsingService.parseIntegerDataAttribute("dataScrollOffset", "data-scroll-offset", this)), this.localeService.setLanguage(this.language) } onDecisionChange(t) { this.floDecisionChange.emit(t) } onAnswerChange(t) { this.floAnswerChange.emit(t) } onCommand(t) { this.floCommand.emit(t) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt), b(Ed)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-decision"]], inputs: { dataCheckData: "dataCheckData", dataQuestionDisplayType: "dataQuestionDisplayType", dataShowOutcomes: "dataShowOutcomes", dataShowOutcomesPerQuestion: "dataShowOutcomesPerQuestion", dataOutcomesHeader: "dataOutcomesHeader", dataOutcomesPerQuestionHeader: "dataOutcomesPerQuestionHeader", dataOutcomesHeaderLevel: "dataOutcomesHeaderLevel", dataPreviousButtonText: "dataPreviousButtonText", dataNextButtonText: "dataNextButtonText", dataDisabledNextButton: "dataDisabledNextButton", dataUnansweredAlertMessage: "dataUnansweredAlertMessage", dataShowPreviousButtonAtStart: "dataShowPreviousButtonAtStart", dataShowNextButtonAtEnd: "dataShowNextButtonAtEnd", dataStartAtLastQuestion: "dataStartAtLastQuestion", dataCustomApiUrl: "dataCustomApiUrl", dataAnswers: "dataAnswers", dataReUsableAnswers: "dataReUsableAnswers", dataFormAnswers: "dataFormAnswers", dataDisabled: "dataDisabled", dataLanguage: "dataLanguage", dataUseTransitions: "dataUseTransitions", dataTransitionTime: "dataTransitionTime", dataNavWithinQuestionContainer: "dataNavWithinQuestionContainer", dataScrollOffset: "dataScrollOffset" }, outputs: { floDecisionChange: "floDecisionChange", floAnswerChange: "floAnswerChange", floCommand: "floCommand" }, features: [Te], decls: 2, vars: 2, consts: [[3, "checkData", "questionDisplayType", "showOutcomes", "showOutcomesPerQuestion", "outcomesHeader", "outcomesPerQuestionHeader", "outcomesHeaderLevel", "previousButtonText", "nextButtonText", "disabledNextButton", "customUnansweredAlertMessage", "showPreviousButtonAtStart", "showNextButtonAtEnd", "startAtLastQuestion", "customApiUrl", "answers", "reUsableAnswers", "formAnswers", "disabled", "useTransitions", "transitionTime", "navWithinQuestionContainer", "scrollOffset", "decisionChange", "answerChange", "command", 4, "ngIf"], ["class", "flo-input-errors-container", 4, "ngIf"], [3, "checkData", "questionDisplayType", "showOutcomes", "showOutcomesPerQuestion", "outcomesHeader", "outcomesPerQuestionHeader", "outcomesHeaderLevel", "previousButtonText", "nextButtonText", "disabledNextButton", "customUnansweredAlertMessage", "showPreviousButtonAtStart", "showNextButtonAtEnd", "startAtLastQuestion", "customApiUrl", "answers", "reUsableAnswers", "formAnswers", "disabled", "useTransitions", "transitionTime", "navWithinQuestionContainer", "scrollOffset", "decisionChange", "answerChange", "command"], [1, "flo-input-errors-container"], [1, "flo-input-errors-header"], [1, "flo-input-errors-content"], [4, "ngFor", "ngForOf"]], template: function (o, i) { 1 & o && (v(0, L2, 1, 23, "app-decision", 0), v(1, V2, 5, 1, "div", 1)), 2 & o && (h("ngIf", 0 === i.dataAttributeParsingService.errors.length), f(1), h("ngIf", i.dataAttributeParsingService.errors.length > 0)) }, dependencies: [ct, Ue, Dd], encapsulation: 2 }) } return e })(), j2 = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [oi, ud, md, Ia] }) } return e })(); function sC(e, n, t, o, i, r, s) { try { var a = e[r](s), l = a.value } catch (u) { return void t(u) } a.done ? n(l) : Promise.resolve(l).then(o, i) } function Id(e) { return function () { var n = this, t = arguments; return new Promise(function (o, i) { var r = e.apply(n, t); function s(l) { sC(r, o, i, s, a, "next", l) } function a(l) { sC(r, o, i, s, a, "throw", l) } s(void 0) }) } } var dn = (() => { return (e = dn || (dn = {})).AS_IS = "AS_IS", e.LISTITEM_DISC = "LISTITEM_DISC", e.LISTITEM_NUMERIC = "LISTITEM_NUMERIC", e.LISTITEM_ALFABETIC = "LISTITEM_ALFABETIC", e.COMMA_SEPARATED = "COMMA_SEPARATED", dn; var e })(), br = (() => { return (e = br || (br = {})).RICH = "RICH", e.PLAIN = "PLAIN", br; var e })(); class pi { constructor() { this.value = null, this.canContainPlaceholders = !1, this.isHtml = !1, this.optionIds = [] } } class Td { constructor() { this.isMultiple = !1, this.itemsMultiple = [], this.item = null } hasValue() { return this.isMultiple ? this.itemsMultiple.length > 0 : this.item && this.item.value } } class H2 { constructor() { this.show = null, this.questionId = null, this.optionIds = [] } } const U2 = new RegExp(/&lt;([\\\w\s\-_\/=.]+)&gt;/, "g"), $2 = new RegExp(/<([\\\w\s\-_\/=.]+)>/, "g"); function Er(e, n = !1) { let t; t = n ? U2 : $2; const o = []; for (; ;) { const i = t.exec(e); if (null === i) break; -1 === o.indexOf(i[1]) && o.push(i[1]) } return o } function aC(e, n, t, o = !1) { let i; return i = o ? new RegExp("&lt;" + n + "&gt;", "g") : new RegExp("<" + n + ">", "g"), e.replace(i, t) } function lC(e, n) { if (n === dn.AS_IS) return e.join(""); if (n === dn.COMMA_SEPARATED) { let o = ""; return e.forEach((i, r) => { o = 0 === r ? i : r === e.length - 1 ? o + " en " + i : o + ", " + i }), o } const t = e.map(o => `<li>${o}</li>`).join(""); return n === dn.LISTITEM_DISC ? `<ul>${t}</ul>` : n === dn.LISTITEM_ALFABETIC ? `<ol class="flo-list-style-lower-alpha">${t}</ol>` : `<ol>${t}</ol>` } function uC(e, n, t) { for (let o of e) { if ("OR" === n && !0 === t[o]) return !0; if ("AND" === n && !1 === t[o]) return !1 } return "OR" !== n } function cC(e, n, t) { let o = !1; for (let i of e) { if ("OR" === n && t[i] === re.VALID) return !0; if ("AND" === n && t[i] === re.INVALID) return !1; t[i] === re.PENDING && (o = !0) } return o ? null : "OR" !== n } function Ad(e, n, t = !1) { const o = new pi; return o.canContainPlaceholders = !1, o.isHtml = !1, o.value = e.type === V.DECISIONTABLE ? e.checkData.outcomes.find(i => i.id === n).title : e.options.find(i => i.id === n).value, o.questionId = e.id, t && (o.optionIds = [n]), o } function dC(e, n, t) { const o = new pi; return o.canContainPlaceholders = !0, o.isHtml = e.editorType === br.RICH, o.value = e.content, o.questionId = n.id, t && (o.optionIds = e.optionIds), o } function Sd(e) { const n = new pi; return n.canContainPlaceholders = !1, n.isHtml = !1, n.value = "", n.questionId = e.id, n } function fC(e, n, t, o) { for (const r of o) { const s = new RegExp("<" + r + ">", "g"); e = e.replace(s, `&lt;${r}&gt;`) } let i; if (t.optionIds && t.optionIds.length > 0) { i = ""; for (const r of t.optionIds) i += ` _${r}` } else i = "_" + t.questionId; return n ? `<div class="${i}">${e}</div>` : `<span class="${i}">${e}</span>` } function G2(e, n, t) { const o = hC(t); return n ? `<div class="${o}">${e}</div>` : `<span class="${o}">${e}</span>` } function hC(e) { return e.optionIds && e.optionIds.length > 0 ? "_" + e.optionIds.join() : "_" + e.questionId } function pC(e, n, t, o, i = !1, r = !1) { const s = { value: n.value, isHtml: n.isHtml }; if (null === n.value) return s; let a = n.value, l = !1; if (n.canContainPlaceholders) { let d = Er(n.value, n.isHtml).filter(p => p !== e); r || (d = d.filter(p => -1 !== o.indexOf(p))), d.length > 0 && (a = function c(d, p, g) { let C = g; for (const D of p) { const I = t[D]; let F; I && (F = I.isMultiple ? I.itemsMultiple : [I.item]); let E = []; F && (E = F.map(te => { if (!te) return ""; te.isHtml && (C = !0, l = !0); let pe = te.value; if (!pe) return ""; if (i) { let Fd = []; te.isHtml || (Fd = Er(pe, !1)), pe = fC(pe, te.isHtml, te, Fd), C = !0, l = !0 } return pe })); let L = ""; if (I.isMultiple ? (L = lC(E, I.displayType), I.displayType !== dn.COMMA_SEPARATED && (C = !0)) : L = E[0], L) d = aC(d, D, L, g); else if (r) d = aC(d, D, "", g); else if (!g && i) { const te = new RegExp("<" + D + ">", "g"); d = d.replace(te, `&lt;${D}&gt`) } } let w = Er(d, C).filter(D => D !== e); return r || (w = w.filter(D => -1 !== o.indexOf(D))), w.length > 0 ? c(d, w, C) : d }(a, d, n.isHtml)) } const u = n.isHtml || l; if (i) { let d = []; u || (d = Er(a, !1)), a = fC(a, u, n, d) } return s.isHtml = i || u, s.value = a, s } var Ge = (() => { return (e = Ge || (Ge = {})).full = "full", e.long = "long", e.medium = "medium", e.short = "short", e.shorter = "shorter", e.numeric_long = "numeric_long", e.weekday_long = "weekday_long", Ge; var e })(); class Ir { static getFormatOptions(n) { switch (n) { case Ge.full: return Object.freeze({ dateStyle: "full" }); case Ge.long: return Object.freeze({ dateStyle: "long" }); case Ge.medium: return Object.freeze({ dateStyle: "medium" }); case Ge.short: return Object.freeze({ dateStyle: "short" }); case Ge.shorter: return Object.freeze({ year: "numeric", month: "numeric", day: "numeric" }); case Ge.numeric_long: return Object.freeze({ month: "long", day: "numeric" }); case Ge.weekday_long: return Object.freeze({ weekday: "long", day: "numeric", month: "long" }) } } static getFormatter(n, t = "nl") { const o = Ir.getFormatOptions(n); return new Intl.DateTimeFormat(t, o) } static getFormattedDate(n, t, o = "nl") { return Ir.getFormatter(t, o).format(n) } } const Q2 = [V.BOOLEAN, V.LIST_MULTIPLE, V.LIST_SINGLE, V.DECISIONTABLE]; class z2 { constructor() { } init(n, t, o) { this.mainTemplate = n, this.placeholderData = new Map, this.sectionData = new Map, this.attachmentData = new Map, this.placeholders = [], this.sectionNames = function q2(e) { const n = new RegExp(/\[\[(=[\\\w\s\-_\/.]+=){1}[^\]\[]+\]\]/, "g"), t = []; for (; ;) { const o = n.exec(e); if (null === o) break; if (-1 === t.indexOf(o[1])) { const i = o[1].replace(/=/g, ""); " " !== i.charAt(0) && " " !== i.charAt(i.length - 1) && -1 === t.indexOf(i) && t.push(i) } } return t }(this.mainTemplate), this.attachments = o, this.mainTemplatePlaceholders = Er(this.mainTemplate, !0), t.forEach(i => { if (i.placeholders) { this.placeholderData.set(i, i.placeholders); for (const r of i.placeholders) this.placeholders.push(r.text) } i.sections && this.sectionData.set(i, i.sections), i.attachments && this.attachmentData.set(i, i.attachments) }) } buildDocument(n, t = !1, o = !0) { const i = this.getSubstituedPlaceholderItems(n, o, t); let r = this.mainTemplate; const s = this.getSectionInfo(n); for (const a of this.sectionNames) { const l = new RegExp("\\[\\[=" + a + "=([^\\]\\[]+){1}\\]\\]"), u = l.exec(r); if (u && u.length > 0) if (s.hasOwnProperty(a) && null !== s[a].show) if (!0 === s[a].show) { let c = u[1]; const d = -1 !== c.indexOf("<"); o && (c = G2(c, d, s[a])), r = r.replace(l, c) } else r = r.replace(l, ""); else r = r.replace(l, t ? "" : `[[=${a}= ... ]]`) } for (const a of this.mainTemplatePlaceholders) { const l = new RegExp("&lt;" + a + "&gt;", "g"); if (i.hasOwnProperty(a)) { const c = i[a].value; c ? r = r.replace(l, c) : t && (r = r.replace(l, "")) } else t && (r = r.replace(l, "")) } return r = this.removeEmptyListItems(r), r = this.removeRedundantParagraphs(r), r } getSubstituedPlaceholderItems(n, t = !1, o = !1, i = !0) { const r = this.getInitialPlaceholderItems(n), s = {}, a = Object.keys(r).filter(l => r[l].hasValue()); for (const l of this.placeholders) { if (!r[l]) continue; let u; const c = r[l]; if (c.isMultiple) if (0 === c.itemsMultiple.length) u = { value: "", isHtml: !1 }; else { const d = []; for (const p of c.itemsMultiple) d.push(pC(l, p, r, a, t, o)); if (i) { const p = lC(d.map(C => C.value), c.displayType); let g = !1; if (-1 === [dn.AS_IS, dn.COMMA_SEPARATED].indexOf(c.displayType)) g = !0; else for (const C of d) if (C.isHtml) { g = !0; break } u = { value: p, isHtml: g } } else u = { values: d, displayType: c.displayType } } else u = null === c.item ? { value: "", isHtml: !1 } : pC(l, c.item, r, a, t, o); s[l] = u } return s } getSectionInfoSimple(n) { const t = {}; return this.sectionData.forEach((o, i) => { n.hasOwnProperty(i.id) && o.forEach(r => { const s = this.mustItemBeShown(r, n[i.id], i); t[r.name] = s.show }) }), t } getSectionInfo(n) { const t = {}; return this.sectionData.forEach((o, i) => { n.hasOwnProperty(i.id) && o.forEach(r => { t[r.name] = this.mustItemBeShown(r, n[i.id], i) }) }), t } getAttachmentInfo(n) { const t = {}; return this.attachmentData.forEach((o, i) => { n.hasOwnProperty(i.id) && o.forEach(r => { const s = this.mustItemBeShown(r, n[i.id], i); s.identityClass = hC(s), t[r.name] = s }) }), t } getInitialPlaceholderItems(n) { const t = {}; return this.placeholderData.forEach((o, i) => { n.hasOwnProperty(i.id) && (-1 === Q2.indexOf(i.type) ? o.forEach(r => { const s = new pi; let a = n[i.id]; if (a && i.type === V.DATE) { const u = new Date(a); a = Ir.getFormattedDate(u, r.dateFormat ? r.dateFormat : Ge.short) } s.value = a, s.questionId = i.id; const l = new Td; l.item = s, t[r.text] = l }) : o.forEach(r => { const s = new pi; s.value = n[i.id], s.questionId = i.id, (new Td).item = s, t[r.text] = this.createPlaceholderItem(r, n[i.id], i) })) }), t } mustItemBeShown(n, t, o) { const i = new H2; return null === t || (i.questionId = o.id, o.type === V.LIST_MULTIPLE ? (i.optionIds = n.optionIds, i.show = uC(n.optionIds, n.operator, t)) : o.type === V.DECISIONTABLE ? (i.optionIds = n.optionIds, i.show = cC(n.optionIds, n.operator, t)) : (o.type === V.BOOLEAN && (t = !0 === t ? "ja" : "nee"), i.show = n.optionIds[0] === t)), i } createPlaceholderItem(n, t, o) { const i = new Td; if (null === t) return i; if (o.type === V.LIST_MULTIPLE) { i.isMultiple = !0, i.displayType = n.multiplePlaceholderValuesDisplayType; const r = t; if (n.placeholderValueEqualsOptionValue) for (const s of Object.keys(r)) !0 === r[s] && i.itemsMultiple.push(Ad(o, s, !0)); else { const s = n.placeholderValues.filter(a => !(0 === a.optionIds.length || !a.content) && uC(a.optionIds, a.operator, r)); s.length > 0 ? i.itemsMultiple = s.map(a => dC(a, o, a.optionIds)) : Object.keys(r).some(l => !0 === r[l]) && (i.itemsMultiple = [Sd(o)]) } } else if (o.type === V.DECISIONTABLE) { i.isMultiple = !0, i.displayType = n.multiplePlaceholderValuesDisplayType; const r = t; if (n.placeholderValueEqualsOptionValue) for (const s of Object.keys(r)) r[s] === re.VALID && i.itemsMultiple.push(Ad(o, s, !0)); else { const s = n.placeholderValues.filter(a => !(0 === a.optionIds.length || !a.content) && cC(a.optionIds, a.operator, r)); s.length > 0 ? i.itemsMultiple = s.map(a => dC(a, o, a.optionIds)) : Object.keys(r).some(l => r[l] === re.VALID) && (i.itemsMultiple = [Sd(o)]) } } else if (n.placeholderValueEqualsOptionValue) i.item = Ad(o, t); else { const r = n.placeholderValues.find(s => !(0 === s.optionIds.length || !s.content) && (o.type === V.BOOLEAN && (t = !0 === t ? "ja" : "nee"), s.optionIds[0] === t)); if (r) { const s = new pi; s.canContainPlaceholders = !0, s.isHtml = r.editorType === br.RICH, s.value = r.content, s.questionId = o.id, i.item = s } else null !== t && (i.item = Sd(o)) } return i } removeEmptyListItems(n) { const t = document.createElement("template"); t.innerHTML = n; const o = t.content; o.querySelectorAll("li").forEach(s => { "" === s.textContent.trim() && s.remove() }); const r = document.createElement("template"); return r.content.appendChild(o), r.innerHTML } removeRedundantParagraphs(n) { const t = document.createElement("template"); t.innerHTML = n; const o = t.content; o.querySelectorAll("p").forEach(s => { s.textContent.replace(/(&nbsp;)+/g, ""), "" === s.textContent.trim() && s.remove() }); const r = document.createElement("template"); return r.content.appendChild(o), r.innerHTML } } let W2 = (() => { class e { constructor(t) { this.httpClient = t } getActivityExportContent(t, o) { const i = wr.publicApiBaseUrl + "smart-document", r = (new An).set("identifier", t).set("environment", o); return this.httpClient.get(i, { params: r }).pipe(Or()) } static #e = this.\u0275fac = function (o) { return new (o || e)(q(vr)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), K2 = (() => { class e { constructor(t) { this.httpClient = t, this.currentDecisionOutcomes = new Map } downloadHtmlAsDocx(t, o) { const r = []; r.push(t); const s = document.createElement("a"); s.href = window.URL.createObjectURL(new Blob(r, { type: "text/html" })), o && s.setAttribute("download", o), document.body.appendChild(s), s.click() } setCurrentDecisionOutcomes(t, o) { this.currentDecisionOutcomes.set(t, o.filter(i => i.state === re.VALID).map(i => i.id)) } getNewDecisionOutcomes(t, o) { const i = this.currentDecisionOutcomes.get(t), r = []; for (const s of o) s.state === re.VALID && (!i || -1 === i.indexOf(s.id)) && r.push(s.id); return r } downloadDocx(t, o, i, r, s, a, l, u, c) { this.httpClient.post(i + "download-docx", { fileNameIn: s, fileNameOut: a, organisationId: o, activityId: t, placeholderValues: l, sectionInfo: u, removeEmptyPlaceholders: c }, { responseType: "blob", headers: (new vt).append("x-api-key", r) }).subscribe({ next: g => { const C = g.type, w = []; w.push(g); const D = document.createElement("a"); D.href = window.URL.createObjectURL(new Blob(w, { type: C })), a && D.setAttribute("download", a), document.body.appendChild(D), D.click() }, error: g => { if (422 === g.status) { const C = new FileReader; C.onload = function () { const D = "Het Word-document kan niet gemaakt worden. " + JSON.parse(C.result).errors[0].msg; confirm(D) }, C.readAsText(g.error) } else confirm(g.message) } }) } downloadPdfForPreview(t, o, i, r, s) { return this.httpClient.post(i + "download-attachment", { organisationId: o, activityId: t, fileName: s }, { responseType: "blob", headers: (new vt).append("x-api-key", r) }) } downloadConvertedBuilderObjectAttachment(t, o, i, r, s) { return this.httpClient.post(i + "download-converted-builder-object-attachment", { organisationId: o, activityId: t, fileName: s }, { headers: (() => { let u = new vt; return u = u.append("x-api-key", r), u = u.append("Accept", "application/json"), u })() }) } downloadAttachment(t, o, i, r, s) { var u; this.httpClient.post(i + "download-attachment", { fileName: s, organisationId: o, activityId: t }, { responseType: "blob", headers: (new vt).append("x-api-key", r) }).subscribe({ next: u => { const c = u.type, d = []; d.push(u); const p = document.createElement("a"); p.href = window.URL.createObjectURL(new Blob(d, { type: c })), p.setAttribute("download", s), document.body.appendChild(p), p.click() }, error: (u = Id(function* (c) { let d = c.message; if (c.error) { const p = yield c.error.text(), g = JSON.parse(p); g.errors && g.errors.length > 0 && (d = "De bijlage kan niet worden gedownload. Foutbericht: " + g.errors[0].msg) } console.error(c), confirm(d) }), function (d) { return u.apply(this, arguments) }) }) } downloadAttachments(t, o, i, r, s, a) { var c; this.httpClient.post(i + "download-attachments", { fileNames: s, fileNameOut: a, organisationId: o, activityId: t }, { responseType: "blob", headers: (new vt).append("x-api-key", r) }).subscribe({ next: c => { const d = c.type, p = []; p.push(c); const g = document.createElement("a"); g.href = window.URL.createObjectURL(new Blob(p, { type: d })), a && g.setAttribute("download", a), document.body.appendChild(g), g.click() }, error: (c = Id(function* (d) { let p = d.message; if (d.error) { const g = yield d.error.text(), C = JSON.parse(g); C.errors && C.errors.length > 0 && (p = "De bijlagen kunnen niet worden gedownload. Foutbericht: " + C.errors[0].msg) } console.error(d), confirm(p) }), function (p) { return c.apply(this, arguments) }) }) } static #e = this.\u0275fac = function (o) { return new (o || e)(q(vr)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Y2(e, n) { 1 & e && no(0) } let J2 = (() => { class e { constructor() { this.title = "", this.closeMe = new Q } close() { this.closeMe.emit() } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-modal"]], inputs: { content: "content", title: "title" }, outputs: { closeMe: "closeMe" }, decls: 9, vars: 2, consts: [[1, "flo-modal-background", 3, "click"], [1, "flo-modal"], [1, "flo-modal-header"], ["type", "button", 1, "flo-form-button", 3, "click"], ["src", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAdVBMVEUAAABNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0N3NIOAAAAJnRSTlMAAQIDBAUGBwgRFRYZGiEjQ3l7hYaqtLm8vsDFx87a4uvv8fP1+bbY9ZEAAAB8SURBVBhXXY5LFoJAAMOCIP4VBRXEv5j7H9HFDOizu2TRFljedgCQHeocWHVaAWStXnKyl2oVWI+kd1XLvFV1D7Ng3qrWKYMZ+MdEhk3gbhw59KvlH0eTnf2mgiRwvQ7NW6aqNmncukKhnvo/zzlQ2PR/HgsAJkncH6XwAcr0FUY5BVeFAAAAAElFTkSuQmCC", "width", "16", "height", "16", "alt", ""], [1, "flo-modal-content"], [4, "ngTemplateOutlet"]], template: function (o, i) { 1 & o && (y(0, "div", 0), M("click", function () { return i.close() }), _(), y(1, "div", 1)(2, "div", 2)(3, "h2"), A(4), _(), y(5, "button", 3), M("click", function () { return i.close() }), k(6, "img", 4), _()(), y(7, "div", 5), v(8, Y2, 1, 0, "ng-container", 6), _()()), 2 & o && (f(4), j(i.title), f(4), h("ngTemplateOutlet", i.content)) }, dependencies: [ar] }) } return e })(); function Z2(e, n) { if (1 & e && (y(0, "div"), A(1), _()), 2 & e) { const t = m(); f(1), j(t.errorMessage) } } function X2(e, n) { if (1 & e && (y(0, "th"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function eP(e, n) { if (1 & e && (y(0, "td"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function tP(e, n) { if (1 & e && (y(0, "tr"), v(1, eP, 2, 1, "td", 3), _()), 2 & e) { const t = n.$implicit; f(1), h("ngForOf", t.values) } } function nP(e, n) { if (1 & e && (y(0, "table", 2)(1, "thead")(2, "tr"), v(3, X2, 2, 1, "th", 3), _()(), y(4, "tbody"), v(5, tP, 2, 1, "tr", 3), _()()), 2 & e) { const t = m(); f(3), h("ngForOf", t.tableData.header), f(2), h("ngForOf", t.tableData.rows) } } let oP = (() => { class e { constructor() { this.tableData = this.initTableData(), this.errorMessage = "" } ngOnChanges() { if (this.tableData = this.initTableData(), this.errorMessage = "", this.checkData) { for (const t of this.checkData.questions) this.tableData.rows.push({ id: t.id, question: t, values: [t.questionText] }); for (const t of this.checkData.outcomes) { if (!t.name) { this.errorMessage = `Voor uitkomst met titel ${t.title} ontbreekt property 'name'. Daarom is weergave van de beslissingstabel niet mogelijk`; break } t.answercombinations.forEach((o, i) => { this.tableData.header.push(t.name); for (const r of this.tableData.rows) if (o.answers.hasOwnProperty(r.id)) { let s = ""; const a = o.answers[r.id], l = r.question; s = l.type === be.BOOLEAN ? !0 === a ? this.checkData.trueLabel : this.checkData.falseLabel : l.options.find(c => c.id === a).value, r.values.push(s) } else r.values.push("") }) } } else this.errorMessage = "Geen checkdata beschikbaar" } initTableData() { return { header: [""], rows: [] } } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-decision-table"]], inputs: { checkData: "checkData" }, features: [Te], decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "flo-decision-table", 4, "ngIf"], [1, "flo-decision-table"], [4, "ngFor", "ngForOf"]], template: function (o, i) { 1 & o && (v(0, Z2, 2, 1, "div", 0), v(1, nP, 6, 2, "table", 1)), 2 & o && (h("ngIf", i.errorMessage), f(1), h("ngIf", !i.errorMessage)) }, dependencies: [ct, Ue] }) } return e })(), iP = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-check-icon"]], decls: 5, vars: 0, consts: [["xmlns", "http://www.w3.org/2000/svg", "x", "0px", "y", "0px", "viewBox", "0 0 69.525421 90.288139", "width", "69.525421", "height", "90.288139"], ["y", "1.5", "x", "1.5", "height", "87.288139", "width", "66.525421", 2, "opacity", "1", "fill", "#ffffff", "fill-opacity", "1", "stroke", "#000000", "stroke-width", "4", "stroke-miterlimit", "4", "stroke-dasharray", "none", "stroke-dashoffset", "0", "stroke-opacity", "1"], ["d", "m 24.254797,45.612638 c 1.145588,1.648055 2.497468,2.346949 4.502263,2.346949 1.718391,0 4.283138,-1.804198 4.283138,-1.804198 L 47.786124,26.681321 c 2.577581,-2.966494 6.826897,-10.143575 4.249315,-12.780461 -2.577581,-2.966499 -2.141999,-0.747437 -7.463854,3.678985 l -16.581944,19.04307 -5.435737,-9.053753 c -2.577582,-2.966496 -5.780854,-6.655583 -7.463856,-3.120758 -1.976223,4.150683 -1.059911,5.015316 1.718121,8.968632 z", 2, "fill", "#2fe22f", "fill-opacity", "1", "stroke", "#000000", "stroke-width", "0.62725466", "stroke-miterlimit", "4", "stroke-dasharray", "none", "stroke-opacity", "1"], ["d", "M 13.364408,59.974577 54.042374,59.550848", 2, "fill", "none", "stroke", "#000000", "stroke-width", "1.60000002", "stroke-linecap", "butt", "stroke-linejoin", "miter", "stroke-miterlimit", "4", "stroke-dasharray", "none", "stroke-opacity", "1"], ["d", "M 12.093221,71.838983 54.466102,71.415255", 2, "fill", "none", "stroke", "#000000", "stroke-width", "1.60000002", "stroke-linecap", "butt", "stroke-linejoin", "miter", "stroke-miterlimit", "4", "stroke-dasharray", "none", "stroke-opacity", "1"]], template: function (o, i) { 1 & o && (Kr(), y(0, "svg", 0), k(1, "rect", 1)(2, "path", 2)(3, "path", 3)(4, "path", 4), _()) } }) } return e })(), rP = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-preview-icon"]], decls: 3, vars: 0, consts: [["xmlns", "http://www.w3.org/2000/svg", "x", "0px", "y", "0px", "width", "120px", "height", "120px", "viewBox", "0 0 120 120"], ["d", "M60,19.089C22.382,19.089,0.053,60,0.053,60S22.382,100.91,60,100.91S119.947,60,119.947,60S97.618,19.089,60,19.089z\n\t M59.999,84.409C46.54,84.409,35.59,73.459,35.59,60c0-13.459,10.95-24.409,24.409-24.409c13.459,0,24.409,10.95,24.409,24.409\n\tC84.408,73.459,73.458,84.409,59.999,84.409z"], ["cx", "60", "cy", "60.583", "r", "14.409"]], template: function (o, i) { 1 & o && (Kr(), y(0, "svg", 0), k(1, "path", 1)(2, "circle", 2), _()) } }) } return e })(), sP = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-pdf-icon"]], decls: 18, vars: 0, consts: [["viewBox", "0 0 14 16", "height", "64", "width", "56", "xmlns", "http://www.w3.org/2000/svg"], ["transform", "matrix(.04589 0 0 .04589 -.66877 -.73379)"], ["points", "51.791 356.65 51.791 23.99 204.5 23.99 282.65 102.07 282.65 356.65", "fill", "#fff", "stroke-width", "212.65"], ["d", "m201.19 31.99 73.46 73.393v243.26h-214.86v-316.66h141.4m6.623-16h-164.02v348.66h246.85v-265.9z", "stroke-width", "21.791"], ["points", "282.65 356.65 51.791 356.65 51.791 23.99 204.5 23.99 206.31 25.8 206.31 100.33 280.9 100.33 282.65 102.07", "fill", "#fff", "stroke-width", "212.65"], ["d", "m198.31 31.99v76.337h76.337v240.32h-214.86v-316.66h138.52m9.5-16h-164.02v348.66h246.85v-265.9l-6.43-6.424h-69.907v-69.842z", "stroke-width", "21.791"], ["transform", "matrix(.04589 0 0 .04589 -.66877 -.73379)", "stroke-width", "21.791"], ["points", "258.31 87.75 219.64 87.75 219.64 48.667 258.31 86.38"], ["d", "m227.64 67.646 12.41 12.104h-12.41v-12.104m-5.002-27.229h-10.998v55.333h54.666v-12.742z"], ["transform", "matrix(.04589 0 0 .04589 -.66877 -.73379)", "fill", "#333", "stroke-width", "212.65"], ["points", "311.89 284.49 22.544 284.49 22.544 167.68 37.291 152.94 37.291 171.49 297.15 171.49 297.15 152.94 311.89 167.68"], ["d", "m303.65 168.63 1.747 1.747v107.62h-276.35v-107.62l1.747-1.747v9.362h272.85v-9.362m-12.999-31.385v27.747h-246.86v-27.747l-27.747 27.747v126h302.35v-126z"], ["x", "1.7219", "y", "7.9544", "width", "10.684", "height", "4.0307", "fill", "none"], ["transform", "matrix(.04589 0 0 .04589 1.7219 11.733)", "fill", "#fff", "stroke-width", "21.791"], ["d", "m9.216 0v-83.2h30.464q6.784 0 12.928 1.408 6.144 1.28 10.752 4.608 4.608 3.2 7.296 8.576 2.816 5.248 2.816 13.056 0 7.68-2.816 13.184-2.688 5.504-7.296 9.088-4.608 3.456-10.624 5.248-6.016 1.664-12.544 1.664h-8.96v26.368zm22.016-43.776h7.936q6.528 0 9.6-3.072 3.2-3.072 3.2-8.704t-3.456-7.936-9.856-2.304h-7.424z"], ["d", "m87.04 0v-83.2h24.576q9.472 0 17.28 2.304 7.936 2.304 13.568 7.296t8.704 12.8q3.2 7.808 3.2 18.816t-3.072 18.944-8.704 13.056q-5.504 5.12-13.184 7.552-7.552 2.432-16.512 2.432zm22.016-17.664h1.28q4.48 0 8.448-1.024 3.968-1.152 6.784-3.84 2.944-2.688 4.608-7.424t1.664-12.032-1.664-11.904-4.608-7.168q-2.816-2.56-6.784-3.456-3.968-1.024-8.448-1.024h-1.28z"], ["d", "m169.22 0v-83.2h54.272v18.432h-32.256v15.872h27.648v18.432h-27.648v30.464z"]], template: function (o, i) { 1 & o && (Kr(), y(0, "svg", 0)(1, "g", 1), k(2, "polygon", 2)(3, "path", 3), _(), y(4, "g", 1), k(5, "polygon", 4)(6, "path", 5), _(), y(7, "g", 6), k(8, "polygon", 7)(9, "path", 8), _(), y(10, "g", 9), k(11, "polygon", 10)(12, "path", 11), _(), k(13, "rect", 12), y(14, "g", 13), k(15, "path", 14)(16, "path", 15)(17, "path", 16), _()()) } }) } return e })(); function aP(e, n) { 1 & e && (y(0, "td", 8), k(1, "app-check-icon"), _()) } function lP(e, n) { 1 & e && (y(0, "td", 8), k(1, "app-pdf-icon"), _()) } function uP(e, n) { if (1 & e) { const t = R(); y(0, "tr", 2), v(1, aP, 2, 0, "td", 3), v(2, lP, 2, 0, "td", 3), y(3, "td", 4), A(4), _(), y(5, "td")(6, "button", 5), M("click", function () { const r = S(t).$implicit; return x(m().onDownloadButtonClicked(r)) }), k(7, "div", 6), _()(), y(8, "td")(9, "button", 7), M("click", function () { const r = S(t).$implicit; return x(m().onPreviewButtonClicked(r)) }), k(10, "app-preview-icon"), _()()() } if (2 & e) { const t = n.$implicit, o = m(); f(1), h("ngIf", o.isCheck(t)), f(1), h("ngIf", o.isPdf(t)), f(2), j(t) } } let cP = (() => { class e { constructor() { this.previewRequest = new Q, this.downloadRequest = new Q } isPdf(t) { return t.indexOf(".pdf") === t.length - 4 } isCheck(t) { return t.indexOf(".json") === t.length - 5 } onPreviewButtonClicked(t) { this.previewRequest.emit(t) } onDownloadButtonClicked(t) { this.downloadRequest.emit(t) } static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-attachments"]], inputs: { attachments: "attachments", smartDocumentName: "smartDocumentName" }, outputs: { previewRequest: "previewRequest", downloadRequest: "downloadRequest" }, decls: 2, vars: 1, consts: [[1, "flo-attachment-lines"], ["class", "flo-attachment-line", 4, "ngFor", "ngForOf"], [1, "flo-attachment-line"], ["class", "flo-attachment-icon", 4, "ngIf"], [1, "flo-attachment-name"], ["type", "button", "title", "download", 1, "flo-form-button", 3, "click"], [1, "flo-download-icon"], ["type", "button", "title", "preview", 1, "flo-form-button", 3, "click"], [1, "flo-attachment-icon"]], template: function (o, i) { 1 & o && (y(0, "table", 0), v(1, uP, 11, 3, "tr", 1), _()), 2 & o && (f(1), h("ngForOf", i.attachments)) }, dependencies: [ct, Ue, iP, rP, sP] }) } return e })(); const dP = ["formWrapper"], fP = ["preview"], hP = ["modalContentContainer"]; function pP(e, n) { if (1 & e) { const t = R(); y(0, "div", 5)(1, "div", 6, 7)(3, "app-form", 8), M("formChange", function (i) { return S(t), x(m().onFormChange(i)) })("focusedQuestionChange", function (i) { return S(t), x(m().onFocusedQuestionChange(i)) })("decisionChange", function (i) { return S(t), x(m().onDecisionChange(i)) })("switchToNextGroup", function () { return S(t), x(m().onSwitchToNextGroup()) }), _()(), y(4, "div")(5, "button", 9), M("click", function () { return S(t), x(m().clearAnswers()) }), A(6, "Wis formulier"), _()()() } if (2 & e) { const t = m(); f(3), h("formData", t.formData)("initialAnswers", t.initialAnswers)("showDependentQuestions", t.showDependentQuestions)("initialDecisionAnswers", t.initialDecisionAnswers)("cacheAnswers", t.cacheAnswers)("useAccordion", t.useAccordion)("allGroupsAvailable", t.allGroupsAvailable) } } function gP(e, n) { 1 & e && (y(0, "p")(1, "em"), A(2, "Hieronder vindt u een weergave van de antwoorden en de teksten die gezamenlijk het te downloaden Word document gaan vormen. Het is dus geen exacte weergave van het te downloaden Word document."), _()()) } function mP(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "label")(2, "input", 17), M("click", function () { return S(t), x(m(2).toggleEmptyPlaceholders()) }), _(), A(3, " niet ingevulde placeholders laten staan"), _()() } } function _P(e, n) { if (1 & e) { const t = R(); y(0, "div", 21)(1, "app-attachments", 22), M("downloadRequest", function (i) { return S(t), x(m(3).onDownloadRequested(i)) })("previewRequest", function (i) { return S(t), x(m(3).onPreviewRequested(i)) }), _()() } if (2 & e) { const t = m(3); f(1), h("attachments", t.neededAttachments)("smartDocumentName", t.templateName) } } function yP(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "div", 18)(2, "button", 19), M("click", function () { return S(t), x(m(2).toggleAttachments()) }), A(3), _()(), v(4, _P, 2, 2, "div", 20), _() } if (2 & e) { const t = m(2); f(3), _t("Bijlagen (", t.neededAttachments.length, ")"), f(1), h("ngIf", t.attachmentsVisible) } } function vP(e, n) { if (1 & e) { const t = R(); y(0, "section", 10, 11)(2, "h2", 12)(3, "span"), A(4, "Preview inhoud document"), _(), y(5, "button", 13), M("click", function () { return S(t), x(m().downloadPreview()) }), k(6, "div", 14), _()(), y(7, "div", 15), v(8, gP, 3, 0, "p", 3), v(9, mP, 4, 0, "div", 3), k(10, "section", 16), _(), v(11, yP, 5, 2, "div", 3), _() } if (2 & e) { const t = m(); f(8), h("ngIf", t.useWordTemplate), f(1), h("ngIf", t.showEmptyPlaceholdersOption), f(1), h("innerHTML", t.previewContent, vn), f(1), h("ngIf", t.neededAttachments.length > 0) } } function CP(e, n) { if (1 & e && (y(0, "div"), A(1), _()), 2 & e) { const t = m(); f(1), _t(" ", t.errorMessage, " ") } } function wP(e, n) { 1 & e && k(0, "iframe", 27), 2 & e && h("src", m(3).modalPdfObjectUrl, tu) } function DP(e, n) { 1 & e && k(0, "app-decision-table", 28), 2 & e && h("checkData", m(3).modalCheckData) } function bP(e, n) { 1 & e && k(0, "div", null, 29) } function EP(e, n) { if (1 & e && (v(0, wP, 1, 1, "iframe", 25), v(1, DP, 1, 1, "app-decision-table", 26), v(2, bP, 2, 0, "div", 3)), 2 & e) { const t = m(2); h("ngIf", "pdf" === t.modalContentType), f(1), h("ngIf", "check" === t.modalContentType), f(1), h("ngIf", "check" === t.modalContentType) } } function IP(e, n) { if (1 & e) { const t = R(); y(0, "app-modal", 23), M("closeMe", function () { return S(t), x(m().closeModal()) }), v(1, EP, 3, 3, "ng-template", null, 24, tr), _() } if (2 & e) { const t = kt(2), o = m(); h("content", t)("title", o.modalTitle) } } let TP = (() => { class e { constructor(t, o, i, r, s) { this.dataService = t, this.localeService = o, this.smartDocumentService = i, this.cd = r, this.sanitizer = s, this.useAccordion = !0, this.allGroupsAvailable = !1, this.environment = "staging", this.initialAnswers = {}, this.showDependentQuestions = !1, this.cacheAnswers = !0, this.initialDecisionAnswers = {}, this.showEmptyPlaceholdersOption = !1, this.useWordTemplate = !1, this.serviceApiUrl = "", this.serviceApKey = "", this.language = "nl", this.floFormChange = new Q, this.name = "myName", this.templateContent = "", this.attachments = [], this.attachmentsVisible = !1, this.previewContent = "", this.lastOutcomes = [], this.hasError = !1, this.errorMessage = "", this.formIsCompleted = !1, this.removeEmptyPlaceholders = !0, this.smartDocumentBuilder = new z2, this.showModal = !1, this.modalTitle = "", this.modalContentType = "check", this.modalCheckData = null, this.modalPdfObjectUrl = null } onKeydownHandler(t) { this.showModal && (this.showModal = !1) } ngOnInit() { } ngOnDestroy() { } get neededAttachments() { return this.attachments.filter(t => this.attachmentInfo.hasOwnProperty(t) && this.attachmentInfo[t].show) } ngOnChanges() { if (this.localeService.setLanguage(this.language), this.dataIdentifier && (this.identifier = this.dataIdentifier), this.dataEnvironment && (this.environment = this.dataEnvironment), this.dataUseAccordion && (this.useAccordion = "true" === this.dataUseAccordion.toLowerCase()), this.dataAllGroupsAvailable && (this.allGroupsAvailable = "true" === this.dataAllGroupsAvailable.toLowerCase()), this.dataAnswers && (this.initialAnswers = JSON.parse(this.dataAnswers)), this.dataShowDependentQuestions && (this.showDependentQuestions = JSON.parse(this.dataShowDependentQuestions.toLowerCase())), this.dataCacheAnswers && (this.cacheAnswers = JSON.parse(this.dataCacheAnswers.toLowerCase())), this.dataDecisionAnswers && (this.initialDecisionAnswers = JSON.parse(this.dataDecisionAnswers)), this.dataShowEmptyPlaceholdersOption && (this.showEmptyPlaceholdersOption = "true" === this.dataShowEmptyPlaceholdersOption.toLowerCase()), this.dataUseWordTemplate && (this.useWordTemplate = "true" === this.dataUseWordTemplate.toLowerCase()), this.serviceApiUrl = this.dataServiceApiUrl ? this.dataServiceApiUrl : wr.apiBaseUrl, this.dataServiceApiKey && (this.serviceApKey = this.dataServiceApiKey), this.identifier) this.dataService.getActivityExportContent(this.identifier, this.environment).subscribe(t => { this.extractContentProperties(t), this.hasError = !1, this.init() }, t => { this.hasError = !0, this.errorMessage = "Er is een fout opgetreden. De gegevens van het smart document kunnen niet opgehaald worden." }); else if (this.dataContent) { const t = JSON.parse(this.dataContent); this.extractContentProperties(t), this.hasError = !1, this.init() } else this.hasError = !0, this.errorMessage = "Er is een fout opgetreden. Er is geen inhoud beschikbaar." } extractContentProperties(t) { t.name && (this.name = t.name), t.attachments && (this.attachments = t.attachments), t.formData && (this.formData = t.formData), this.useWordTemplate ? t.wordAsHtmlTemplate && (this.templateContent = t.wordAsHtmlTemplate) : t.template && (this.templateContent = t.template), t.templateName && (this.templateName = t.templateName), t.organisationId && (this.organisationId = t.organisationId), t.activityId && (this.activityId = t.activityId) } init() { this.smartDocumentBuilder.init(this.templateContent, this.formData.questions, this.attachments), this.updatePreviewContent() } onFormChange(t) { this.formIsCompleted = t.formIsComplete, this.currentAnswers = t.answers, this.updatePreviewContent(), this.floFormChange.emit(t) } onSwitchToNextGroup() { this.formWrapperElement.nativeElement.scrollTop = 0 } updatePreviewContent() { this.currentAnswers ? (this.previewContent = this.smartDocumentBuilder.buildDocument(this.currentAnswers, this.removeEmptyPlaceholders, !0), this.attachmentInfo = this.smartDocumentBuilder.getAttachmentInfo(this.currentAnswers), this.setHighlightedElements()) : this.previewContent = this.templateContent } toggleEmptyPlaceholders() { this.removeEmptyPlaceholders = !this.removeEmptyPlaceholders, this.updatePreviewContent() } onFocusedQuestionChange(t) { this.focusInfo = t, this.lastOutcomes = [], this.setHighlightedElements() } onDecisionChange(t) { this.lastOutcomes = this.smartDocumentService.getNewDecisionOutcomes(t.formItemId, t.checkResult.outcomes), this.smartDocumentService.setCurrentDecisionOutcomes(t.formItemId, t.checkResult.outcomes) } downloadAttachments() { this.attachmentInfo = this.smartDocumentBuilder.getAttachmentInfo(this.currentAnswers); const t = []; for (const s of this.attachments) this.attachmentInfo[s] && this.attachmentInfo[s].show && t.push(s); const o = this.templateName.replace(/\s+/g, "-"), i = new Date, r = `bijlagen bij ${o} ${i.getDate()}-${i.getMonth() + 1}-${i.getFullYear()}--${i.toTimeString().substr(0, 5).replace(":", "-")}.zip`; this.smartDocumentService.downloadAttachments(this.activityId, this.organisationId, this.serviceApiUrl, this.serviceApKey, t, r) } downloadPreview() { if (this.dataUseWordTemplate) return void this.downloadFromWordTemplate(); const t = new Date, i = `${this.name.replace(/\s+/g, "-")} ${t.getDate()}-${t.getMonth() + 1}-${t.getFullYear()}--${t.toTimeString().substr(0, 5).replace(":", "-")}`, r = this.smartDocumentBuilder.buildDocument(this.currentAnswers, this.removeEmptyPlaceholders, !1); this.smartDocumentService.downloadHtmlAsDocx(`<!DOCTYPE html>\n<html lang="nl">\n<head>\n    <meta charset="UTF-8">\n    <title>${this.name}</title>\n    <style>\n        table {\n            border-collapse: collapse;\n        }\n        th, td {\n            border: 1px solid black;\n            padding: 5px;\n        }\n    </style>\n</head>\n<body>\n${r}\n</body>\n</html>`, i + ".html") } downloadFromWordTemplate() { const t = this.smartDocumentBuilder.getSubstituedPlaceholderItems(this.currentAnswers, !1, this.removeEmptyPlaceholders, !1), o = [], i = Object.keys(t); for (const l of i) if (t[l].hasOwnProperty("isHtml")) t[l].isHtml && o.push(l); else { const c = t[l]; let d = !1; for (const p of c.values) if (p.isHtml) { d = !0; break } d && o.push(l) } if (o.length > 0) { const l = "De inhoud voor placeholders <" + o.join(">, <") + "> bevat opgemaakte tekst. Dit wordt nog niet ondersteund in Word templates."; return void alert(l) } const r = this.templateName.replace(/\s+/g, "-"), s = new Date, a = `${r} ${s.getDate()}-${s.getMonth() + 1}-${s.getFullYear()}--${s.toTimeString().substr(0, 5).replace(":", "-")}.docx`; this.smartDocumentService.downloadDocx(this.activityId, this.organisationId, this.serviceApiUrl, this.serviceApKey, this.templateName, a, t, this.smartDocumentBuilder.getSectionInfoSimple(this.currentAnswers), this.removeEmptyPlaceholders) } toggleAttachments() { this.attachmentsVisible = !this.attachmentsVisible } clearAnswers() { this.initialAnswers = {}, this.initialDecisionAnswers = {} } onPreviewRequested(t) { t.endsWith(".json") ? this.previewCheck(t) : t.endsWith("pdf") && this.previewPdf(t) } onDownloadRequested(t) { this.smartDocumentService.downloadAttachment(this.activityId, this.organisationId, this.serviceApiUrl, this.serviceApKey, t) } previewCheck(t) { this.modalContentType = "check", this.smartDocumentService.downloadConvertedBuilderObjectAttachment(this.activityId, this.organisationId, this.serviceApiUrl, this.serviceApKey, t).subscribe(o => { this.showModal = !0, this.modalTitle = o.name, this.cd.detectChanges(); const i = this.modalContentContainerElement.nativeElement; i.innerHTML = "<flo-decision></flo-decision>"; const r = i.querySelector("flo-decision"); this.modalCheckData = o.data, r.setAttribute("data-check-data", JSON.stringify(o.data)), r.setAttribute("data-show-outcomes", "true"), r.setAttribute("data-outcomes-header", "Uitkomst"), r.setAttribute("data-outcomes-header-level", "3") }) } previewPdf(t) { var o; this.smartDocumentService.downloadPdfForPreview(this.activityId, this.organisationId, this.serviceApiUrl, this.serviceApKey, t).subscribe({ next: o => { this.modalContentType = "pdf", this.showModal = !0, this.modalTitle = t.slice(0, t.length - 4); const i = o.type, r = []; r.push(o), this.modalPdfObjectUrl = this.sanitizer.bypassSecurityTrustResourceUrl(window.URL.createObjectURL(new Blob(r, { type: i }))) }, error: (o = Id(function* (i) { let r = i.message; if (i.error) { const s = yield i.error.text(), a = JSON.parse(s); a.errors && a.errors.length > 0 && (r = "De bijlagen kunnen niet worden gedownload. Foutbericht: " + a.errors[0].msg) } console.error(i), confirm(r) }), function (r) { return o.apply(this, arguments) }) }) } closeModal() { this.showModal = !1 } setHighlightedElements() { if (!this.focusInfo && 0 === this.lastOutcomes.length) return; const t = this.previewElement.nativeElement; let o = ""; 0 === this.lastOutcomes.length ? o = this.focusInfo.optionId ? "._" + this.focusInfo.optionId : "._" + this.focusInfo.questionId : this.lastOutcomes.forEach((r, s) => { 0 !== s && (o += ", "), o += `._${r}` }); const i = setTimeout(() => { t.querySelectorAll(".flo-preview-highlight").forEach(u => { u.classList.remove("flo-preview-highlight") }), t.querySelectorAll(o).forEach(u => { u.classList.add("flo-preview-highlight") }); const a = t.querySelector(".flo-document-preview"), l = a.querySelector(o); if (l) { let u = l.offsetParent, c = l.offsetTop; for (; "BODY" !== u.nodeName;)u = u.offsetParent, c += u.offsetTop; const d = c - a.scrollTop; let p = 0; d < 150 && (p = d - 150), d > a.offsetHeight / 2 && (p = d - a.offsetHeight / 2); const g = a.scrollTop + p; a.scrollTop = g > 0 ? g : 0 } clearTimeout(i) }, 600) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(W2), b(Kt), b(K2), b(ti), b(Iy)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-smart-document"]], viewQuery: function (o, i) { if (1 & o && (so(dP, 5), so(fP, 5), so(hP, 5)), 2 & o) { let r; ro(r = ao()) && (i.formWrapperElement = r.first), ro(r = ao()) && (i.previewElement = r.first), ro(r = ao()) && (i.modalContentContainerElement = r.first) } }, hostBindings: function (o, i) { 1 & o && M("keydown.escape", function (s) { return i.onKeydownHandler(s) }, 0, cp) }, inputs: { dataIdentifier: "dataIdentifier", dataContent: "dataContent", dataUseAccordion: "dataUseAccordion", dataAllGroupsAvailable: "dataAllGroupsAvailable", dataEnvironment: "dataEnvironment", dataAnswers: "dataAnswers", dataShowDependentQuestions: "dataShowDependentQuestions", dataCacheAnswers: "dataCacheAnswers", dataDecisionAnswers: "dataDecisionAnswers", dataShowEmptyPlaceholdersOption: "dataShowEmptyPlaceholdersOption", dataUseWordTemplate: "dataUseWordTemplate", dataServiceApiUrl: "dataServiceApiUrl", dataServiceApiKey: "dataServiceApiKey", language: "language" }, outputs: { floFormChange: "floFormChange" }, features: [de([_d]), Te], decls: 5, vars: 4, consts: [[1, "flo-container"], ["class", "flo-form-section", 4, "ngIf"], ["class", "flo-preview", 4, "ngIf"], [4, "ngIf"], [3, "content", "title", "closeMe", 4, "ngIf"], [1, "flo-form-section"], [1, "flo-form-wrapper"], ["formWrapper", ""], [3, "formData", "initialAnswers", "showDependentQuestions", "initialDecisionAnswers", "cacheAnswers", "useAccordion", "allGroupsAvailable", "formChange", "focusedQuestionChange", "decisionChange", "switchToNextGroup"], ["type", "button", 1, "flo-form-button", 3, "click"], [1, "flo-preview"], ["preview", ""], [1, "flo-preview-title"], ["type", "button", "title", "Download document", 1, "flo-form-button", "flo-download-button", 3, "click"], [1, "flo-download-icon"], [1, "flo-document-preview"], [1, "flo-preview-content", 3, "innerHTML"], ["type", "checkbox", 3, "click"], [1, "flo-form-group-header"], ["type", "button", 1, "flo-form-button", "flo-form-group-button", 3, "click"], ["class", "flo-attachments-preview", 4, "ngIf"], [1, "flo-attachments-preview"], [3, "attachments", "smartDocumentName", "downloadRequest", "previewRequest"], [3, "content", "title", "closeMe"], ["content", ""], ["class", "flo-pdf-frame", 3, "src", 4, "ngIf"], [3, "checkData", 4, "ngIf"], [1, "flo-pdf-frame", 3, "src"], [3, "checkData"], ["modalContentContainer", ""]], template: function (o, i) { 1 & o && (y(0, "section", 0), v(1, pP, 7, 7, "div", 1), v(2, vP, 12, 4, "section", 2), v(3, CP, 2, 1, "div", 3), _(), v(4, IP, 3, 2, "app-modal", 4)), 2 & o && (f(1), h("ngIf", i.formData), f(1), h("ngIf", i.formData), f(1), h("ngIf", i.hasError), f(1), h("ngIf", i.showModal)) }, dependencies: [Ue, rC, J2, oP, cP], encapsulation: 2 }) } return e })(); class gC extends qn { constructor(n) { super(), this._value = n } get value() { return this.getValue() } _subscribe(n) { const t = super._subscribe(n); return !t.closed && n.next(this._value), t } getValue() { const { hasError: n, thrownError: t, _value: o } = this; if (n) throw t; return this._throwIfClosed(), o } next(n) { super.next(this._value = n) } } function AP(e, n) { if (1 & e) { const t = R(); y(0, "app-decision", 5), M("decisionChange", function (i) { const s = S(t).$implicit; return x(m(2).onDecisionChange(s.identifier, i)) }), _() } if (2 & e) { const t = n.$implicit, o = m(2); h("checkData", t)("questionDisplayType", o.questionDisplayType)("answers", o.checkAnswers[t.identifier]) } } function SP(e, n) { if (1 & e) { const t = R(); y(0, "app-question", 6), M("answerGiven", function (i) { return S(t), x(m(2).onOptionalChecksQuestionAnswerChanged(i)) }), _() } if (2 & e) { const t = m(2); h("question", t.optionalChecksQuestion)("currentAnswer", t.optionalChecksQuestionAnswer)("listMultipleExcludeAnswer", t.optionalChecksQuestionNoneAnswerDescription) } } function xP(e, n) { if (1 & e) { const t = R(); y(0, "app-decision", 5), M("decisionChange", function (i) { const s = S(t).$implicit; return x(m(2).onDecisionChange(s.identifier, i)) }), _() } if (2 & e) { const t = n.$implicit, o = m(2); h("checkData", t)("questionDisplayType", o.questionDisplayType)("answers", o.checkAnswers[t.identifier]) } } function MP(e, n) { if (1 & e && (y(0, "div", 2), v(1, AP, 1, 3, "app-decision", 3), Zi(2, "async"), v(3, SP, 1, 3, "app-question", 4), v(4, xP, 1, 3, "app-decision", 3), Zi(5, "async"), _()), 2 & e) { const t = m(); f(1), h("ngForOf", Xi(2, 3, t.mandatoryChecks$)), f(2), h("ngIf", t.optionalChecksQuestion), f(1), h("ngForOf", Xi(5, 5, t.optionalChecks$)) } } function FP(e, n) { if (1 & e && (y(0, "div"), A(1), _()), 2 & e) { const t = m(); f(1), j(t.dataInputError) } } let OP = (() => { class e { constructor(t) { this.localeService = t, this.dataQuestionDisplayType = "list", this.questionDisplayType = ve.LIST, this.answers = {}, this.language = "nl", this.floCombiDecisionChange = new Q, this.dataInputError = null, this.mandatoryChecks$ = new gC([]), this.optionalChecksQuestion = null, this.optionalChecks$ = new gC([]), this.optionalChecksQuestionId = "optional_check_question", this.optionalChecksQuestionNoneAnswerDescription = "geen van bovenstaande", this.checkAnswers = {}, this.optionalChecksQuestionAnswer = [], this.selectedOptionChecksIdentifiers = [], this.currentResults = {} } ngOnChanges() { this.localeService.setLanguage(this.language), this.dataCheckData && (this.checkData = JSON.parse(this.dataCheckData)), this.dataQuestionDisplayType && (-1 === [ve.LIST.toString(), ve.LIST_CUMULATIVE.toString()].indexOf(this.dataQuestionDisplayType) ? this.dataInputError = "Data-attribute 'data-question-display-type' has an invalid value. Accepted values are:\n        list, list-cumulative" : this.questionDisplayType = this.dataQuestionDisplayType), this.dataAnswers && (this.answers = JSON.parse(this.dataAnswers)), this.checkData ? (this.initAnswers(), this.checkData.optionalChecks.length > 0 ? this.constructOptionalChecksQuestion() : this.optionalChecksQuestion = null, this.initMandatoryChecks(), this.initOptionalChecks()) : (this.mandatoryChecks$.next([]), this.optionalChecks$.next([]), this.optionalChecksQuestion = null) } onOptionalChecksQuestionAnswerChanged(t) { this.optionalChecksQuestionAnswer = t.answers, this.selectedOptionChecksIdentifiers = [], this.optionalChecksQuestionAnswer.forEach(r => { const s = r - 1; s < this.checkData.optionalChecks.length && this.selectedOptionChecksIdentifiers.push(this.checkData.optionalChecks[s].identifier) }), this.initOptionalChecks(), this.emitResult() } onDecisionChange(t, o) { this.handleSingleCheckResult(t, o) } initAnswers() { this.checkAnswers = {}, this.checkData.checks.forEach(t => { this.checkAnswers[t.identifier] = this.answers.hasOwnProperty(t.identifier) ? this.answers[t.identifier] : {} }), this.checkData.optionalChecks.length > 0 && (this.optionalChecksQuestionAnswer = this.answers.hasOwnProperty(this.optionalChecksQuestionId) ? this.answers[this.optionalChecksQuestionId] : []) } constructOptionalChecksQuestion() { const t = { id: this.optionalChecksQuestionId, questionText: this.checkData.optionalCheckQuestionDescription, type: be.LIST_MULTIPLE, options: [], canBeReUsed: !1 }; this.checkData.optionalChecks.forEach((o, i) => { t.options.push({ id: i + 1, value: o.optionDescription, explanation: o.explanation ? o.explanation : null }) }), t.options.push({ id: t.options.length + 1, value: this.optionalChecksQuestionNoneAnswerDescription }), this.optionalChecksQuestion = t } handleSingleCheckResult(t, o) { this.currentResults[t] = o, this.emitResult() } emitResult() { this.checkData.optionalChecks.forEach(o => { -1 === this.selectedOptionChecksIdentifiers.indexOf(o.identifier) && this.currentResults.hasOwnProperty(o.identifier) && delete this.currentResults[o.identifier] }); const t = {}; Object.keys(this.currentResults).forEach(o => { t[o] = this.currentResults[o].answers }), this.checkData.optionalChecks.length > 0 && (t[this.optionalChecksQuestionId] = this.optionalChecksQuestionAnswer), this.floCombiDecisionChange.emit({ checkResults: this.currentResults, answers: t }) } initMandatoryChecks() { const t = []; this.checkData.checks.forEach(o => { this.checkData.optionalChecks.find(i => i.identifier === o.identifier) || t.push(o) }), this.mandatoryChecks$.next(t) } initOptionalChecks() { const t = []; this.checkData.checks.forEach(o => { this.checkData.optionalChecks.find(i => i.identifier === o.identifier) && -1 !== this.selectedOptionChecksIdentifiers.indexOf(o.identifier) && t.push(o) }), this.optionalChecks$.next(t) } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-combi-decision"]], inputs: { dataCheckData: "dataCheckData", dataQuestionDisplayType: "dataQuestionDisplayType", dataAnswers: "dataAnswers", language: "language" }, outputs: { floCombiDecisionChange: "floCombiDecisionChange" }, features: [Te], decls: 2, vars: 2, consts: [["class", "flo-combi-decision", 4, "ngIf"], [4, "ngIf"], [1, "flo-combi-decision"], [3, "checkData", "questionDisplayType", "answers", "decisionChange", 4, "ngFor", "ngForOf"], [3, "question", "currentAnswer", "listMultipleExcludeAnswer", "answerGiven", 4, "ngIf"], [3, "checkData", "questionDisplayType", "answers", "decisionChange"], [3, "question", "currentAnswer", "listMultipleExcludeAnswer", "answerGiven"]], template: function (o, i) { 1 & o && (v(0, MP, 6, 7, "div", 0), v(1, FP, 2, 1, "div", 1)), 2 & o && (h("ngIf", !i.dataInputError), f(1), h("ngIf", i.dataInputError)) }, dependencies: [ct, Ue, oC, Dd, Mc] }) } return e })(), NP = (() => { class e { static #e = this.\u0275fac = function (o) { return new (o || e) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [oi, Ia, ad, Uv, md, ld] }) } return e })(); const PP = { datum: "", functioneleStructuurRefs: [{ functioneleStructuurRef: "", antwoorden: [] }], _geo: { intersects: {} } }; let mC = (() => { class e { constructor(t) { this.httpClient = t, this.headers = { Accept: "application/hal+json" } } bepaal(t, o, i, r = !1, s = []) { const l = JSON.parse(JSON.stringify(PP)); return l.datum = (new Date).toLocaleDateString("nl-NL", { dateStyle: "short" }), l.functioneleStructuurRefs[0].functioneleStructuurRef = o, l._geo.intersects = i, l.functioneleStructuurRefs[0].antwoorden = s, this.httpClient.post("/rtr-api/bepaal", { postBody: l, type: t, usePreEnvironment: r }).pipe(Or()) } getToelichting(t, o) { return this.httpClient.get("/rtr-api/toelichtingen/" + t, { params: { usePreEnvironment: o.toString() } }).pipe(Or()) } static #e = this.\u0275fac = function (o) { return new (o || e)(q(vr)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), Tr = (() => { class e { constructor(t) { this.rtrApiService = t, this.usePreEnvironment = !1 } convertVraagToQuestion(t, o = !0) { const i = this.getFormQuestionTypeFromVraag(t); if (!i) return null; const r = { id: t.id.toString(), type: i, questionText: t.tekst, uitvoeringsregelType: t.uitvoeringsregelType }; if (-1 !== [V.LIST_MULTIPLE, V.LIST_SINGLE].indexOf(r.type)) { const s = t.opties.sort((a, l) => a.sequenceId - l.sequenceId); r.options = s.map(a => this.convertRtrOptionToFloOption(a)), r.displayType = "List" } return t.toelichting && (r.explanation = this.convertRtrToelichtingToExplanation(t.toelichting)), r } convertToelichtingToExplanation(t, o, i) { const r = { content: o, position: "middle", showImmediately: t }; return i && (r.extraContent = i), r } getFormQuestionTypeFromVraag(t) { if ("vraag" === t.uitvoeringsregelType) { if ("lijstwaarde" === t.antwoordType) return "enkelAntwoord" === t.optieType ? V.LIST_SINGLE : V.LIST_MULTIPLE; switch (t.antwoordType) { case "string": return t.invoertype && "tekstveld" === t.invoertype ? V.TEXT_FIELD : V.TEXT_LINE; case "boolean": return V.BOOLEAN; case "datum": return V.DATE; case "numeriek": return V.NUMBER; default: console.error("Onbekend vraagtype bij import van uitvoeringsregel") } } else { if ("geoVerwijzing" === t.uitvoeringsregelType) return "lijstwaarde" === t.antwoordType && "enkelAntwoord" === t.optieType ? V.LIST_SINGLE : (console.error("Unknown question type", t), null); console.error(`Uitvoeringsregeltype ${t.uitvoeringsregelType} wordt nog niet ondersteund`) } return null } convertRtrOptionToFloOption(t) { const o = { id: t.sequenceId.toString(), value: t.optieTekst }; return t.toelichting && (o.explanation = this.convertRtrToelichtingToExplanation(t.toelichting)), t.optieGeenVanBovenstaande && console.warn("Option with optieGeenVanBovenstaande =true", t), o } convertRtrToelichtingToExplanation(t) { const o = { content: "", content$: this.rtrApiService.getToelichting(t.korteToelichtingId, this.usePreEnvironment), position: "middle", showImmediately: t.belangrijk }; return t.langeToelichtingId && (o.extraContent$ = this.rtrApiService.getToelichting(t.langeToelichtingId, this.usePreEnvironment)), o } static #e = this.\u0275fac = function (o) { return new (o || e)(q(mC)) }; static #t = this.\u0275prov = J({ token: e, factory: e.\u0275fac }) } return e })(), xd = (() => { class e { constructor(t) { this.usePreEnvironment = !1, this.useGroups = !0, this.showExplanations = !0, this.logicalAnswerChanged = new Q, this.geoverwijzingenChanged = new Q, this.locationIsInsideWorkingArea = null, this.dataAttributeParsingService = t.get(Ed), this.rtrApiService = t.get(mC), this.conversionService = t.get(Tr) } ngOnChanges() { if (this.dataAttributeParsingService.errors = [], this.dataFunctioneleStructuurRef ? this.functioneleStructuurRef = this.dataFunctioneleStructuurRef : this.dataAttributeParsingService.errors.push("Attribute 'data-functionele-structuur-ref' should be used and have a value"), this.geometry = null, this.dataGeometry) { try { this.geometry = JSON.parse(this.dataGeometry) } catch { this.dataAttributeParsingService.errors.push("Value for attribute 'data-geo' is invalid") } (!this.geometry || !this.geometry.hasOwnProperty("type")) && this.dataAttributeParsingService.errors.push("Value for attribute 'data-geo' is invalid. Property 'type' is missing") } this.usePreEnvironment = !1, this.conversionService.usePreEnvironment = this.usePreEnvironment, this.dataUsePreEnvironment && (this.usePreEnvironment = this.dataAttributeParsingService.parseBooleanDataAttribute("dataUsePreEnvironment", "data-use-pre-environment", this), this.conversionService.usePreEnvironment = this.usePreEnvironment), this.useGroups = !0, this.dataUseGroups && (this.useGroups = this.dataAttributeParsingService.parseBooleanDataAttribute("dataUseGroups", "data-use-groups", this)), this.showExplanations = !0, this.dataShowExplanations && (this.showExplanations = this.dataAttributeParsingService.parseBooleanDataAttribute("dataShowExplanations", "data-show-explanations", this)) } onGeoverwijzingenChanged(t) { this.geoverwijzingenChanged.emit(t) } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["ng-component"]], inputs: { dataFunctioneleStructuurRef: "dataFunctioneleStructuurRef", dataGeometry: "dataGeometry", dataUsePreEnvironment: "dataUsePreEnvironment", dataUseGroups: "dataUseGroups", dataShowExplanations: "dataShowExplanations" }, outputs: { logicalAnswerChanged: "logicalAnswerChanged", geoverwijzingenChanged: "geoverwijzingenChanged" }, features: [Te], decls: 0, vars: 0, template: function (o, i) { }, encapsulation: 2 }) } return e })(); class kP { constructor() { this.name = "", this.questions = [], this.currentQuestionsCnt = 0, this.currentAnsweredQuestionsCnt = 0 } } const LP = function (e) { return { "flo-explanation-visible": e } }; function RP(e, n) { if (1 & e) { const t = R(); y(0, "button", 9), M("click", function () { return S(t), x(m().toggleExplanation()) }), _() } if (2 & e) { const t = m(); h("ngClass", Se(2, LP, t.explanationIsVisible)), De("aria-label", t.showExplanationButtonLabel) } } function VP(e, n) { if (1 & e) { const t = R(); y(0, "div", 10)(1, "app-explanation", 11), M("hideMe", function () { return S(t), x(m().toggleExplanation()) }), _()() } if (2 & e) { const t = m(); f(1), h("content", t.question.explanation.content)("extraContent", t.question.explanation.extraContent || "")("content$", t.question.explanation.content$ || null)("extraContent$", t.question.explanation.extraContent$ || null)("showHideButton", !t.question.explanation.showImmediately) } } function BP(e, n) { if (1 & e && (y(0, "div", 12)(1, "label", 13), k(2, "input", 14), A(3), _(), y(4, "label", 15), k(5, "input", 14), A(6), _()()), 2 & e) { const t = m(); f(1), qe("id", t.questionIdAttr + "yes"), f(1), qe("name", t.question.id), h("value", !0)("formControlName", t.question.id), De("name", t.question.id), f(1), j(t.trueLabel), f(2), qe("name", t.question.id), h("value", !1)("formControlName", t.question.id), De("name", t.question.id), f(1), j(t.falseLabel) } } function jP(e, n) { if (1 & e && (y(0, "option", 19), A(1), _()), 2 & e) { const t = n.$implicit; h("ngValue", t.id), f(1), j(t.value) } } function HP(e, n) { if (1 & e && (y(0, "div", 12)(1, "select", 16), A(2), k(3, "option", 17), v(4, jP, 2, 2, "option", 18), _()()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id), f(1), _t(' attr.aria-labelledby="', t.questionIdAttr, '" '), f(1), h("ngValue", null), f(1), h("ngForOf", t.question.options) } } function UP(e, n) { if (1 & e && (Ee(0), k(1, "app-preview-option", 22), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("questionId", o.question.id)("group", o.formGroup)("control", o.getControl(o.formGroup, o.question.id))("option", t)("showExplanations", o.showExplanations) } } function $P(e, n) { 1 & e && (y(0, "em"), A(1, "Vooraf ingevuld antwoord"), _()) } function qP(e, n) { if (1 & e && (y(0, "em"), A(1), _()), 2 & e) { const t = m(3); f(1), _t("Het vooraf ingevulde antwoord is veranderd. Dit was '", t.question.vooringevuldAntwoordValue, "'.") } } function GP(e, n) { if (1 & e && (y(0, "div"), v(1, $P, 2, 0, "em", 21), v(2, qP, 2, 1, "em", 21), _()), 2 & e) { const t = m(2); f(1), h("ngIf", t.getControl(t.formGroup, t.question.id).value === t.question.vooringevuldAntwoordId), f(1), h("ngIf", t.getControl(t.formGroup, t.question.id).value !== t.question.vooringevuldAntwoordId) } } function QP(e, n) { if (1 & e && (y(0, "div", 12), v(1, UP, 2, 5, "ng-container", 20), v(2, GP, 3, 2, "div", 21), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options), f(1), h("ngIf", "geoVerwijzing" === t.question.uitvoeringsregelType) } } function zP(e, n) { if (1 & e && k(0, "input", 24), 2 & e) { const t = m().$implicit, o = m(2); h("value", t.id)("formControl", o.getCheckBoxControl(t.id)) } } function WP(e, n) { if (1 & e && k(0, "input", 24), 2 & e) { const t = m().$implicit, o = m(2); h("value", t.id)("formControl", o.getCheckBoxControl(t.id)) } } function KP(e, n) { if (1 & e && (y(0, "div")(1, "label", 13), v(2, zP, 1, 2, "input", 23), v(3, WP, 1, 2, "input", 23), A(4), _()()), 2 & e) { const t = n.$implicit, o = n.index, i = m(2); f(1), qe("id", i.questionIdAttr + "firstcheckbox"), f(1), h("ngIf", 0 === o), f(1), h("ngIf", o > 0), f(1), j(t.value) } } function YP(e, n) { if (1 & e && (y(0, "div", 12), v(1, KP, 5, 4, "div", 20), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function JP(e, n) { if (1 & e && (Ee(0), k(1, "app-preview-option", 25), Ie()), 2 & e) { const t = n.$implicit, o = m(2); f(1), h("questionId", o.question.id)("group", o.formGroup)("control", o.getControl(o.getGroup(o.formGroup, o.question.id), t.id))("option", t)("showExplanations", o.showExplanations) } } function ZP(e, n) { if (1 & e && (y(0, "div", 12), v(1, JP, 2, 5, "ng-container", 20), _()), 2 & e) { const t = m(); f(1), h("ngForOf", t.question.options) } } function XP(e, n) { if (1 & e && (y(0, "div", 12), k(1, "input", 26), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function ek(e, n) { if (1 & e && (y(0, "div", 12), k(1, "textarea", 27), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function tk(e, n) { if (1 & e && (y(0, "div", 12), k(1, "input", 28), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function nk(e, n) { if (1 & e && (y(0, "div", 12), k(1, "input", 29), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function ok(e, n) { if (1 & e && (y(0, "div", 12), k(1, "input", 29), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } function ik(e, n) { if (1 & e && (y(0, "div", 12), k(1, "input", 30), _()), 2 & e) { const t = m(); f(1), h("formControlName", t.question.id) } } const rk = function (e) { return { pristine: e } }; let sk = (() => { class e extends yd { constructor(t) { super(t), this.questionIsVisible = !1, this.showExplanations = !0 } static #e = this.\u0275fac = function (o) { return new (o || e)(b(Kt)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-rtr-question"]], inputs: { questionIsVisible: "questionIsVisible", showExplanations: "showExplanations" }, features: [oe], decls: 21, vars: 20, consts: [[1, "flo-question-section", 3, "ngClass"], ["tabindex", "0", 1, "flo-question-container", 3, "formGroup"], ["questionContainer", ""], [1, "sr-only", 3, "id"], [1, "flo-question-description-container"], ["aria-hidden", "true", 1, "flo-question-description"], ["class", "flo-explanation-show flo-explanation-button", "aria-expanded", "false", "type", "button", 3, "ngClass", "click", 4, "ngIf"], ["class", "flo-explanation-container", 4, "ngIf"], ["class", "flo-question-answers", 4, "ngIf"], ["aria-expanded", "false", "type", "button", 1, "flo-explanation-show", "flo-explanation-button", 3, "ngClass", "click"], [1, "flo-explanation-container"], [3, "content", "extraContent", "content$", "extraContent$", "showHideButton", "hideMe"], [1, "flo-question-answers"], [3, "id"], ["type", "radio", 3, "name", "value", "formControlName"], [1, "flo-boolean-false"], [3, "formControlName"], ["disabled", "", "hidden", "", 3, "ngValue"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["inputType", "radio", 3, "questionId", "group", "control", "option", "showExplanations"], ["type", "checkbox", 3, "value", "formControl", 4, "ngIf"], ["type", "checkbox", 3, "value", "formControl"], ["inputType", "checkbox", 3, "questionId", "group", "control", "option", "showExplanations"], ["type", "text", 3, "formControlName"], ["rows", "4", 3, "formControlName"], ["type", "text", "inputmode", "numeric", "pattern", "[0-9]*", 3, "formControlName"], ["type", "date", 3, "formControlName"], ["type", "time", 3, "formControlName"]], template: function (o, i) { 1 & o && (y(0, "div", 0)(1, "fieldset", 1, 2)(3, "legend", 3), A(4), _(), y(5, "div", 4)(6, "span", 5), A(7), _(), v(8, RP, 1, 4, "button", 6), v(9, VP, 2, 5, "div", 7), _(), v(10, BP, 7, 11, "div", 8), v(11, HP, 5, 4, "div", 8), v(12, QP, 3, 2, "div", 8), v(13, YP, 2, 1, "div", 8), v(14, ZP, 2, 1, "div", 8), v(15, XP, 2, 1, "div", 8), v(16, ek, 2, 1, "div", 8), v(17, tk, 2, 1, "div", 8), v(18, nk, 2, 1, "div", 8), v(19, ok, 2, 1, "div", 8), v(20, ik, 2, 1, "div", 8), _()()), 2 & o && (h("ngClass", Se(18, rk, !i.hasAnswer())), f(1), h("formGroup", i.formGroup), f(2), qe("id", i.questionIdAttr), f(1), _t("", i.question.questionText, ">"), f(3), j(i.question.questionText), f(1), h("ngIf", i.showExplanations && i.question.explanation && !i.question.explanation.showImmediately), f(1), h("ngIf", i.showExplanations && i.question.explanation && i.explanationIsVisible && i.questionIsVisible), f(1), h("ngIf", i.question.type === i.QuestionType.BOOLEAN), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_SINGLE && !i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_SINGLE && i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_MULTIPLE && !i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.LIST_MULTIPLE && i.listOptionsWithExplanation), f(1), h("ngIf", i.question.type === i.QuestionType.TEXT_LINE), f(1), h("ngIf", i.question.type === i.QuestionType.TEXT_FIELD), f(1), h("ngIf", i.question.type === i.QuestionType.NUMBER), f(1), h("ngIf", i.question.type === i.QuestionType.DATE), f(1), h("ngIf", i.question.type === i.QuestionType.DATE_TIME), f(1), h("ngIf", i.question.type === i.QuestionType.TIME)) }, dependencies: [zt, ct, Ue, fi, Yv, Da, ba, co, Tn, ui, li, Bn, jn, Ea, _r, Hn, wa], styles: [".sr-only[_ngcontent-%COMP%]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}"] }) } return e })(); const ak = function (e) { return { "flo-form-group-button-active": e } }; function lk(e, n) { if (1 & e) { const t = R(); y(0, "div", 7)(1, "button", 8), M("click", function () { S(t); const i = m().$implicit; return x(m().toggleGroup(i.name)) }), A(2), y(3, "span", 9), A(4), _()()() } if (2 & e) { const t = m().$implicit, o = m(); f(1), h("ngClass", Se(4, ak, o.currentGroupName === t.name)), f(1), _t(" ", t.name, " "), f(2), Ps("", t.currentAnsweredQuestionsCnt, " / ", t.currentQuestionsCnt, "") } } const _C = function (e) { return { "flo-inner-hidden": e } }; function uk(e, n) { if (1 & e && k(0, "app-rtr-question", 10), 2 & e) { const t = n.$implicit, o = m(2); h("ngClass", Se(8, _C, -1 === o.questionsToShow.indexOf(t.id) || -1 === o.visibleQuestions.indexOf(t.id)))("question", t)("formGroup", o.formGroup)("trueLabel", "ja")("falseLabel", "nee")("questionIsVisible", -1 !== o.questionsToShow.indexOf(t.id))("listOptionsWithExplanation", t.displayType && "List" === t.displayType)("showExplanations", o.showExplanations) } } function ck(e, n) { if (1 & e && (y(0, "div", 3), v(1, lk, 5, 6, "div", 4), y(2, "div", 5), v(3, uk, 1, 10, "app-rtr-question", 6), _()()), 2 & e) { const t = n.$implicit, o = m(); h("ngClass", Se(4, _C, -1 === o.visibleGroups.indexOf(t.name))), f(1), h("ngIf", o.useGroups), f(2), h("ngForOf", t.questions)("ngForTrackBy", o.questionTrackBy) } } function dk(e, n) { if (1 & e) { const t = R(); y(0, "div", 11)(1, "button", 12), M("click", function () { return S(t), x(m().clearForm()) }), A(2, "Wis formulier"), _()() } } let Md = (() => { class e { constructor(t, o) { this.formService = t, this.conversionService = o, this.vraagGroepen = [], this.useGroups = !0, this.showExplanations = !0, this.answers = {}, this.logicalAnswerChanged = new Q, this.geoverwijzingenChanged = new Q, this.groups = [], this.currentGroupName = "", this.questionsToShow = [], this.visibleGroups = [], this.visibleQuestions = [], this.questions = new Map, this.currentGeoverwijzingen = [], this.formChangeSubscriptions = [], this.isFirstRender = !0 } ngOnChanges(t) { t.vraagGroepen && 0 !== this.vraagGroepen.length && this.render() } ngOnDestroy() { this.unsubscribeFormChangeSubscriptions() } questionTrackBy(t, o) { return o.id } groupTrackBy(t, o) { return o.name } toggleGroup(t) { this.currentGroupName === t ? (this.currentGroupName = "", this.questionsToShow = []) : (this.currentGroupName = t, this.questionsToShow = this.groups.find(o => o.name === t).questions.map(o => o.id)) } clearForm() { this.answers = {}, this.logicalAnswerChanged.emit([]), this.currentGroupName = this.groups[0].name } render() { this.currentGeoverwijzingen = []; const t = this.vraagGroepen.sort((i, r) => i.prioriteit - r.prioriteit); this.groups = []; const o = Array.from(this.questions.values()); this.questions.clear(); for (const i of t) { const r = new kP; r.name = i.groepNaam; const s = i.vragen.sort((a, l) => a.prioriteit - l.prioriteit); r.questions = [], s.forEach(a => { let l = o.find(u => u.id === a.id.toString()); l || (l = this.conversionService.convertVraagToQuestion(a, this.showExplanations)), "geoVerwijzing" === l.uitvoeringsregelType && (this.setGeoAnswers(l, a), this.addGeoverwijzing(a)), l && r.questions.push(l) }), r.currentQuestionsCnt = r.questions.length, r.currentAnsweredQuestionsCnt = this.getCurrentAnsweredQuestionsCnt(r.questions), this.groups.push(r); for (const a of r.questions) this.questions.set(a.id, a) } this.updateVisibleGroups(t), this.updateVisibleQuestions(t), this.geoverwijzingenChanged.emit(this.currentGeoverwijzingen), this.vraagGroepen = t, this.isFirstRender && this.useGroups && this.groups.length > 0 && (this.currentGroupName = this.groups[0].name), this.useGroups ? this.groups.length > 0 && (this.questionsToShow = this.groups.find(i => i.name === this.currentGroupName).questions.map(i => i.id.toString())) : this.questionsToShow = [].concat(this.visibleQuestions), this.formGroup = this.formService.buildFormData(Array.from(this.questions.values()), this.answers), this.handleFormChanges(), this.isFirstRender = !1 } handleFormChanges() { this.unsubscribeFormChangeSubscriptions(), this.questions.forEach((t, o) => { -1 !== [V.BOOLEAN, V.LIST_MULTIPLE, V.LIST_SINGLE, V.NUMBER, V.DATE].indexOf(t.type) && this.formGroup.get(o).valueChanges.subscribe(r => { this.cacheAndEmitAntwoorden() }) }) } updateVisibleGroups(t) { this.visibleGroups = []; for (const o of t) this.visibleGroups.push(o.groepNaam) } updateVisibleQuestions(t) { this.visibleQuestions = []; for (const o of t) for (const i of o.vragen) this.visibleQuestions.push(i.id.toString()) } setGeoAnswers(t, o) { let i = ""; if (o.vooringevuldAntwoord && (i = o.vooringevuldAntwoord), i) { const r = o.opties.find(l => l.optieTekst === i), a = r.sequenceId.toString(); this.answers[t.id] || (this.answers[t.id] = a), t.vooringevuldAntwoordId = a, t.vooringevuldAntwoordValue = r.optieTekst } } addGeoverwijzing(t) { this.currentGeoverwijzingen.push({ id: t.id, tekst: t.tekst, locatieIdentificatie: t.locatieIdentificatie, vooringevuldAntwoord: t.vooringevuldAntwoord }) } unsubscribeFormChangeSubscriptions() { this.formChangeSubscriptions.forEach(t => { t && t.unsubscribe() }), this.formChangeSubscriptions = [] } cacheAndEmitAntwoorden() { const t = this.formGroup.getRawValue(); this.updateAnswers(t); const o = [], i = Object.keys(t); for (const r of i) { let s = ""; const a = t[r], l = this.questions.get(r); if ("" !== a && null !== a) { if (l.type === V.LIST_MULTIPLE) { const c = Object.keys(a).filter(p => !0 === a[p]), d = []; for (const p of c) { const g = l.options.find(C => C.id === p); d.push(g.value) } if (!(d.length > 0)) continue; s = d.join(", ") } else s = l.type === V.LIST_SINGLE ? l.options.find(d => d.id === a).value : a; const u = parseInt(l.id, 10); o.push({ id: u, antwoord: s }) } } this.logicalAnswerChanged.emit(o) } updateAnswers(t) { Object.keys(t).forEach(i => { this.answers[i] = t[i] }) } getCurrentAnsweredQuestionsCnt(t) { let o = 0; for (const i of t) if (this.answers.hasOwnProperty(i.id)) { const r = this.answers[i.id]; if ("" === r || null === r || i.type === V.LIST_MULTIPLE && 0 === Object.keys(r).filter(a => !0 === r[a]).length) continue; o++ } return o } static #e = this.\u0275fac = function (o) { return new (o || e)(b(_d), b(Tr)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["app-rtr-form"]], inputs: { vraagGroepen: "vraagGroepen", useGroups: "useGroups", showExplanations: "showExplanations", answers: "answers" }, outputs: { logicalAnswerChanged: "logicalAnswerChanged", geoverwijzingenChanged: "geoverwijzingenChanged" }, features: [Te], decls: 3, vars: 3, consts: [[1, "flo-rtr-form"], ["class", "flo-group-container", 3, "ngClass", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "flo-action-bar", 4, "ngIf"], [1, "flo-group-container", 3, "ngClass"], ["class", "flo-form-group-header", 4, "ngIf"], [1, "flo-form-questions-container"], [3, "ngClass", "question", "formGroup", "trueLabel", "falseLabel", "questionIsVisible", "listOptionsWithExplanation", "showExplanations", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "flo-form-group-header"], ["type", "button", 1, "flo-form-button", "flo-form-group-button", 3, "ngClass", "click"], [1, "flo-form-group-counter"], [3, "ngClass", "question", "formGroup", "trueLabel", "falseLabel", "questionIsVisible", "listOptionsWithExplanation", "showExplanations"], [1, "flo-action-bar"], ["type", "button", 3, "click"]], template: function (o, i) { 1 & o && (y(0, "div", 0), v(1, ck, 4, 6, "div", 1), v(2, dk, 3, 0, "div", 2), _()), 2 & o && (f(1), h("ngForOf", i.groups)("ngForTrackBy", i.groupTrackBy), f(1), h("ngIf", i.questionsToShow.length > 0)) }, dependencies: [zt, ct, Ue, jn, Hn, sk] }) } return e })(); function fk(e, n) { if (1 & e && (y(0, "li"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function hk(e, n) { if (1 & e && (y(0, "div", 11)(1, "p", 12), A(2, "De vragen kunnen niet worden weergegeven. De invoer is ongeldig"), _(), y(3, "ul", 13), v(4, fk, 2, 1, "li", 14), _()()), 2 & e) { const t = m(2); f(4), h("ngForOf", t.dataAttributeParsingService.errors) } } function pk(e, n) { 1 & e && (y(0, "div"), A(1, " Deze check kan niet worden weergegeven "), _()) } function gk(e, n) { 1 & e && (y(0, "div"), A(1, " Geen vragen "), _()) } function mk(e, n) { if (1 & e) { const t = R(); y(0, "app-rtr-form", 15), M("logicalAnswerChanged", function (i) { return S(t), x(m(2).onLogicalAnswerChanged(i)) })("geoverwijzingenChanged", function (i) { return S(t), x(m(2).onGeoverwijzingenChanged(i)) }), _() } if (2 & e) { const t = m(2); h("vraagGroepen", t.vraagGroepen)("showExplanations", t.showExplanations) } } function _k(e, n) { if (1 & e && k(0, "div", 18), 2 & e) { const t = m().$implicit; h("innerHTML", m(3).toelichtingPerConclusie.get(t.toestemmingstype.code), vn) } } function yk(e, n) { if (1 & e && (y(0, "div")(1, "h3"), A(2), _(), v(3, _k, 1, 1, "div", 17), _()), 2 & e) { const t = n.$implicit, o = m(3); f(2), j(t.toestemmingstype.waarde), f(1), h("ngIf", o.toelichtingPerConclusie.has(t.toestemmingstype.code)) } } function vk(e, n) { if (1 & e && (y(0, "div", 16), v(1, yk, 4, 2, "div", 14), _()), 2 & e) { const t = m(2); f(1), h("ngForOf", t.conclusies) } } function Ck(e, n) { 1 & e && k(0, "section", 19) } function wk(e, n) { if (1 & e) { const t = R(); y(0, "div", 1)(1, "section", 2)(2, "div", 3)(3, "h2"), A(4, "Vragen"), _(), y(5, "div", 4), A(6, "toon toelichtingen "), y(7, "input", 5), M("ngModelChange", function (i) { return S(t), x(m().showExplanations = i) }), _()()(), v(8, hk, 5, 1, "div", 6), v(9, pk, 2, 0, "div", 7), v(10, gk, 2, 0, "div", 7), v(11, mk, 1, 2, "app-rtr-form", 8), v(12, vk, 2, 1, "div", 9), _(), v(13, Ck, 1, 0, "section", 10), _() } if (2 & e) { const t = m(); f(7), h("ngModel", t.showExplanations), f(1), h("ngIf", t.dataAttributeParsingService.errors.length > 0), f(1), h("ngIf", t.invalidCheckFormat), f(1), h("ngIf", 0 === t.vraagGroepen.length), f(1), h("ngIf", 0 === t.dataAttributeParsingService.errors.length), f(1), h("ngIf", t.conclusies), f(1), h("ngIf", !0 === t.locationIsInsideWorkingArea) } } function Dk(e, n) { 1 & e && (y(0, "div", 1)(1, "p"), A(2, "De gekozen locatie valt niet binnen het werkingsgebied voor deze activiteit. Kies een andere locatie via een klik op de kaart."), _()()) } let bk = (() => { class e extends xd { constructor(t) { super(t), this.vraagGroepen = [], this.invalidCheckFormat = !1, this.toelichtingPerConclusie = new Map } ngOnChanges() { super.ngOnChanges(), 0 === this.dataAttributeParsingService.errors.length && this.fetchData().subscribe({ next: t => { try { if (!t[0].activiteiten) return void (this.locationIsInsideWorkingArea = !1); this.locationIsInsideWorkingArea = !0, this.vraagGroepen = this.getVraagGroepen(t), this.updateConclusies(t) } catch (o) { console.log(o), this.vraagGroepen = [], this.invalidCheckFormat = !0 } }, error: t => { console.log(t) } }) } onLogicalAnswerChanged(t) { this.fetchData(t).subscribe({ next: o => { o[0] && o[0].activiteiten && o[0].activiteiten.length > 0 ? (this.vraagGroepen = this.getVraagGroepen(o), this.updateConclusies(o)) : (this.vraagGroepen = [], this.conclusies = [], this.toelichtingPerConclusie.clear(), this.updateConclusies(o)) }, error: o => { console.log(o) } }) } updateConclusies(t) { this.conclusies = [], t[0] && t[0].activiteiten && t[0].activiteiten[0].conclusies && (this.conclusies = t[0].activiteiten[0].conclusies, this.toelichtingPerConclusie.clear(), this.conclusies.forEach(o => { o.toelichtingId && this.rtrApiService.getToelichting(o.toelichtingId, this.usePreEnvironment).subscribe(i => { this.toelichtingPerConclusie.set(o.toestemmingstype.code, i.toelichting) }) })) } fetchData(t = []) { return this.rtrApiService.bepaal("conclusie", this.functioneleStructuurRef, this.geometry, this.usePreEnvironment, t) } getVraagGroepen(t) { return t[0] && t[0].activiteiten && t[0].activiteiten.length > 0 && t[0].activiteiten[0].vraaggroepen ? t[0].activiteiten[0].vraaggroepen : [] } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-rtr-conclusie"]], features: [de([Ed, Tr]), oe, Te], decls: 2, vars: 2, consts: [["class", "flo-rtr-container", 4, "ngIf"], [1, "flo-rtr-container"], [1, "flo-rtr-form-container"], [1, "flo-rtr-form-header"], [1, "flo-rtr-explanations-switch"], ["type", "checkbox", "name", "show-explanations", 3, "ngModel", "ngModelChange"], ["class", "flo-input-errors-container", 4, "ngIf"], [4, "ngIf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged", "geoverwijzingenChanged", 4, "ngIf"], ["class", "flo-outcomes-container", 4, "ngIf"], ["class", "flo-rtr-side-container", 4, "ngIf"], [1, "flo-input-errors-container"], [1, "flo-input-errors-header"], [1, "flo-input-errors-content"], [4, "ngFor", "ngForOf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged", "geoverwijzingenChanged"], [1, "flo-outcomes-container"], [3, "innerHTML", 4, "ngIf"], [3, "innerHTML"], [1, "flo-rtr-side-container"]], template: function (o, i) { 1 & o && (v(0, wk, 14, 7, "div", 0), v(1, Dk, 3, 0, "div", 0)), 2 & o && (h("ngIf", i.locationIsInsideWorkingArea), f(1), h("ngIf", !1 === i.locationIsInsideWorkingArea)) }, dependencies: [ct, Ue, Tn, Bn, ai, Md] }) } return e })(); function Ek(e, n) { if (1 & e && (y(0, "li"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function Ik(e, n) { if (1 & e && (y(0, "div", 14)(1, "p", 15), A(2, "De vragen kunnen niet worden weergegeven. De invoer is ongeldig"), _(), y(3, "ul", 16), v(4, Ek, 2, 1, "li", 17), _()()), 2 & e) { const t = m(3); f(4), h("ngForOf", t.dataAttributeParsingService.errors) } } function Tk(e, n) { 1 & e && (y(0, "div"), A(1, " Deze check kan niet worden weergegeven "), _()) } function Ak(e, n) { if (1 & e) { const t = R(); y(0, "app-rtr-form", 18), M("logicalAnswerChanged", function (i) { return S(t), x(m(3).onLogicalAnswerChanged(i)) }), _() } if (2 & e) { const t = m(3); h("vraagGroepen", t.vraagGroepen)("showExplanations", t.showExplanations) } } function Sk(e, n) { if (1 & e && (y(0, "div", 25), k(1, "app-explanation", 26), _()), 2 & e) { const t = m().$implicit, o = m(4); f(1), h("content", o.bijlageToelichtingen.get(t.id).content)("extraContent", o.bijlageToelichtingen.get(t.id).extraContent || "")("showHideButton", !1) } } function xk(e, n) { if (1 & e && (y(0, "div", 21)(1, "div", 22)(2, "div")(3, "div", 23)(4, "div", 23)(5, "div"), A(6), _()()(), v(7, Sk, 2, 3, "div", 24), _()()()), 2 & e) { const t = n.$implicit, o = m(4); f(6), j(t.type), f(1), h("ngIf", o.bijlageToelichtingen.get(t.id)) } } function Mk(e, n) { if (1 & e && (y(0, "div", 19), v(1, xk, 8, 2, "div", 20), _()), 2 & e) { const t = m(3); f(1), h("ngForOf", t.bijlagen) } } const Fk = function () { return { "flo-form-group-button-active": !1 } }; function Ok(e, n) { if (1 & e) { const t = R(); y(0, "section", 4)(1, "div", 5)(2, "h2"), A(3, "Vragen"), _(), y(4, "div", 6), A(5, "toon toelichtingen "), y(6, "input", 7), M("ngModelChange", function (i) { return S(t), x(m(2).showExplanations = i) }), _()()(), v(7, Ik, 5, 1, "div", 8), v(8, Tk, 2, 0, "div", 9), v(9, Ak, 1, 2, "app-rtr-form", 10), y(10, "div", 11)(11, "button", 12), M("click", function () { return S(t), x(m(2).toggleBijlagen()) }), A(12, "Bijlagen "), _()(), v(13, Mk, 2, 1, "div", 13), _() } if (2 & e) { const t = m(2); f(6), h("ngModel", t.showExplanations), f(1), h("ngIf", t.dataAttributeParsingService.errors.length > 0), f(1), h("ngIf", t.invalidCheckFormat), f(1), h("ngIf", 0 === t.dataAttributeParsingService.errors.length), f(2), h("ngClass", function Fm(e, n, t) { const o = st() + e, i = T(); return i[o] === Y ? sn(i, o, t ? n.call(t) : n()) : function qi(e, n) { return e[n] }(i, o) }(6, Fk)), f(2), h("ngIf", t.bijlagenVisible) } } function Nk(e, n) { 1 & e && k(0, "section", 27) } function Pk(e, n) { if (1 & e && (y(0, "div", 1), v(1, Ok, 14, 7, "section", 2), v(2, Nk, 1, 0, "section", 3), _()), 2 & e) { const t = m(); f(1), h("ngIf", !0 === t.formIsAvailable), f(1), h("ngIf", !0 === t.formIsAvailable) } } function kk(e, n) { 1 & e && (y(0, "div", 1)(1, "p"), A(2, "De gekozen locatie valt niet binnen het werkingsgebied voor deze activiteit. Kies een andere locatie via een klik op de kaart."), _()()) } let Lk = (() => { class e extends xd { constructor(t) { super(t), this.vraagGroepen = [], this.invalidCheckFormat = !1, this.bijlagen = [], this.visibleBijlagen = [], this.bijlagenVisible = !1, this.bijlageToelichtingen = new Map, this.formIsAvailable = null } ngOnChanges() { super.ngOnChanges(), 0 === this.dataAttributeParsingService.errors.length && this.fetchData().subscribe({ next: t => { try { if (!t[1].subactiviteiten) return void (this.locationIsInsideWorkingArea = !1); this.locationIsInsideWorkingArea = !0, this.vraagGroepen = this.getVraagGroepen(t), this.bijlagen = this.getBijlagen(t), this.formIsAvailable = !1, (this.vraagGroepen.length > 0 || this.bijlagen.length > 0) && (this.formIsAvailable = !0), this.fetchBijlagenToelichtingen() } catch (o) { console.log(o), this.vraagGroepen = [], this.invalidCheckFormat = !0 } }, error: t => { console.log(t) } }) } onLogicalAnswerChanged(t) { this.fetchData(t).subscribe({ next: o => { this.vraagGroepen = this.getVraagGroepen(o), this.updateVisbileBijlagen(this.getBijlagen(o)) }, error: o => { console.log(o) } }) } toggleBijlagen() { this.bijlagenVisible = !this.bijlagenVisible } fetchData(t = []) { return this.rtrApiService.bepaal("indieningsvereisten", this.functioneleStructuurRef, this.geometry, this.usePreEnvironment, t) } getVraagGroepen(t) { return t[1] && t[1].subactiviteiten && t[1].subactiviteiten.length > 0 && t[1].subactiviteiten[0].vraaggroepen ? t[1].subactiviteiten[0].vraaggroepen : [] } getBijlagen(t) { return t[1] && t[1].subactiviteiten && t[1].subactiviteiten.length > 0 && t[1].subactiviteiten[0].bijlagen ? t[1].subactiviteiten[0].bijlagen : [] } fetchBijlagenToelichtingen() { this.bijlageToelichtingen.clear(); for (const t of this.bijlagen) if (t.toelichting) { const o = t.toelichting, i = [this.rtrApiService.getToelichting(o.korteToelichtingId, this.usePreEnvironment)]; o.langeToelichtingId && i.push(this.rtrApiService.getToelichting(o.langeToelichtingId, this.usePreEnvironment)), $c(i).subscribe({ next: r => { let a = ""; r[1] && (a = r[1].toelichting), this.bijlageToelichtingen.set(t.id, this.conversionService.convertToelichtingToExplanation(o.belangrijk, r[0].toelichting, a)) }, error: r => { console.log(r) } }) } } updateVisbileBijlagen(t) { this.visibleBijlagen = [], this.visibleBijlagen = t.map(o => o.id) } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-rtr-indieningsvereisten"]], features: [de([Tr]), oe, Te], decls: 2, vars: 2, consts: [["class", "flo-rtr-container", 4, "ngIf"], [1, "flo-rtr-container"], ["class", "flo-rtr-form-container", 4, "ngIf"], ["class", "flo-rtr-side-container", 4, "ngIf"], [1, "flo-rtr-form-container"], [1, "flo-rtr-form-header"], [1, "flo-rtr-explanations-switch"], ["type", "checkbox", "name", "show-explanations", 3, "ngModel", "ngModelChange"], ["class", "flo-input-errors-container", 4, "ngIf"], [4, "ngIf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged", 4, "ngIf"], [1, "flo-form-group-header"], ["type", "button", 1, "flo-form-button", "flo-form-group-button", 3, "ngClass", "click"], ["class", "flo-rtr-form flo-rtr-bijlagen", 4, "ngIf"], [1, "flo-input-errors-container"], [1, "flo-input-errors-header"], [1, "flo-input-errors-content"], [4, "ngFor", "ngForOf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged"], [1, "flo-rtr-form", "flo-rtr-bijlagen"], ["class", "flo-question-section pristine", 4, "ngFor", "ngForOf"], [1, "flo-question-section", "pristine"], [1, "flo-question-container"], [1, "flo-question-description"], ["class", "flo-explanation-container", 4, "ngIf"], [1, "flo-explanation-container"], [3, "content", "extraContent", "showHideButton"], [1, "flo-rtr-side-container"]], template: function (o, i) { 1 & o && (v(0, Pk, 3, 2, "div", 0), v(1, kk, 3, 0, "div", 0)), 2 & o && (h("ngIf", i.locationIsInsideWorkingArea), f(1), h("ngIf", !1 === i.locationIsInsideWorkingArea)) }, dependencies: [zt, ct, Ue, fi, Tn, Bn, ai, Md] }) } return e })(); function Rk(e, n) { if (1 & e && (y(0, "li"), A(1), _()), 2 & e) { const t = n.$implicit; f(1), j(t) } } function Vk(e, n) { if (1 & e && (y(0, "div", 13)(1, "p", 14), A(2, "De vragen kunnen niet worden weergegeven. De invoer is ongeldig"), _(), y(3, "ul", 15), v(4, Rk, 2, 1, "li", 16), _()()), 2 & e) { const t = m(2); f(4), h("ngForOf", t.dataAttributeParsingService.errors) } } function Bk(e, n) { 1 & e && (y(0, "div"), A(1, " Deze check kan niet worden weergegeven "), _()) } function jk(e, n) { if (1 & e) { const t = R(); y(0, "app-rtr-form", 17), M("logicalAnswerChanged", function (i) { return S(t), x(m(2).onLogicalAnswerChanged(i)) }), _() } if (2 & e) { const t = m(2); h("vraagGroepen", t.vraagGroepen)("showExplanations", t.showExplanations) } } function Hk(e, n) { 1 & e && (y(0, "div"), A(1, " Geen vragen, deze maatregelen gelden altijd. "), _()) } function Uk(e, n) { if (1 & e && (y(0, "tr")(1, "td"), A(2, "Thema's"), _(), y(3, "td"), A(4), _()()), 2 & e) { const t = m().$implicit; f(4), j(t.maatregel.themas.join("; ")) } } function $k(e, n) { if (1 & e && (y(0, "tr")(1, "td"), A(2, "Kenmerken"), _(), y(3, "td"), A(4), _()()), 2 & e) { const t = m().$implicit; f(4), j(t.maatregel.kenmerken.join("; ")) } } function qk(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "span", 24), M("click", function () { S(t); const i = m(2).$implicit; return x(m(2).toggleToelichting(i)) }), A(2, "toon toelichting"), _()() } } function Gk(e, n) { 1 & e && k(0, "div", 25), 2 & e && h("innerHTML", m(2).$implicit.maatregel.toelichting, vn) } function Qk(e, n) { if (1 & e) { const t = R(); y(0, "div")(1, "span", 24), M("click", function () { S(t); const i = m(2).$implicit; return x(m(2).toggleToelichting(i)) }), A(2, "verberg toelichting"), _()() } } function zk(e, n) { if (1 & e && (y(0, "div", 22), v(1, qk, 3, 0, "div", 8), v(2, Gk, 1, 1, "div", 23), v(3, Qk, 3, 0, "div", 8), _()), 2 & e) { const t = m().$implicit; f(1), h("ngIf", !t.toelichtingVisible), f(1), h("ngIf", t.toelichtingVisible), f(1), h("ngIf", t.toelichtingVisible) } } function Wk(e, n) { if (1 & e && (y(0, "div", 18)(1, "div", 19)(2, "h3"), A(3), _(), y(4, "table", 20)(5, "tbody")(6, "tr")(7, "td"), A(8, "Frequentie"), _(), y(9, "td"), A(10), _()(), y(11, "tr")(12, "td"), A(13, "Basis in de wet"), _(), y(14, "td"), A(15), _()(), v(16, Uk, 5, 1, "tr", 8), v(17, $k, 5, 1, "tr", 8), _()(), v(18, zk, 4, 3, "div", 21), _()()), 2 & e) { const t = n.$implicit; f(3), Ps("", t.maatregel.nummer, ": ", t.maatregel.maatregeltekst, ""), f(7), j(t.maatregel.frequentie), f(5), j(t.source), f(1), h("ngIf", t.maatregel.themas), f(1), h("ngIf", t.maatregel.kenmerken), f(1), h("ngIf", t.maatregel.toelichting) } } function Kk(e, n) { if (1 & e) { const t = R(); y(0, "div", 2)(1, "section", 3)(2, "div", 4)(3, "h2"), A(4, "Vragen"), _(), y(5, "div", 5), A(6, "toon toelichtingen "), y(7, "input", 6), M("ngModelChange", function (i) { return S(t), x(m().showExplanations = i) }), _()()(), v(8, Vk, 5, 1, "div", 7), v(9, Bk, 2, 0, "div", 8), v(10, jk, 1, 2, "app-rtr-form", 9), v(11, Hk, 2, 0, "div", 8), _(), y(12, "section", 10)(13, "h2"), A(14, "Maatregelen"), _(), y(15, "div", 11), v(16, Wk, 19, 7, "div", 12), _()()() } if (2 & e) { const t = m(); f(7), h("ngModel", t.showExplanations), f(1), h("ngIf", t.dataAttributeParsingService.errors.length > 0), f(1), h("ngIf", t.invalidCheckFormat), f(1), h("ngIf", 0 === t.dataAttributeParsingService.errors.length && t.vraagGroepen.length > 0), f(1), h("ngIf", 0 === t.vraagGroepen.length && t.maatregelen.length > 0), f(5), h("ngForOf", t.maatregelen) } } function Yk(e, n) { 1 & e && (y(0, "div", 26)(1, "p"), A(2, "De gekozen locatie valt niet binnen het werkingsgebied voor deze activiteit. Kies een andere locatie via een klik op de kaart."), _()()) } let Jk = (() => { class e extends xd { constructor(t) { super(t), this.vraagGroepen = [], this.invalidCheckFormat = !1, this.maatregelen = [] } ngOnChanges() { super.ngOnChanges(), 0 === this.dataAttributeParsingService.errors.length && this.fetchData().subscribe({ next: t => { try { if (!t[0].activiteiten) return void (this.locationIsInsideWorkingArea = !1); this.locationIsInsideWorkingArea = !0, this.vraagGroepen = this.getVraagGroepen(t), this.updateMaatregelen(t) } catch (o) { console.log(o), this.vraagGroepen = [], this.invalidCheckFormat = !0 } }, error: t => { console.log(t) } }) } onLogicalAnswerChanged(t) { this.fetchData(t).subscribe({ next: o => { this.vraagGroepen = this.getVraagGroepen(o), this.updateMaatregelen(o) }, error: o => { console.log(o) } }) } toggleToelichting(t) { t.toelichtingVisible = !t.toelichtingVisible } updateMaatregelen(t) { let o = []; if (t[0] && t[0].activiteiten && t[0].activiteiten.length > 0 && t[0].activiteiten[0].voorschriften) { const i = t[0].activiteiten[0].voorschriften; for (const r of i) if (r.maatregelen) for (const s of r.maatregelen) o.push({ maatregel: s, toelichtingVisible: !1, source: this.getSourceFormVoorschrift(r) }); this.maatregelen = o.sort((r, s) => r.maatregel.volgorde - s.maatregel.volgorde) } } fetchData(t = []) { return this.rtrApiService.bepaal("maatregelen", this.functioneleStructuurRef, this.geometry, this.usePreEnvironment, t) } getVraagGroepen(t) { return t[0] && t[0].activiteiten && t[0].activiteiten.length > 0 && t[0].activiteiten[0].vraaggroepen ? t[0].activiteiten[0].vraaggroepen : [] } getSourceFormVoorschrift(t) { return t.juridischeLink.replace("titelzonderlink=", "") } static #e = this.\u0275fac = function (o) { return new (o || e)(b($e)) }; static #t = this.\u0275cmp = he({ type: e, selectors: [["flo-rtr-maatregelen"]], features: [de([Tr]), oe, Te], decls: 2, vars: 2, consts: [["class", "flo-rtr-container flo-maatregelen-container", 4, "ngIf"], ["class", "flo-rtr-container", 4, "ngIf"], [1, "flo-rtr-container", "flo-maatregelen-container"], [1, "flo-rtr-form-container"], [1, "flo-rtr-form-header"], [1, "flo-rtr-explanations-switch"], ["type", "checkbox", "name", "show-explanations", 3, "ngModel", "ngModelChange"], ["class", "flo-input-errors-container", 4, "ngIf"], [4, "ngIf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged", 4, "ngIf"], [1, "flo-rtr-side-container"], [1, "flo-form-questions-container"], ["class", "flo-question-section pristine", 4, "ngFor", "ngForOf"], [1, "flo-input-errors-container"], [1, "flo-input-errors-header"], [1, "flo-input-errors-content"], [4, "ngFor", "ngForOf"], [3, "vraagGroepen", "showExplanations", "logicalAnswerChanged"], [1, "flo-question-section", "pristine"], [1, "flo-question-container"], [1, "flo-maatregelen-attributes"], ["class", "flo-maatregelen-toelichting", 4, "ngIf"], [1, "flo-maatregelen-toelichting"], [3, "innerHTML", 4, "ngIf"], [1, "flo-link-button", 3, "click"], [3, "innerHTML"], [1, "flo-rtr-container"]], template: function (o, i) { 1 & o && (v(0, Kk, 17, 6, "div", 0), v(1, Yk, 3, 0, "div", 1)), 2 & o && (h("ngIf", i.locationIsInsideWorkingArea), f(1), h("ngIf", !1 === i.locationIsInsideWorkingArea)) }, dependencies: [ct, Ue, Tn, Bn, ai, Md] }) } return e })(), Zk = (() => { class e { constructor(t) { this.injector = t } ngDoBootstrap() { if (!customElements.get("flo-decision")) { const t = po(B2, { injector: this.injector }); customElements.define("flo-decision", t) } if (!customElements.get("flo-rtr-conclusie")) { const t = po(bk, { injector: this.injector }); customElements.define("flo-rtr-conclusie", t) } if (!customElements.get("flo-rtr-indieningsvereisten")) { const t = po(Lk, { injector: this.injector }); customElements.define("flo-rtr-indieningsvereisten", t) } if (!customElements.get("flo-rtr-maatregelen")) { const t = po(Jk, { injector: this.injector }); customElements.define("flo-rtr-maatregelen", t) } if (!customElements.get("flo-combi-decision")) { const t = po(OP, { injector: this.injector }); customElements.define("flo-combi-decision", t) } if (!customElements.get("flo-form")) { const t = po(k2, { injector: this.injector }); customElements.define("flo-form", t) } if (!customElements.get("flo-smart-document")) { const t = po(TP, { injector: this.injector }); customElements.define("flo-smart-document", t) } } static #e = this.\u0275fac = function (o) { return new (o || e)(q($e)) }; static #t = this.\u0275mod = it({ type: e }); static #n = this.\u0275inj = Je({ imports: [Gx, ud, md, j2, NP] }) } return e })(); qx().bootstrapModule(Zk).catch(e => console.error(e)) } }, se => { se(se.s = 702) }]);